<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Canvas - V1.5</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Pacifico&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="chord-intervals-config.js"></script>
    <script src="chord-presets.js"></script>
    <script src="grid-manager.js"></script>
    <script src="piano-visualizer.js"></script>
    <script src="piano-sound.js"></script>
    <script src="chordcortex.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            max-width: 100%;
            margin: 0;
            padding: 12px 16px;
            background: #ffffff;
            color: #1a1a1a;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: -0.01em;
            line-height: 1.4;
        }
        
        .page-header {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 2px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
        }
        
        .header-section {
            flex: 1;
            min-width: 200px;
        }
        
        .header-section.bpm-section {
            min-width: 250px;
        }
        
        .header-section.full-width {
            flex: 1 1 100%;
        }
        
        .header-section h3 {
            margin: 0 0 6px 0;
            color: #1a1a1a;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        
        
        #selectionScreen { 
            display: block;
            margin: 0 auto;
            padding-top: 0;
            max-width: 700px;
            position: relative;
        }
        #selectionScreen.hidden { display: none; }
        #mainScreen { display: none; }
        #mainScreen.visible { display: block; }
        
        .selection-container {
            max-width: 700px;
            margin: 0 auto;
            padding: 0;
            background: transparent;
            border: none;
            border-radius: 0;
            position: relative;
        }
        
        
        #mainScreen {
            margin: 0 auto;
            padding-top: 0;
            max-width: 700px;
            position: relative;
        }
        
        #mainScreen h1 {
            font-family: 'Pacifico', cursive;
            font-weight: 400;
            margin-top: 0;
            margin-bottom: 0;
        }
        
        .selection-section {
            margin-bottom: 10px;
            padding: 20px;
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 2px;
        }
        
        .selection-section:first-of-type {
            margin-top: 0;
        }
        
        .selection-section h2 {
            margin: 0 0 6px 0;
            color: #666;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        #chordInput {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 13px;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            background: #ffffff;
            color: #1a1a1a;
            resize: vertical;
            font-family: monospace;
            transition: border-color 0.2s;
        }
        
        #chordInput:focus {
            outline: none;
            border-color: #1a1a1a;
        }
        
        #presetSelect {
            width: 100%;
            padding: 6px;
            font-size: 13px;
            background: #ffffff;
            color: #1a1a1a;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            margin-bottom: 6px;
            transition: border-color 0.2s;
        }
        
        #presetSelect:focus {
            outline: none;
            border-color: #1a1a1a;
        }
        
        .simple-tooltip {
            position: absolute;
            background: #ffffcc;
            color: #1a1a1a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-5px);
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .simple-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .simple-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid #ffffcc;
        }
        
        .tutorial-highlight {
            position: relative;
            transition: box-shadow 0.3s;
        }
        
        .tutorial-highlight.active {
            box-shadow: 0 0 0 3px rgba(26, 26, 26, 0.4);
            z-index: 9998;
        }
        
        /* Tutorial Prompt Modal */
        .tutorial-prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-prompt-modal.show {
            display: flex;
        }
        
        .tutorial-prompt-content {
            background: #ffffff;
            padding: 24px;
            border-radius: 4px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .tutorial-prompt-content h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 500;
            color: #1a1a1a;
        }
        
        .tutorial-prompt-content p {
            margin: 0 0 20px 0;
            font-size: 14px;
            color: #666;
            line-height: 1.5;
        }
        
        .tutorial-prompt-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .tutorial-prompt-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .tutorial-prompt-checkbox label {
            font-size: 13px;
            color: #666;
            cursor: pointer;
        }
        
        .tutorial-prompt-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .tutorial-prompt-buttons button {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 2px;
            cursor: pointer;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            color: #1a1a1a;
            transition: all 0.2s;
        }
        
        .tutorial-prompt-buttons button:hover {
            background: #f8f8f8;
        }
        
        .tutorial-prompt-buttons button.primary {
            background: #1a1a1a;
            color: #ffffff;
            border-color: #1a1a1a;
        }
        
        .tutorial-prompt-buttons button.primary:hover {
            background: #333;
            border-color: #333;
        }
        
        /* Tutorial button - fixed top right */
        .tutorial-help-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            font-size: 12px;
            background: #ffffff;
            color: #1a1a1a;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }
        
        .tutorial-help-btn:hover {
            background: #f8f8f8;
            border-color: #1a1a1a;
            color: #1a1a1a;
        }
        
        /* Hide tutorial buttons when screens are hidden */
        #mainScreen:not(.visible) #showMainTutorialBtn {
            display: none;
        }
        
        
        .chord-preview {
            margin-top: 8px;
            padding: 8px;
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 2px;
            min-height: 40px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .chord-preview-item {
            padding: 3px 8px;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            font-size: 12px;
            color: #1a1a1a;
            transition: background 0.2s, color 0.2s;
        }
        
        
        .chord-preview-item.playing {
            background: transparent;
            border: 1px solid transparent;
            color: rgb(33, 150, 243);
        }
        
        .chord-preview-item.current.playing {
            background: transparent;
            border: 1px solid transparent;
            color: rgb(33, 150, 243);
        }
        
        button {
            padding: 6px 12px;
            font-size: 12px;
            background: #1a1a1a;
            color: #ffffff;
            border: 1px solid #1a1a1a;
            border-radius: 2px;
            cursor: pointer;
            margin-right: 6px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        button:hover { 
            background: #333;
            border-color: #333;
        }
        button.active { 
            background: #ffffff;
            color: #1a1a1a;
            border-color: #1a1a1a;
        }
        button:disabled { 
            background: #f0f0f0; 
            color: #999; 
            border-color: #e5e5e5;
            cursor: not-allowed; 
        }
        
        #toggleBtn {

            color: #1a1a1a;
            border-color: rgb(33, 150, 243); 
            background: rgba(33, 150, 243, 0.3);
        }
        
        #playHiddenBtn {
            color: rgba(33, 150, 243);
        }
        
        #prevBtn, #nextChordBtn {
            background: #ffffff;
            border: 1px solid #d0d0d0;
            color: #1a1a1a;
        }
        
        #prevBtn:hover, #nextChordBtn:hover {
            background: #f8f8f8;
            border-color: #1a1a1a;
        }
        
        h1 { 
            margin: 0 0 8px 0; 
            font-size: 16px; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            font-weight: 500;
            letter-spacing: -0.02em;
            color: #1a1a1a;
        }
        
        h2 {
            font-weight: 500;
            letter-spacing: -0.01em;
            color: #1a1a1a;
        }
        
        .controls {
            margin-bottom: 10px;
            padding: 10px;
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 2px;
        }
        
        .controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        .controls-row:last-child { margin-bottom: 0; }
        
        .bpm-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bpm-slider { flex: 1; min-width: 150px; }
        .bpm-display { min-width: 70px; font-size: 13px; font-weight: 500; }
        
        .chord-navigation {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 1px;
            background: #e5e5e5;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            overflow: hidden;
            padding: 0;
            width: 100%;
        }
        
        
        .grid-cell {
            padding: 1px;
            margin: 0;
            background: #ffffff;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 13px;
            line-height: 1;
            color: #1a1a1a;
        }
        
        .grid-cell:hover:not(.header) { background: #f8f8f8; }
        .grid-cell.header {
            background: #fafafa;
            cursor: default;
            font-weight: 600;
            color: #666;
        }
        
        .grid-cell.header.row-header {
            color: #666;
        }
        
        .grid-cell.header.col-header {
            color: #666;
        }
        
        /* Header fade animation keyframes */
        @keyframes headerFade {
            0% { background-color: #d0d0d0; }
            50% { background-color: #e8e8e8; }
            100% { background-color: #fafafa; }
        }
        
        .grid-cell.header.animated {
            animation: headerFade linear infinite;
        }
        
        .grid-cell.active {
            background: #1a1a1a;
            color: #ffffff;
        }
        
        /* Prevent tutorial highlight from changing header colors */
        .grid-cell.header.tutorial-highlight.active {
            background: #fafafa !important;
            color: #666 !important;
        }
        .grid-cell.pending {
            background: #f0f0f0;
            border: 1px solid #d0d0d0;
        }
        .grid-cell.pending:hover:not(.header) {
            background: #e8e8e8;
        }
        
        /* Piano Visualizer Styles - Now injected by piano-visualizer.js */
        
        .volume-modulation-display {
            margin-top: 8px;
            padding: 8px;
            background: #ffffff;
            border-radius: 2px;
            border: 1px solid #e5e5e5;
        }
        
        .volume-modulation-display h3 {
            margin: 0 0 4px 0;
            color: #1a1a1a;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        
        .chord-sequence-display {
            padding: 0;
        }
        
        .chord-sequence-display h3 {
            margin: 0 0 6px 0;
            color: #1a1a1a;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        
        .chord-sequence-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .chord-sequence-item {
            padding: 3px 8px;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            font-size: 11px;
            transition: all 0.2s;
            cursor: pointer;
            color: #1a1a1a;
        }
        
        .chord-sequence-item:hover {
            border-color: #1a1a1a;
        }
        
        .chord-sequence-item.current {
            border-color: rgb(33, 150, 243);
            background: rgba(33, 150, 243, 0.3);
            font-weight: 500;
        }
        
        .debug-display {
            padding: 0;
        }
        
        .debug-display h3 {
            margin: 0 0 6px 0;
            color: #1a1a1a;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        
        .debug-section {
            margin-bottom: 0;
            margin-right: 16px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .debug-section:last-child { margin-right: 0; }
        
        .debug-section-label {
            font-weight: 600;
            color: #666;
            margin-bottom: 0;
            font-size: 11px;
            white-space: nowrap;
        }
        
        .debug-notes {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .debug-note-item {
            padding: 3px 6px;
            background: #f8f8f8;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            font-size: 11px;
            font-family: monospace;
            color: #1a1a1a;
        }
        
        .debug-note-item.bass {
            background: #f0f0f0;
            border-color: #d0d0d0;
        }
        
        .debug-note-item.high {
            background: #f0f0f0;
            border-color: #d0d0d0;
        }
        
        label { font-size: 12px; white-space: nowrap; color: #1a1a1a; }
        select { 
            padding: 4px; 
            font-size: 12px; 
            background: #ffffff; 
            color: #1a1a1a; 
            border: 1px solid #d0d0d0; 
            border-radius: 2px;
            transition: border-color 0.2s;
        }
        select:focus {
            outline: none;
            border-color: #1a1a1a;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #e5e5e5;
            border-radius: 2px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #1a1a1a;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #1a1a1a;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .synth-tab {
            transition: all 0.2s;
        }
        
        .synth-controls-panel {
            padding: 8px 0;
        }
        
        h1 a {
            color: #1a1a1a;
            text-decoration: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        h1 a:hover {
            opacity: 0.6;
        }
    </style>
</head>
<body>
    
    <!-- Tutorial Prompt Modal -->
    <div id="tutorialPromptModal" class="tutorial-prompt-modal">
        <div class="tutorial-prompt-content">
            <h3>Welcome to Chord Canvas!</h3>
            <p>Do you want a quick tutorial?</p>
            <div class="tutorial-prompt-checkbox">
                <input type="checkbox" id="neverShowTutorial">
                <label for="neverShowTutorial">Never show this again</label>
            </div>
            <div class="tutorial-prompt-buttons">
                <button id="tutorialPromptNo">No, thanks</button>
                <button id="tutorialPromptYes" class="primary">Yes, show me</button>
            </div>
        </div>
    </div>
    
    <!-- Selection Screen -->
    <div id="selectionScreen">
        <!-- Page Header -->
        <div class="page-header">
            <div class="header-section" style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: space-between;">
                <h1 style="margin: 0; padding: 0; font-size: 18px; line-height: 1.2; font-family: 'Pacifico', cursive; font-weight: 400;"><a href="../index.html" style="text-decoration: none; color: inherit;">Chord Canvas</a></h1>
                <button id="showTutorialBtn" class="tutorial-help-btn" title="Show tutorial tips" style="position: static;">Tutorial</button>
            </div>
            
            <div class="header-section full-width">
                <select id="presetSelect"></select>
            </div>
            <div class="header-section full-width">
                <textarea id="chordInput" placeholder="Am, D7, G, C"></textarea>
            </div>
            <div class="header-section full-width">
                <div id="chordPreview" class="chord-preview"></div>
            </div>
        </div>
    </div>
    
    <!-- Main Screen -->
    <div id="mainScreen" style="margin-top: 0; padding-top: 0;">
        <!-- Page Header -->
        <div class="page-header">
            <div class="header-section" style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; line-height: 1.2;">
                    <h1 id="mainScreenTitle" style="margin: 0; padding: 0; font-size: 18px; line-height: 1.2;">Chord Canvas</h1>
                </div>
                <div class="bpm-control" style="display: flex; align-items: center; gap: 6px; flex: 1; min-width: 200px;">
                    <input type="range" id="bpmSlider" class="bpm-slider" min="40" max="240" value="120" step="1" style="flex: 1; min-width: 150px;">
                    <div class="bpm-display" id="bpmDisplay" style="min-width: 70px; font-size: 13px; font-weight: bold;">120 BPM</div>
                </div>
                <button id="showMainTutorialBtn" class="tutorial-help-btn" title="Show tutorial tips" style="position: static; margin-left: auto;">Tutorial</button>
            </div>
            
            <!-- Synth Controls Navbar -->
            <div class="header-section full-width" style="margin-top: 8px;">
                <div style="display: flex; gap: 8px; margin-bottom: 8px; border-bottom: 1px solid #e5e5e5;">
                    <button id="waterControlsTab" class="synth-tab active" style="padding: 6px 12px; background: #1a1a1a; border: 1px solid #1a1a1a; border-radius: 2px 2px 0 0; color: #ffffff; cursor: pointer; font-size: 12px; font-weight: 500;">Water Synth</button>
                    <button id="pluckyControlsTab" class="synth-tab" style="padding: 6px 12px; background: #ffffff; border: 1px solid #e5e5e5; border-radius: 2px 2px 0 0; color: #666; cursor: pointer; font-size: 12px; font-weight: 500;">Plucky Synth</button>
                    <button id="subControlsTab" class="synth-tab" style="padding: 6px 12px; background: #ffffff; border: 1px solid #e5e5e5; border-radius: 2px 2px 0 0; color: #666; cursor: pointer; font-size: 12px; font-weight: 500;">Sub Synth</button>
                </div>
                
                <!-- Water Synth Controls -->
                <div id="waterControlsPanel" class="synth-controls-panel">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Water Profile</div>
                            <select id="waterProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="waterVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterVolumeSlider" class="bpm-slider" min="0" max="100" value="50" step="1">
                                <div class="bpm-display" id="waterVolumeDisplay">50%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterReverbSlider" class="bpm-slider" min="0" max="100" value="77" step="1">
                                <div class="bpm-display" id="waterReverbDisplay">77%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterAttackSlider" class="bpm-slider" min="1" max="100" value="20" step="1">
                                <div class="bpm-display" id="waterAttackDisplay">20ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterHarmonic2Slider" class="bpm-slider" min="0" max="100" value="30" step="1">
                                <div class="bpm-display" id="waterHarmonic2Display">30%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">2nd Harmonic</div>
                        </div>
                    </div>
                </div>
                
                <!-- Plucky Synth Controls -->
                <div id="pluckyControlsPanel" class="synth-controls-panel" style="display: none;">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Plucky Profile</div>
                            <select id="pluckyProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="pluckyVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyVolumeSlider" class="bpm-slider" min="0" max="100" value="50" step="1">
                                <div class="bpm-display" id="pluckyVolumeDisplay">50%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyReverbSlider" class="bpm-slider" min="0" max="100" value="77" step="1">
                                <div class="bpm-display" id="pluckyReverbDisplay">77%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyAttackSlider" class="bpm-slider" min="1" max="100" value="66" step="1">
                                <div class="bpm-display" id="pluckyAttackDisplay">66ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                    </div>
                </div>
                
                <!-- Sub Synth Controls -->
                <div id="subControlsPanel" class="synth-controls-panel" style="display: none;">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Sub Profile</div>
                            <select id="subProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="subVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #1a1a1a; border: 1px solid #d0d0d0; border-radius: 2px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subVolumeSlider" class="bpm-slider" min="0" max="100" value="22" step="1">
                                <div class="bpm-display" id="subVolumeDisplay">22%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subReverbSlider" class="bpm-slider" min="0" max="100" value="12" step="1">
                                <div class="bpm-display" id="subReverbDisplay">12%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subAttackSlider" class="bpm-slider" min="1" max="100" value="80" step="1">
                                <div class="bpm-display" id="subAttackDisplay">80ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subSaturationSlider" class="bpm-slider" min="0" max="100" value="5" step="1">
                                <div class="bpm-display" id="subSaturationDisplay">5%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Saturation</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Grids - only show active sound's grid -->
            <div style="margin-top: 12px; align-self: flex-start; width: 100%;">
                <div class="grid" id="waterGrid"></div>
                <div class="grid" id="pluckyGrid" style="display: none;"></div>
                <div class="grid" id="subGrid" style="display: none;"></div>
            </div>
            
            <div class="header-section">
                <div class="debug-display">
                    <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 0;">
                        <div class="debug-section">
                            <div class="debug-section-label">Bass:</div>
                            <div class="debug-notes" id="debugBassNotes"><span style="color: #666;">-</span></div>
                        </div>
                        <div class="debug-section">
                            <div class="debug-section-label">High:</div>
                            <div class="debug-notes" id="debugHighNotes"><span style="color: #666;">-</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chord-sequence-display" style="flex: 1 1 100%;">
                <div class="chord-sequence-list" id="chordSequenceList"></div>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 6px;">
                    <div style="display: flex; gap: 6px;">
                        <button id="toggleBtn">▶︎ Start</button>
                        <button id="prevBtn">←</button>
                        <button id="nextChordBtn">→</button>
                        <button id="toggleMainScreenBtn" style="background: none; border: none; cursor: pointer; font-size: 1.4em; padding: 2px 6px; margin: 0; transition: opacity 0.2s; color: #1a1a1a; line-height: 1; vertical-align: middle;" title="Toggle main screen">⁝</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ========== CHORD PARSER ==========
        // Use values from chord-intervals-config.js (already loaded)
        // Create local references to avoid redeclaration errors
        const NOTE_TO_INDEX_REF = window.NOTE_TO_INDEX || {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8,
            'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };
        
        const CHORD_INTERVALS_REF = window.CHORD_INTERVALS || {
            'major-triad': [-24, -12, -5, 0, 4, 7],
            'minor-triad': [-24, -12, -5, 0, 3, 7],
            'dominant-7th': [-24, -12, -5, 0, 4, 7, 10],
            'minor-7th': [-24, -12, -5, 0, 3, 7, 10],
            'major-7th': [-24, -12, -5, 0, 4, 7, 11],
            'diminished-7th': [-24, -12, -6, 0, 3, 6, 9],
            'diminished-triad': [-24, -12, -6, 0, 3, 6],
            'augmented-triad': [-24, -12, -4, 0, 4, 8],
            'major-6th': [-24, -12, -5, 0, 4, 7, 9],
            'minor-6th': [-24, -12, -5, 0, 3, 7, 9],
            'dominant-9th': [-24, -12, -5, 0, 4, 7, 10, 14],
            'major-9th': [-24, -12, -5, 0, 4, 7, 11, 14],
            'minor-9th': [-24, -12, -5, 0, 3, 7, 10, 14],
            'dominant-11th': [-24, -12, -5, 0, 4, 7, 10, 17],
            'minor-11th': [-24, -12, -5, 0, 3, 7, 10, 17],
            'major-11th': [-24, -12, -5, 0, 4, 7, 11, 14, 17],
            'add9': [-24, -12, -5, 0, 4, 7, 14],
            'add11': [-24, -12, -5, 0, 4, 7, 17],
            'add13': [-24, -12, -5, 0, 4, 7, 21],
            '7sharp11': [-24, -12, -5, 0, 4, 7, 10, 18],
            '9sharp11': [-24, -12, -5, 0, 4, 7, 10, 14, 18],
            'sus2': [-24, -12, -5, 0, 2, 7],
            'sus4': [-24, -12, -5, 0, 5, 7]
        };
        
        function parseChord(input) {
            const trimmed = input.trim();
            if (!trimmed) return null;
            
            const match = trimmed.match(/^([A-Ga-g])([#b]?)(.*)$/i);
            if (!match) return null;
            
            const rootLetter = match[1].toUpperCase();
            const accidental = match[2] || '';
            const suffix = match[3]; // Keep case-sensitive for M vs m distinction
            const noteName = rootLetter + accidental;
            
            if (!NOTE_TO_INDEX_REF.hasOwnProperty(noteName)) return null;
            
            let chordType = 'major-triad';
            let processedSuffix = suffix;
            
            const slashIndex = suffix.indexOf('/');
            if (slashIndex !== -1) {
                processedSuffix = suffix.substring(0, slashIndex);
            }
            
            // Check uppercase M patterns first (before lowercase m patterns)
            const suffixLower = processedSuffix.toLowerCase();
            
            if (processedSuffix === 'M7' || processedSuffix === 'maj7' || processedSuffix === 'major7' || suffixLower === 'ma7') {
                chordType = 'major-7th';
            } else if (processedSuffix === 'M9' || processedSuffix === 'maj9' || processedSuffix === 'major9') {
                chordType = 'major-9th';
            } else if (processedSuffix === 'M11' || processedSuffix === 'maj11' || processedSuffix === 'major11') {
                chordType = 'major-11th';
            } else if (suffixLower === 'm' || suffixLower === 'min' || processedSuffix === '-') {
                chordType = 'minor-triad';
            } else if (suffixLower === '7' || suffixLower === 'dom' || suffixLower === 'dom7') {
                chordType = 'dominant-7th';
            } else if (suffixLower === 'm7' || suffixLower === 'min7') {
chordType = 'minor-7th';
            } else if (suffixLower.includes('dim') || processedSuffix.includes('°')) {
                // Check for diminished 7th first (dim7 or °7)
                if (suffixLower.includes('7') || processedSuffix.includes('°7') || processedSuffix === '°7') {
                    chordType = 'diminished-7th';
                } else {
                    chordType = 'diminished-triad';
                }
            } else if (suffixLower.includes('aug') || processedSuffix === '+') {
                chordType = 'augmented-triad';
            } else if (suffixLower === 'm9' || suffixLower === 'min9' || processedSuffix === '-9') {
                chordType = 'minor-9th';
            } else if (processedSuffix === '9') {
                chordType = 'dominant-9th';
            } else if (suffixLower === 'm11' || suffixLower === 'min11' || processedSuffix === '-11') {
                chordType = 'minor-11th';
            } else if (processedSuffix === '11') {
                chordType = 'dominant-11th'; // Standard notation: no prefix = dominant
            } else if (processedSuffix === '6') {
                chordType = 'major-6th';
            } else if (suffixLower === 'm6' || suffixLower === 'min6' || processedSuffix === '-6') {
                chordType = 'minor-6th';
            } else if (suffixLower.includes('add9')) {
                chordType = 'add9';
            } else if (suffixLower.includes('add11')) {
                chordType = 'add11';
            } else if (suffixLower.includes('add13')) {
                chordType = 'add13';
            } else if (suffixLower.includes('7#11') || suffixLower.includes('7(#11)') || suffixLower.includes('7+11')) {
                chordType = '7sharp11';
            } else if (suffixLower.includes('9#11') || suffixLower.includes('9(#11)') || suffixLower.includes('9+11')) {
                chordType = '9sharp11';
            } else if (suffixLower.includes('sus2') || suffixLower === 'sus2') {
                chordType = 'sus2';
            } else if (suffixLower.includes('sus4') || suffixLower === 'sus' || suffixLower === 'sus4') {
                chordType = 'sus4';
            }
            
            return { rootNote: noteName, chordType, original: trimmed };
        }
        
        // Make parseChord globally accessible
        window.parseChord = parseChord;
        
        // Function to get formatted chord name from rootNote and chordType
        function getChordDisplayName(rootNote, chordType) {
            // Map chord types to display names
            const chordTypeNames = {
                'major-triad': '',
                'minor-triad': 'm',
                'diminished-triad': 'dim',
                'augmented-triad': 'aug',
                'dominant-7th': '7',
                'minor-7th': 'm7',
                'major-7th': 'maj7',
                'diminished-7th': 'dim7',
                'major-6th': '6',
                'minor-6th': 'm6',
                'dominant-9th': '9',
                'major-9th': 'maj9',
                'minor-9th': 'm9',
                'dominant-11th': '11',
                'minor-11th': 'm11',
                'major-11th': 'maj11',
                'add9': 'add9',
                'add11': 'add11',
                'add13': 'add13',
                '7sharp11': '7#11',
                '9sharp11': '9#11',
                'sus2': 'sus2',
                'sus4': 'sus4'
            };
            
            const suffix = chordTypeNames[chordType] || '';
            return suffix ? `${rootNote}${suffix}` : rootNote;
        }
        
        function parseChordSequence(input) {
            return input.split(',').map(s => s.trim()).filter(s => s)
                .map(str => parseChord(str)).filter(c => c !== null);
        }
        
        /**
         * Shared function: Convert chord intervals to note objects with note name and octave
         * This is the canonical function for getting notes from a chord
         * @param {string} rootNote - Root note name (e.g., 'C', 'C#')
         * @param {string} chordType - Chord type (e.g., 'major-triad')
         * @param {number} baseOctave - Base octave to start from (default: 4 for C4)
         * @returns {Array} Array of {note: string, octave: number} objects
         */
        function getChordNotesFromIntervals(rootNote, chordType, baseOctave = 4) {
            const rootIndex = NOTE_TO_INDEX_REF[rootNote];
            if (rootIndex === undefined) return [];
            
            const intervals = CHORD_INTERVALS_REF[chordType];
            if (!intervals) return [];
            
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const notesWithOctaves = [];
            
            // Convert intervals to note names with octaves
            intervals.forEach((interval) => {
                const totalSemitones = rootIndex + interval;
                // Handle negative modulo correctly: -5 % 12 = -5, but we want 7
                let noteIndex = totalSemitones % 12;
                if (noteIndex < 0) {
                    noteIndex += 12;
                }
                const noteName = noteNames[noteIndex];
                
                // Calculate octave: start from base octave, add octave for each 12 semitones
                // For negative intervals, Math.floor correctly handles: -24/12 = -2, -5/12 = -1
                const octaveOffset = Math.floor(totalSemitones / 12);
                const octave = baseOctave + octaveOffset;
                
                notesWithOctaves.push({
                    note: noteName,
                    octave: octave
                });
            });
            
            // Sort by octave first, then by note index (lowest first)
            notesWithOctaves.sort((a, b) => {
                if (a.octave !== b.octave) {
                    return a.octave - b.octave;
                }
                const aIndex = NOTE_TO_INDEX_REF[a.note];
                const bIndex = NOTE_TO_INDEX_REF[b.note];
                return aIndex - bIndex;
            });
            
            return notesWithOctaves;
        }
        
        // Expose shared function globally so PianoVisualizer can use it
        window.getChordNotesFromIntervals = getChordNotesFromIntervals;
        
        /**
         * Convert chord to MIDI notes, split into bass (lowest 3) and high (highest 3)
         * Used by the main sequence playback system for synth layers
         * @param {Object} chord - Chord object with rootNote and chordType
         * @param {number} rootMIDI - Root MIDI note (default: 64 for E4)
         * @returns {Object} { bass: [MIDI numbers], high: [MIDI numbers] }
         */
        function chordToMIDINotes(chord, rootMIDI = 64) {
            if (!chord) return { bass: [], high: [] };
            
            // Use shared function to get note objects
            const noteObjects = getChordNotesFromIntervals(chord.rootNote, chord.chordType, 4);
            if (noteObjects.length === 0) return { bass: [], high: [] };
            
            // Convert note objects to MIDI notes
            // MIDI note = (octave + 1) * 12 + noteIndex
            // C4 = (4 + 1) * 12 + 0 = 60
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const midiNotes = noteObjects.map(noteObj => {
                const noteIndex = noteNames.indexOf(noteObj.note);
                return (noteObj.octave + 1) * 12 + noteIndex;
            });
            
            // Split into bass (lowest 3) and high (highest 3)
            const sorted = [...midiNotes].sort((a, b) => a - b);
            const bass = sorted.slice(0, 3);
            const high = sorted.slice(-3);
            
            return { bass, high };
        }
        
        // ========== STATE ==========
        let chordSequence = [];
        let currentChordIndex = 0;
        let nextChordIndex = 1; // Index of chord that will play in the next cycle
        let waterSynth = null;
        let pluckySynth = null;
        let isPlaying = false;
        
        // Water synth state
        let waterBassInterval = null;
        let waterHighInterval = null;
        let waterCurrentBassDuration = null;
        let waterCurrentHighDuration = null;
        let waterPendingBassDuration = null;
        let waterPendingHighDuration = null;
        let waterPendingCellRow = null;
        let waterPendingCellCol = null;
        let waterActiveCellRow = null;
        let waterActiveCellCol = null;
        let waterProfile = 'none';
        let waterCreativeCycleCounter = 0;
        
        // Plucky synth state
        let pluckyBassInterval = null;
        let pluckyHighInterval = null;
        let pluckyCurrentBassDuration = null;
        let pluckyCurrentHighDuration = null;
        let pluckyPendingBassDuration = null;
        let pluckyPendingHighDuration = null;
        let pluckyPendingCellRow = null;
        let pluckyPendingCellCol = null;
        let pluckyActiveCellRow = null;
        let pluckyActiveCellCol = null;
        let pluckyProfile = 'none';
        let pluckyCreativeCycleCounter = 0;
        
        // Sub synth state
        let subSynth = null;
        let subBassInterval = null;
        let subOctaveInterval = null;
        let subCurrentBassDuration = null;
        let subCurrentOctaveDuration = null;
        let subPendingBassDuration = null;
        let subPendingOctaveDuration = null;
        let subPendingCellRow = null;
        let subPendingCellCol = null;
        let subActiveCellRow = null;
        let subActiveCellCol = null;
        let subProfile = 'none';
        let subCreativeCycleCounter = 0;
        
        // Shared state
        let cycleInterval = null;
        let transitionUpdateInterval = null;
        let currentBPM = 120;
        let waterVolumeModulation = 'triangle';
        let pluckyVolumeModulation = 'triangle';
        let subVolumeModulation = 'triangle';
        let masterCycleStartTime = null;
        let masterCycleNumber = 0;
        let pendingBPM = null;
        let masterVolume = null;
        let masterLimiter = null;
        // Water synth parameters
        let waterAttackTime = 0.02; // in seconds (20ms default)
        let waterHarmonic2Gain = 0.3; // 30% default
        let waterHarmonic3Gain = 0.2; // 20% default (fixed, not randomized)
        let waterHarmonic4Gain = 0.1; // 10% default (fixed, not randomized)
        let waterReverbGain = 0.77; // 77% default
        
        // Plucky synth parameters (attack only, no harmonics)
        let pluckyAttackTime = 0.066; // in seconds (66ms default)
        let pluckyReverbGain = 0.77; // 77% default
        
        // Sub synth parameters
        let subAttackTime = 0.08; // in seconds (80ms default)
        let subReverbGain = 0.12; // 12% default
        let subSaturationAmount = 0.05; // 5% default
        let subVolumeGain = 0.22; // 22% default
        
        // Water synth volume
        let waterVolumeGain = 0.5; // 50% default
        
        // Plucky synth volume
        let pluckyVolumeGain = 0.22; // 22% default
        
        // Legacy variables for compatibility (used by water synth)
        let attackTime = 0.02;
        let harmonic2Gain = 0.3;
        let harmonic3Gain = 0.2;
        let harmonic4Gain = 0.1;
        
        // Transition tracking for smooth parameter changes (water synth only)
        let targetAttackTime = 0.02;
        let targetHarmonic2Gain = 0.3;
        let attackTransitionStartTime = null;
        let attackTransitionStartValue = 0.02;
        let attackTransitionDuration = 0;
        let harmonic2TransitionStartTime = null;
        let harmonic2TransitionStartValue = 0.3;
        let harmonic2TransitionDuration = 0;
        
        // Transition tracking for plucky reverb
        let targetPluckyReverbGain = 0.77;
        let pluckyReverbTransitionStartTime = null;
        let pluckyReverbTransitionStartValue = 0.77;
        let pluckyReverbTransitionDuration = 0;
        
        // Transition tracking for water reverb
        let targetWaterReverbGain = 0.77;
        let waterReverbTransitionStartTime = null;
        let waterReverbTransitionStartValue = 0.77;
        let waterReverbTransitionDuration = 0;
        
        // Transition tracking for sub reverb
        let targetSubReverbGain = 0.12;
        let subReverbTransitionStartTime = null;
        let subReverbTransitionStartValue = 0.12;
        let subReverbTransitionDuration = 0;
        
        const DURATION_MULTIPLIERS = [null, 240, 120, 60, 40, 30, 20, 15];
        
        // ========== GRID MANAGER ==========
        let gridManager;
        
        // ========== WATER SYNTH ==========
        class WaterSynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied only to dry path, not reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 300,
                    Q: 0.7
                });
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.5); // Output volume control before reverb (default 50%)
                this.dryGain = new Tone.Gain(0.08);
                this.reverbGain = new Tone.Gain(0.77);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Volume modulation affects both dry and reverb paths BEFORE reverb
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.dryGain);
                this.outputVolume.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.oscillator3) voice.oscillator3.dispose();
                        if (voice.oscillator4) voice.oscillator4.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.envelope3) voice.envelope3.dispose();
                        if (voice.envelope4) voice.envelope4.dispose();
                        if (voice.noise) voice.noise.dispose();
                        if (voice.noiseEnv) voice.noiseEnv.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createWaterVoice(frequency, noteDuration, pitchDrop = 0.02, noiseAmount = 0.03, isHighNote = false, tempo = null) {
                const now = Tone.now();
                
                // Tempo-based random delay: 0 to (tempo / currentBPM) * 0.02 seconds
                let startDelay = 0;
                if (tempo !== null && isFinite(tempo) && tempo > 0 && typeof currentBPM !== 'undefined' && isFinite(currentBPM) && currentBPM > 0) {
                    const maxDelay = (tempo / currentBPM) * 0.02;
                    startDelay = Math.random() * maxDelay;
                } else {
                    // Fallback to old behavior if tempo not provided
                    startDelay = Math.random() * 0.02;
                }
                const startTime = now + startDelay;
                
                // Random decay reduction 0-40ms
                const decayReduction = Math.random() * 0.04;
                
                const finalPitchDrop = frequency * (pitchDrop + Math.random() * 0.02);
                const finalNoiseAmount = noiseAmount * (0.8 + Math.random() * 0.4);
                
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency + finalPitchDrop
                });
                osc.frequency.exponentialRampTo(frequency, 0.08);
                
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 2) + (finalPitchDrop * 2)
                });
                osc2.frequency.exponentialRampTo(frequency * 2, 0.08);
                
                const osc3 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 3) + (finalPitchDrop * 3)
                });
                osc3.frequency.exponentialRampTo(frequency * 3, 0.08);
                
                const osc4 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 4) + (finalPitchDrop * 4)
                });
                osc4.frequency.exponentialRampTo(frequency * 4, 0.08);
                
                // Calculate release time with decay reduction
                const baseRelease = Math.min(0.3, noteDuration * 0.3);
                const reducedRelease = Math.max(0.01, baseRelease - decayReduction);
                
                // Random sustain variation: -0 to -2dB (linear: 1.0 to 0.794)
                const sustainVariation = Math.random() * (1.0 - 0.794) + 0.794; // Random between 0.794 and 1.0
                const sustainVariation2 = Math.random() * (1.0 - 0.794) + 0.794;
                const sustainVariation3 = Math.random() * (1.0 - 0.794) + 0.794;
                const sustainVariation4 = Math.random() * (1.0 - 0.794) + 0.794;
                
                // Use water-specific attack time
                const currentAttack = typeof waterAttackTime === 'number' ? waterAttackTime : 0.02;
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.35 * sustainVariation,
                    release: reducedRelease
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.25 * sustainVariation2,
                    release: reducedRelease
                });
                
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.15 * sustainVariation3,
                    release: reducedRelease
                });
                
                const env4 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.1 * sustainVariation4,
                    release: reducedRelease
                });
                
                // Use water-specific harmonic gains
                const currentHarmonic2 = typeof waterHarmonic2Gain === 'number' ? waterHarmonic2Gain : 0.3;
                const currentHarmonic3 = typeof waterHarmonic3Gain === 'number' ? waterHarmonic3Gain : 0.2;
                const currentHarmonic4 = typeof waterHarmonic4Gain === 'number' ? waterHarmonic4Gain : 0.1;
                
                const harmonicGain2 = new Tone.Gain(currentHarmonic2);
                const harmonicGain3 = new Tone.Gain(currentHarmonic3);
                const harmonicGain4 = new Tone.Gain(currentHarmonic4);
                
                const noise = new Tone.Noise({
                    type: 'white',
                    volume: -20
                });
                
                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,
                    sustain: 0,
                    release: 0
                });
                
                const noiseGain = new Tone.Gain();
                noiseGain.gain.value = finalNoiseAmount * 0.5;
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                // Apply -12 dB reduction for high notes (linear gain ≈ 0.251)
                const highNoteVolumeReduction = isHighNote ? 0.251 : 1.0;
                // Random volume reduction 0-6dB (linear gain: 0.5012 to 1.0)
                const volumeVariation = 0.5012 + Math.random() * (1.0 - 0.5012);
                const volumeGain = new Tone.Gain(highNoteVolumeReduction * volumeVariation);
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(harmonicGain2);
                harmonicGain2.connect(volumeGain);
                osc3.connect(env3);
                env3.connect(harmonicGain3);
                harmonicGain3.connect(volumeGain);
                osc4.connect(env4);
                env4.connect(harmonicGain4);
                harmonicGain4.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);
                
                osc.start(startTime);
                osc2.start(startTime);
                osc3.start(startTime);
                osc4.start(startTime);
                noise.start(startTime);
                env.triggerAttack(startTime);
                env2.triggerAttack(startTime);
                env3.triggerAttack(startTime);
                env4.triggerAttack(startTime);
                noiseEnv.triggerAttack(startTime);
                
                noise.stop(startTime + 0.15);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                osc3.stop(stopTime);
                osc4.stop(stopTime);
                
                const releaseTime = Math.max(startTime + 0.01, stopTime - reducedRelease);
                env.triggerRelease(releaseTime);
                env2.triggerRelease(releaseTime);
                env3.triggerRelease(releaseTime);
                env4.triggerRelease(releaseTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    oscillator3: osc3,
                    oscillator4: osc4,
                    envelope: env,
                    envelope2: env2,
                    envelope3: env3,
                    envelope4: env4,
                    noise: noise,
                    noiseEnv: noiseEnv,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            env3.triggerRelease();
                            env4.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                            osc3.stop('+0.1');
                            osc4.stop('+0.1');
                            noise.stop();
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            osc3.dispose();
                            osc4.dispose();
                            env.dispose();
                            env2.dispose();
                            env3.dispose();
                            env4.dispose();
                            noise.dispose();
                            noiseEnv.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== PLUCKY SYNTH ==========
        class PluckySynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied only to dry path, not reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 300,
                    Q: 0.7
                });
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.5); // Output volume control before reverb (default 50%)
                this.dryGain = new Tone.Gain(0.08);
                this.reverbGain = new Tone.Gain(0.77);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Volume modulation affects both dry and reverb paths BEFORE reverb
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.dryGain);
                this.outputVolume.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.filter) voice.filter.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createPluckyVoice(frequency, noteDuration, isHighNote = false, tempo = null) {
                const now = Tone.now();
                
                // Tempo-based random delay: 0 to (tempo / currentBPM) * 0.02 seconds
                let startDelay = 0;
                if (tempo !== null && isFinite(tempo) && tempo > 0 && typeof currentBPM !== 'undefined' && isFinite(currentBPM) && currentBPM > 0) {
                    const maxDelay = (tempo / currentBPM) * 0.02;
                    startDelay = Math.random() * maxDelay;
                } else {
                    // Fallback to old behavior if tempo not provided
                    startDelay = Math.random() * 0.02;
                }
                const startTime = now + startDelay;
                
                // Very short attack for plucky sound
                // Use plucky-specific attack time
                const currentAttack = typeof pluckyAttackTime === 'number' ? Math.min(pluckyAttackTime, 0.005) : 0.005;
                
                // Create plucky sound with sharp attack and quick decay
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: frequency
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: frequency * 2 // Octave for richness
                });
                
                // Sharp pluck envelope: very fast attack, quick decay
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.1, noteDuration * 0.3),
                    sustain: 0.1,
                    release: Math.min(0.2, noteDuration * 0.4)
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.08, noteDuration * 0.25),
                    sustain: 0.05,
                    release: Math.min(0.15, noteDuration * 0.35)
                });
                
                // Lowpass filter for warmth
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: frequency * 6,
                    Q: 1.5
                });
                
                // Apply -12 dB reduction for high notes
                const highNoteVolumeReduction = isHighNote ? 0.251 : 1.0;
                // Random volume reduction 0-6dB (linear gain: 0.5012 to 1.0)
                const volumeVariation = 0.5012 + Math.random() * (1.0 - 0.5012);
                const volumeGain = new Tone.Gain(highNoteVolumeReduction * volumeVariation);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                
                // Routing
                osc.connect(env);
                env.connect(filter);
                osc2.connect(env2);
                env2.connect(filter);
                filter.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                // Start oscillators and trigger envelopes
                osc.start(startTime);
                osc2.start(startTime);
                env.triggerAttackRelease(noteDuration, startTime);
                env2.triggerAttackRelease(noteDuration * 0.9, startTime);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            env.dispose();
                            env2.dispose();
                            filter.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== SUB SYNTH ==========
        class SubSynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied only to dry path, not reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                // Lowpass filter for sub-bass character
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 200,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 300,
                    Q: 0.7
                });
                
                // Saturation for warmth and character
                this.saturation = new Tone.Distortion(0);
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.22); // Output volume control before reverb (default 22%)
                this.dryGain = new Tone.Gain(0.1);
                this.reverbGain = new Tone.Gain(0.12);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> saturation -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.saturation);
                this.saturation.connect(this.dryGain);
                this.saturation.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.filter) voice.filter.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createSubVoice(frequency, noteDuration, tempo = null) {
                const now = Tone.now();
                
                // Tempo-based random delay: 0 to (tempo / currentBPM) * 0.02 seconds
                let startDelay = 0;
                if (tempo !== null && isFinite(tempo) && tempo > 0 && typeof currentBPM !== 'undefined' && isFinite(currentBPM) && currentBPM > 0) {
                    const maxDelay = (tempo / currentBPM) * 0.02;
                    startDelay = Math.random() * maxDelay;
                } else {
                    // Fallback to old behavior if tempo not provided
                    startDelay = Math.random() * 0.02;
                }
                const startTime = now + startDelay;
                
                // Use sub-specific attack time
                const currentAttack = typeof subAttackTime === 'number' ? subAttackTime : 0.08;
                
                // Sub-bass: sine wave for pure low end
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency
                });
                
                // Add a subtle second harmonic (octave) for warmth
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency * 2
                });
                
                // Envelope with longer sustain for bass
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.15, noteDuration * 0.2),
                    sustain: 0.6,
                    release: Math.min(0.3, noteDuration * 0.5)
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.12, noteDuration * 0.18),
                    sustain: 0.3,
                    release: Math.min(0.25, noteDuration * 0.45)
                });
                
                // Lowpass filter for sub-bass
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: frequency * 3,
                    Q: 1.0
                });
                
                // Random volume reduction 0-6dB (linear gain: 0.5012 to 1.0)
                const volumeVariation = 0.5012 + Math.random() * (1.0 - 0.5012);
                const volumeGain = new Tone.Gain(volumeVariation);
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.1); // Less panning for bass
                
                // Routing
                osc.connect(env);
                env.connect(filter);
                osc2.connect(env2);
                env2.connect(filter);
                filter.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                // Start oscillators and trigger envelopes
                osc.start(startTime);
                osc2.start(startTime);
                env.triggerAttackRelease(noteDuration, startTime);
                env2.triggerAttackRelease(noteDuration * 0.95, startTime);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            env.dispose();
                            env2.dispose();
                            filter.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== CPU/RAM MANAGEMENT ==========
        // Cleanup function to remove voices older than 4 cycles
        function cleanupOldVoices() {
            if (!isPlaying || masterCycleNumber < 4) return;
            
            const cyclesToKeep = 4;
            const oldestCycleToKeep = masterCycleNumber - cyclesToKeep;
            
            [waterSynth, pluckySynth, subSynth].forEach(synth => {
                if (synth && synth.activeVoices) {
                    const voicesToRemove = synth.activeVoices.filter(voice => {
                        // Remove voices older than 4 cycles
                        return voice.cycleNumber !== undefined && voice.cycleNumber < oldestCycleToKeep;
                    });
                    
                    voicesToRemove.forEach(voice => {
                        try {
                            const index = synth.activeVoices.indexOf(voice);
                            if (index > -1) {
                                synth.activeVoices.splice(index, 1);
                                voice.stop();
                                voice.dispose();
                            }
                        } catch (e) {
                            console.warn('Error cleaning up old voice:', e);
                        }
                    });
                }
            });
        }
        
        // ========== AUDIO FUNCTIONS ==========
        function initAudio() {
            return new Promise((resolve, reject) => {
                if (!waterSynth || !pluckySynth || !subSynth) {
                    Tone.start().then(() => {
                        if (!masterVolume) {
                            masterVolume = new Tone.Volume(0);
                        }
                        if (!masterLimiter) {
                            // Limiter to prevent clipping at final master output
                            masterLimiter = new Tone.Limiter(-0.1); // -0.1 dB ceiling to prevent clipping
                            // Disconnect masterVolume from destination if already connected
                            try {
                                masterVolume.disconnect();
                            } catch (e) {
                                // Already disconnected or never connected
                            }
                            masterVolume.connect(masterLimiter);
                            masterLimiter.toDestination();
                        }
                        if (!waterSynth) {
                            waterSynth = new WaterSynthTone(masterVolume);
                            // Set initial reverb gain
                        if (waterSynth.reverbGain) {
                            waterSynth.reverbGain.gain.value = waterReverbGain;
                        }
                        if (waterSynth.outputVolume) {
                            waterSynth.outputVolume.gain.value = waterVolumeGain;
                        }
                    }
                    if (!pluckySynth) {
                        pluckySynth = new PluckySynthTone(masterVolume);
                        // Set initial reverb gain
                        if (pluckySynth.reverbGain) {
                            pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                        }
                        if (pluckySynth.outputVolume) {
                            pluckySynth.outputVolume.gain.value = pluckyVolumeGain;
                        }
                    }
                    if (!subSynth) {
                        subSynth = new SubSynthTone(masterVolume);
                        // Set initial reverb gain and saturation
                        if (subSynth.reverbGain) {
                            subSynth.reverbGain.gain.value = subReverbGain;
                        }
                        if (subSynth.saturation) {
                            subSynth.saturation.distortion = subSaturationAmount;
                        }
                        if (subSynth.outputVolume) {
                            subSynth.outputVolume.gain.value = subVolumeGain;
                        }
                    }
                        console.log('Audio initialized with all three synths');
                        resolve();
                    }).catch(reject);
                } else {
                    resolve();
                }
            });
        }
        
        function setupVolumeModulation(synth, cycleStartTime, cycleDuration, modulation) {
            if (!synth || !synth.volumeModulation || !isFinite(cycleDuration) || cycleDuration <= 0) return;
            
            const minVolume = -20;
            const maxVolume = 0;
            const now = Tone.now();
            
            // Get current volume value before canceling
            const currentVolume = synth.volumeModulation.volume.value;
            
            // Cancel scheduled values slightly before the cycle start to allow smooth transition
            const cancelTime = Math.max(now, cycleStartTime - 0.01);
            synth.volumeModulation.volume.cancelScheduledValues(cancelTime);
            
            // Smooth transition from current volume to cycle start volume
            const transitionTime = Math.max(now + 0.001, cycleStartTime);
            
            if (modulation === 'triangle') {
                const peakTime = cycleStartTime + cycleDuration * 0.5;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, peakTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, endTime);
            } else if (modulation === 'ascend') {
                const peakTime = cycleStartTime + cycleDuration * 0.9;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, peakTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, endTime);
            } else if (modulation === 'descend') {
                const quietTime = cycleStartTime + cycleDuration * 0.9;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, quietTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, endTime);
            } else {
                synth.volumeModulation.volume.linearRampToValueAtTime((minVolume + maxVolume) / 2, transitionTime);
            }
        }
        
        function resyncToMasterCycle() {
            if (!isPlaying || masterCycleStartTime === null) return;
            
            const masterCycleDuration240 = 240 / currentBPM;
            const exactCycleTime = masterCycleStartTime + (masterCycleNumber * masterCycleDuration240);
            
            // Setup volume modulation for each synth separately
            if (waterSynth) {
                setupVolumeModulation(waterSynth, exactCycleTime, masterCycleDuration240, waterVolumeModulation);
            }
            if (pluckySynth) {
                setupVolumeModulation(pluckySynth, exactCycleTime, masterCycleDuration240, pluckyVolumeModulation);
            }
            if (subSynth) {
                setupVolumeModulation(subSynth, exactCycleTime, masterCycleDuration240, subVolumeModulation);
            }
        }
        
        function checkAndApplyPendingChanges() {
            let changed = false;
            
            // Handle BPM changes
            if (pendingBPM !== null) {
                currentBPM = pendingBPM;
                pendingBPM = null;
                changed = true;
                // Update grid headers when BPM changes
                if (gridManager) {
                    gridManager.updateAllGridHeaders();
                }
            }
            
            // Handle water synth pending changes
            if (waterPendingBassDuration !== null || waterPendingHighDuration !== null) {
                const newBass = waterPendingBassDuration !== null ? waterPendingBassDuration : waterCurrentBassDuration;
                const newHigh = waterPendingHighDuration !== null ? waterPendingHighDuration : waterCurrentHighDuration;
                
                if (waterPendingCellRow !== null && waterPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#waterGrid .grid-cell[data-row="${waterPendingCellRow}"][data-col="${waterPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#waterGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                        waterActiveCellRow = waterPendingCellRow;
                        waterActiveCellCol = waterPendingCellCol;
                    }
                }
                
                waterCurrentBassDuration = newBass;
                waterCurrentHighDuration = newHigh;
                waterPendingBassDuration = null;
                waterPendingHighDuration = null;
                waterPendingCellRow = null;
                waterPendingCellCol = null;
                changed = true;
                
                // Update header animations
                gridManager.updateGridHeaderAnimations('waterGrid', waterCurrentBassDuration, waterCurrentHighDuration, 'water', waterActiveCellRow, waterActiveCellCol);
            }
            
            // Handle plucky synth pending changes
            if (pluckyPendingBassDuration !== null || pluckyPendingHighDuration !== null) {
                const newBass = pluckyPendingBassDuration !== null ? pluckyPendingBassDuration : pluckyCurrentBassDuration;
                const newHigh = pluckyPendingHighDuration !== null ? pluckyPendingHighDuration : pluckyCurrentHighDuration;
                
                if (pluckyPendingCellRow !== null && pluckyPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#pluckyGrid .grid-cell[data-row="${pluckyPendingCellRow}"][data-col="${pluckyPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#pluckyGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                        pluckyActiveCellRow = pluckyPendingCellRow;
                        pluckyActiveCellCol = pluckyPendingCellCol;
                    }
                }
                
                pluckyCurrentBassDuration = newBass;
                pluckyCurrentHighDuration = newHigh;
                pluckyPendingBassDuration = null;
                pluckyPendingHighDuration = null;
                pluckyPendingCellRow = null;
                pluckyPendingCellCol = null;
                changed = true;
                
                // Update header animations
                gridManager.updateGridHeaderAnimations('pluckyGrid', pluckyCurrentBassDuration, pluckyCurrentHighDuration, 'plucky', pluckyActiveCellRow, pluckyActiveCellCol);
            }
            
            // Handle sub synth pending changes
            if (subPendingBassDuration !== null || subPendingOctaveDuration !== null) {
                const newBass = subPendingBassDuration !== null ? subPendingBassDuration : subCurrentBassDuration;
                const newOctave = subPendingOctaveDuration !== null ? subPendingOctaveDuration : subCurrentOctaveDuration;
                
                if (subPendingCellRow !== null && subPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#subGrid .grid-cell[data-row="${subPendingCellRow}"][data-col="${subPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#subGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                        subActiveCellRow = subPendingCellRow;
                        subActiveCellCol = subPendingCellCol;
                    }
                }
                
                subCurrentBassDuration = newBass;
                subCurrentOctaveDuration = newOctave;
                subPendingBassDuration = null;
                subPendingOctaveDuration = null;
                subPendingCellRow = null;
                subPendingCellCol = null;
                changed = true;
                
                // Update header animations
                gridManager.updateGridHeaderAnimations('subGrid', subCurrentBassDuration, subCurrentOctaveDuration, 'sub', subActiveCellRow, subActiveCellCol);
            }
            
            // Restart if needed
            if (changed && isPlaying) {
                stopPlaying();
                startPlaying();
                return true;
            }
            
            return false;
        }
        
        function midiToFrequency(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        function midiToNoteName(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            return `${noteNames[noteIndex]}${octave}`;
        }
        
        function updateDebugDisplay(bassNotes, highNotes) {
            const bassContainer = document.getElementById('debugBassNotes');
            const highContainer = document.getElementById('debugHighNotes');
            
            if (!bassContainer || !highContainer) return;
            
            // Update bass notes
            if (bassNotes && bassNotes.length > 0) {
                bassContainer.innerHTML = '';
                bassNotes.forEach(midiNote => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'debug-note-item bass';
                    noteItem.textContent = `${midiToNoteName(midiNote)}`;
                    bassContainer.appendChild(noteItem);
                });
            } else {
                bassContainer.innerHTML = '<span style="color: #666;">-</span>';
            }
            
            // Update high notes
            if (highNotes && highNotes.length > 0) {
                highContainer.innerHTML = '';
                highNotes.forEach(midiNote => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'debug-note-item high';
                    noteItem.textContent = `${midiToNoteName(midiNote)}`;
                    highContainer.appendChild(noteItem);
                });
            } else {
                highContainer.innerHTML = '<span style="color: #666;">-</span>';
            }
        }
        
        function playBassLayer(notes, noteDuration, cycleDuration, synth, synthType, bassDurationMultiplier) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validNoteDuration = isFinite(noteDuration) && noteDuration > 0 ? noteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            notes.forEach((midiNote) => {
                const frequency = midiToFrequency(midiNote);
                if (synthType === 'water') {
                    synth.createWaterVoice(frequency, validNoteDuration, 0.02, 0.03, false, bassDurationMultiplier);
                } else if (synthType === 'plucky') {
                    synth.createPluckyVoice(frequency, validNoteDuration, false, bassDurationMultiplier);
                } else if (synthType === 'sub') {
                    synth.createSubVoice(frequency, validNoteDuration, bassDurationMultiplier);
                }
            });
        }
        
        function playHighLayer(notes, noteDuration, cycleDuration, synth, synthType, profile, currentHighDuration) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validNoteDuration = isFinite(noteDuration) && noteDuration > 0 ? noteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            // Drunk/Creative/Lazy/Threat profile: Check for special variations first (120/bpm or 60/bpm)
            if ((profile === 'drunk' || profile === 'creative' || profile === 'lazy' || profile === 'threat') && (currentHighDuration === 120 || currentHighDuration === 60) && Math.random() < 0.34) {
                // Another 34% chance to play special variations
                if (Math.random() < 0.34) {
                    const currentBassNotes = getCurrentChordNotes().bass;
                    
                    // Randomly choose: 1/3rd duration three times OR half duration twice
                    if (Math.random() < 0.5) {
                        // Play at 1/3rd duration three times
                        const thirdNoteDuration = validNoteDuration / 3;
                        
                        // Play first third (each note individually decides to skip)
                        notes.forEach((midiNote) => {
                            if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                const frequency = midiToFrequency(midiNote);
                                if (synthType === 'water') {
                                    synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true, currentHighDuration);
                                } else if (synthType === 'plucky') {
                                    synth.createPluckyVoice(frequency, thirdNoteDuration, true, currentHighDuration);
                                }
                            }
                        });
                        
                        // Play second third after delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true, currentHighDuration);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, thirdNoteDuration, true, currentHighDuration);
                                        }
                                    }
                                });
                            }
                        }, thirdNoteDuration * 1000);
                        
                        // Play third third after another delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true, currentHighDuration);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, thirdNoteDuration, true, currentHighDuration);
                                        }
                                    }
                                });
                            }
                        }, thirdNoteDuration * 2000);
                    } else {
                        // Play at half duration twice
                        const halfNoteDuration = validNoteDuration / 2;
                        
                        // Play first half (each note individually decides to skip)
                        notes.forEach((midiNote) => {
                            if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                const frequency = midiToFrequency(midiNote);
                                if (synthType === 'water') {
                                    synth.createWaterVoice(frequency, halfNoteDuration, 0.02, 0.03, true, currentHighDuration);
                                } else if (synthType === 'plucky') {
                                    synth.createPluckyVoice(frequency, halfNoteDuration, true, currentHighDuration);
                                }
                            }
                        });
                        
                        // Play second half after a delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, halfNoteDuration, 0.02, 0.03, true, currentHighDuration);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, halfNoteDuration, true, currentHighDuration);
                                        }
                                    }
                                });
                            }
                        }, halfNoteDuration * 1000);
                    }
                    
                    return;
                }
            }
            
            // Normal playback: each note individually decides whether to skip (34% chance)
            notes.forEach((midiNote) => {
                // Each note individually decides: 34% chance to skip in drunk/creative/lazy/threat profile
                if ((profile === 'drunk' || profile === 'creative' || profile === 'lazy' || profile === 'threat') && Math.random() < 0.34) {
                    // Skip this note
                    return;
                }
                
                // Play this note
                const frequency = midiToFrequency(midiNote);
                if (synthType === 'water') {
                    synth.createWaterVoice(frequency, validNoteDuration, 0.02, 0.03, true, currentHighDuration);
                } else if (synthType === 'plucky') {
                    synth.createPluckyVoice(frequency, validNoteDuration, true, currentHighDuration);
                }
            });
        }
        
        function updateParameterTransitions() {
            const now = Tone.now();
            
            // Update water attack transition
            if (attackTransitionStartTime !== null && attackTransitionDuration > 0) {
                const elapsed = now - attackTransitionStartTime;
                if (elapsed < attackTransitionDuration) {
                    const progress = elapsed / attackTransitionDuration;
                    // Linear interpolation
                    waterAttackTime = attackTransitionStartValue + (targetAttackTime - attackTransitionStartValue) * progress;
                    attackTime = waterAttackTime; // Legacy compatibility
                    
                    // Update slider and display in real-time
                    const attackSlider = document.getElementById('waterAttackSlider');
                    const attackDisplay = document.getElementById('waterAttackDisplay');
                    if (attackSlider && attackDisplay) {
                        const currentAttackMs = Math.round(waterAttackTime * 1000);
                        attackSlider.value = currentAttackMs;
                        attackDisplay.textContent = currentAttackMs + 'ms';
                    }
                } else {
                    // Transition complete
                    waterAttackTime = targetAttackTime;
                    attackTime = waterAttackTime; // Legacy compatibility
                    attackTransitionStartTime = null;
                    attackTransitionDuration = 0;
                    
                    // Final update to slider
                    const attackSlider = document.getElementById('waterAttackSlider');
                    const attackDisplay = document.getElementById('waterAttackDisplay');
                    if (attackSlider && attackDisplay) {
                        const finalAttackMs = Math.round(targetAttackTime * 1000);
                        attackSlider.value = finalAttackMs;
                        attackDisplay.textContent = finalAttackMs + 'ms';
                    }
                }
            }
            
            // Update water harmonic2 transition
            if (harmonic2TransitionStartTime !== null && harmonic2TransitionDuration > 0) {
                const elapsed = now - harmonic2TransitionStartTime;
                if (elapsed < harmonic2TransitionDuration) {
                    const progress = elapsed / harmonic2TransitionDuration;
                    // Linear interpolation
                    waterHarmonic2Gain = harmonic2TransitionStartValue + (targetHarmonic2Gain - harmonic2TransitionStartValue) * progress;
                    harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                    
                    // Update slider and display in real-time
                    const harmonic2Slider = document.getElementById('waterHarmonic2Slider');
                    const harmonic2Display = document.getElementById('waterHarmonic2Display');
                    if (harmonic2Slider && harmonic2Display) {
                        const currentHarmonic2Percent = Math.round(waterHarmonic2Gain * 100);
                        harmonic2Slider.value = currentHarmonic2Percent;
                        harmonic2Display.textContent = currentHarmonic2Percent + '%';
                    }
                } else {
                    // Transition complete
                    waterHarmonic2Gain = targetHarmonic2Gain;
                    harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                    harmonic2TransitionStartTime = null;
                    harmonic2TransitionDuration = 0;
                    
                    // Final update to slider
                    const harmonic2Slider = document.getElementById('waterHarmonic2Slider');
                    const harmonic2Display = document.getElementById('waterHarmonic2Display');
                    if (harmonic2Slider && harmonic2Display) {
                        const finalHarmonic2Percent = Math.round(targetHarmonic2Gain * 100);
                        harmonic2Slider.value = finalHarmonic2Percent;
                        harmonic2Display.textContent = finalHarmonic2Percent + '%';
                    }
                }
            }
            
            // Update plucky reverb transition
            if (pluckyReverbTransitionStartTime !== null && pluckyReverbTransitionDuration > 0) {
                const elapsed = now - pluckyReverbTransitionStartTime;
                if (elapsed < pluckyReverbTransitionDuration) {
                    const progress = elapsed / pluckyReverbTransitionDuration;
                    // Linear interpolation
                    pluckyReverbGain = pluckyReverbTransitionStartValue + (targetPluckyReverbGain - pluckyReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (pluckySynth && pluckySynth.reverbGain) {
                        pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const pluckyReverbSlider = document.getElementById('pluckyReverbSlider');
                    const pluckyReverbDisplay = document.getElementById('pluckyReverbDisplay');
                    if (pluckyReverbSlider && pluckyReverbDisplay) {
                        const currentReverbPercent = Math.round(pluckyReverbGain * 100);
                        pluckyReverbSlider.value = currentReverbPercent;
                        pluckyReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    pluckyReverbGain = targetPluckyReverbGain;
                    pluckyReverbTransitionStartTime = null;
                    pluckyReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (pluckySynth && pluckySynth.reverbGain) {
                        pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                    }
                    
                    // Final update to slider
                    const pluckyReverbSlider = document.getElementById('pluckyReverbSlider');
                    const pluckyReverbDisplay = document.getElementById('pluckyReverbDisplay');
                    if (pluckyReverbSlider && pluckyReverbDisplay) {
                        const finalReverbPercent = Math.round(targetPluckyReverbGain * 100);
                        pluckyReverbSlider.value = finalReverbPercent;
                        pluckyReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
            
            // Update water reverb transition
            if (waterReverbTransitionStartTime !== null && waterReverbTransitionDuration > 0) {
                const elapsed = now - waterReverbTransitionStartTime;
                if (elapsed < waterReverbTransitionDuration) {
                    const progress = elapsed / waterReverbTransitionDuration;
                    // Linear interpolation
                    waterReverbGain = waterReverbTransitionStartValue + (targetWaterReverbGain - waterReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (waterSynth && waterSynth.reverbGain) {
                        waterSynth.reverbGain.gain.value = waterReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const waterReverbSlider = document.getElementById('waterReverbSlider');
                    const waterReverbDisplay = document.getElementById('waterReverbDisplay');
                    if (waterReverbSlider && waterReverbDisplay) {
                        const currentReverbPercent = Math.round(waterReverbGain * 100);
                        waterReverbSlider.value = currentReverbPercent;
                        waterReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    waterReverbGain = targetWaterReverbGain;
                    waterReverbTransitionStartTime = null;
                    waterReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (waterSynth && waterSynth.reverbGain) {
                        waterSynth.reverbGain.gain.value = waterReverbGain;
                    }
                    
                    // Final update to slider
                    const waterReverbSlider = document.getElementById('waterReverbSlider');
                    const waterReverbDisplay = document.getElementById('waterReverbDisplay');
                    if (waterReverbSlider && waterReverbDisplay) {
                        const finalReverbPercent = Math.round(targetWaterReverbGain * 100);
                        waterReverbSlider.value = finalReverbPercent;
                        waterReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
            
            // Update sub reverb transition
            if (subReverbTransitionStartTime !== null && subReverbTransitionDuration > 0) {
                const elapsed = now - subReverbTransitionStartTime;
                if (elapsed < subReverbTransitionDuration) {
                    const progress = elapsed / subReverbTransitionDuration;
                    // Linear interpolation
                    subReverbGain = subReverbTransitionStartValue + (targetSubReverbGain - subReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (subSynth && subSynth.reverbGain) {
                        subSynth.reverbGain.gain.value = subReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const subReverbSlider = document.getElementById('subReverbSlider');
                    const subReverbDisplay = document.getElementById('subReverbDisplay');
                    if (subReverbSlider && subReverbDisplay) {
                        const currentReverbPercent = Math.round(subReverbGain * 100);
                        subReverbSlider.value = currentReverbPercent;
                        subReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    subReverbGain = targetSubReverbGain;
                    subReverbTransitionStartTime = null;
                    subReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (subSynth && subSynth.reverbGain) {
                        subSynth.reverbGain.gain.value = subReverbGain;
                    }
                    
                    // Final update to slider
                    const subReverbSlider = document.getElementById('subReverbSlider');
                    const subReverbDisplay = document.getElementById('subReverbDisplay');
                    if (subReverbSlider && subReverbDisplay) {
                        const finalReverbPercent = Math.round(targetSubReverbGain * 100);
                        subReverbSlider.value = finalReverbPercent;
                        subReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
        }
        
        function randomizeSynthParameters(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize water attack: 1-100ms (convert to seconds)
            const randomAttack = Math.floor(Math.random() * 100) + 1;
            targetAttackTime = randomAttack / 1000;
            
            // Randomize water 2nd harmonic only: 0-100% (convert to gain 0-1)
            const randomHarmonic2 = Math.floor(Math.random() * 101);
            targetHarmonic2Gain = randomHarmonic2 / 100;
            
            // Start smooth transitions
            // Note: We don't update sliders here - let updateParameterTransitions() handle smooth updates
            attackTransitionStartTime = now;
            attackTransitionStartValue = waterAttackTime;
            attackTransitionDuration = transitionDuration;
            
            harmonic2TransitionStartTime = now;
            harmonic2TransitionStartValue = waterHarmonic2Gain;
            harmonic2TransitionDuration = transitionDuration;
        }
        
        function randomizePluckyReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize plucky reverb: 3% to 40% (convert to gain 0.03 to 0.40)
            const randomReverb = Math.floor(Math.random() * 38) + 3; // 3 to 40
            targetPluckyReverbGain = randomReverb / 100;
            
            // Start smooth transition
            pluckyReverbTransitionStartTime = now;
            pluckyReverbTransitionStartValue = pluckyReverbGain;
            pluckyReverbTransitionDuration = transitionDuration;
        }
        
        function randomizeWaterReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize water reverb: 8% to 80% (convert to gain 0.08 to 0.80)
            const randomReverb = Math.floor(Math.random() * 73) + 8; // 8 to 80
            targetWaterReverbGain = randomReverb / 100;
            
            // Start smooth transition
            waterReverbTransitionStartTime = now;
            waterReverbTransitionStartValue = waterReverbGain;
            waterReverbTransitionDuration = transitionDuration;
        }
        
        function randomizeSubReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize sub reverb: 10% to 70% (convert to gain 0.1 to 0.7)
            const randomReverb = Math.floor(Math.random() * 61) + 10; // 10 to 70
            targetSubReverbGain = randomReverb / 100;
            
            // Start smooth transition
            subReverbTransitionStartTime = now;
            subReverbTransitionStartValue = subReverbGain;
            subReverbTransitionDuration = transitionDuration;
        }
        
        function setBPM(newBPM) {
            if (!isFinite(newBPM) || newBPM <= 0) {
                console.error('Invalid BPM value:', newBPM);
                return;
            }
            
            const slider = document.getElementById('bpmSlider');
            if (slider) {
                slider.value = newBPM;
            }
            
            document.getElementById('bpmDisplay').textContent = `${newBPM} BPM`;
            
            // Also update the selection screen BPM slider if it exists
            const presetBpmSlider = document.getElementById('presetBpmSlider');
            const presetBpmDisplay = document.getElementById('presetBpmDisplay');
            if (presetBpmSlider) {
                presetBpmSlider.value = newBPM;
            }
            if (presetBpmDisplay) {
                presetBpmDisplay.textContent = `${newBPM} BPM`;
            }
            
            if (isPlaying) {
                pendingBPM = newBPM;
            } else {
                currentBPM = newBPM;
                // Update grid headers when BPM changes
                if (gridManager) {
                    gridManager.updateAllGridHeaders();
                }
            }
        }
        
        function updateBPM() {
            const slider = document.getElementById('bpmSlider');
            const newBPM = parseInt(slider.value);
            setBPM(newBPM);
        }
        
        function getCurrentChordNotes() {
            if (chordSequence.length === 0) return { bass: [], high: [] };
            const currentChord = chordSequence[currentChordIndex];
            return chordToMIDINotes(currentChord);
        }
        
        function handleProfileBehaviors(synthType, profile, currentBassDuration, currentHighDuration) {
            const gridId = synthType === 'water' ? 'waterGrid' : 'pluckyGrid';
            
            // Creative profile: randomize synth parameters every cycle, transition over 3 cycles
            if (profile === 'creative') {
                if (synthType === 'water') {
                    randomizeSynthParameters(3);
                    randomizeWaterReverb(3);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(3);
                }
            }
            
            // Lazy profile: randomize synth parameters every cycle, transition over 3 cycles (same as creative, but NO cell selection)
            if (profile === 'lazy') {
                if (synthType === 'water') {
                    randomizeSynthParameters(3);
                    randomizeWaterReverb(3);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(3);
                }
            }
            
            // Drunk profile: randomize synth parameters every half cycle (every other cycle), transition over 1 cycle
            if (profile === 'drunk' && masterCycleNumber % 2 === 0) {
                if (synthType === 'water') {
                    randomizeSynthParameters(1);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(1);
                }
            }
            
            // Creative profile: every 4 cycles, pick any random cell
            if (profile === 'creative') {
                if (synthType === 'water') {
                    waterCreativeCycleCounter++;
                    if (waterCreativeCycleCounter >= 4) {
                        waterCreativeCycleCounter = 0;
                        
                        // Find current active cell
                        let currentActiveRow = null;
                        let currentActiveCol = null;
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                                currentActiveRow = i;
                            }
                            if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                                currentActiveCol = i;
                            }
                        }
                        
                        if (currentActiveRow !== null && currentActiveCol !== null) {
                            // Pick any random cell
                            const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            
                            const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                            const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                            
                            if (bassDurationMultiplier && highDurationMultiplier) {
                                // Clear existing pending states for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                    c.classList.remove('pending');
                                });
                                
                                // Clear active cells for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                    c.classList.remove('active');
                                });
                                
                                // Set new pending cell
                                const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                                if (cell) {
                                    cell.classList.add('pending');
                                    waterPendingBassDuration = bassDurationMultiplier;
                                    waterPendingHighDuration = highDurationMultiplier;
                                    waterPendingCellRow = randomRow;
                                    waterPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                } else if (synthType === 'plucky') {
                    pluckyCreativeCycleCounter++;
                    if (pluckyCreativeCycleCounter >= 4) {
                        pluckyCreativeCycleCounter = 0;
                        
                        // Find current active cell
                        let currentActiveRow = null;
                        let currentActiveCol = null;
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                                currentActiveRow = i;
                            }
                            if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                                currentActiveCol = i;
                            }
                        }
                        
                        if (currentActiveRow !== null && currentActiveCol !== null) {
                            // Pick any random cell
                            const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            
                            const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                            const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                            
                            if (bassDurationMultiplier && highDurationMultiplier) {
                                // Clear existing pending states for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                    c.classList.remove('pending');
                                });
                                
                                // Clear active cells for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                    c.classList.remove('active');
                                });
                                
                                // Set new pending cell
                                const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                                if (cell) {
                                    cell.classList.add('pending');
                                    pluckyPendingBassDuration = bassDurationMultiplier;
                                    pluckyPendingHighDuration = highDurationMultiplier;
                                    pluckyPendingCellRow = randomRow;
                                    pluckyPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                }
            }
            
            // Drunk profile: 34% chance to randomly select a cell
            if (profile === 'drunk' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveRow = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                        currentActiveCol = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow) {
                                availableRows.push(i);
                            }
                        }
                        randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                    } else {
                        // Same row, different column
                        randomRow = currentActiveRow;
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                    const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                    
                    if (bassDurationMultiplier && highDurationMultiplier) {
                        // Clear existing pending states for this grid
                        document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                            c.classList.remove('pending');
                        });
                        
                        // Set new pending cell
                        const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                        if (cell) {
                            cell.classList.add('pending');
                            if (synthType === 'water') {
                                waterPendingBassDuration = bassDurationMultiplier;
                                waterPendingHighDuration = highDurationMultiplier;
                                waterPendingCellRow = randomRow;
                                waterPendingCellCol = randomCol;
                            } else {
                                pluckyPendingBassDuration = bassDurationMultiplier;
                                pluckyPendingHighDuration = highDurationMultiplier;
                                pluckyPendingCellRow = randomRow;
                                pluckyPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
            
            // Threat profile: 34% chance to randomly select a cell (never picks rows 1 or 2)
            if (profile === 'threat' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveRow = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                        currentActiveCol = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row (but not row 1 or 2)
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow && i !== 1 && i !== 2) {
                                availableRows.push(i);
                            }
                        }
                        if (availableRows.length > 0) {
                            randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                        } else {
                            randomRow = null;
                        }
                    } else {
                        // Same row, different column (but if row is 1 or 2, pick different row)
                        randomRow = currentActiveRow;
                        if (randomRow === 1 || randomRow === 2) {
                            const availableRows = [];
                            for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                                if (i !== 1 && i !== 2) {
                                    availableRows.push(i);
                                }
                            }
                            if (availableRows.length > 0) {
                                randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                            } else {
                                randomRow = null;
                            }
                        }
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    if (randomRow !== null && randomCol !== null) {
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        
                        if (bassDurationMultiplier && highDurationMultiplier) {
                            // Clear existing pending states for this grid
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                if (synthType === 'water') {
                                    waterPendingBassDuration = bassDurationMultiplier;
                                    waterPendingHighDuration = highDurationMultiplier;
                                    waterPendingCellRow = randomRow;
                                    waterPendingCellCol = randomCol;
                                } else {
                                    pluckyPendingBassDuration = bassDurationMultiplier;
                                    pluckyPendingHighDuration = highDurationMultiplier;
                                    pluckyPendingCellRow = randomRow;
                                    pluckyPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function handleSubProfileBehaviors(profile, currentBassDuration, currentOctaveDuration) {
            const gridId = 'subGrid';
            
            // Creative profile: every 4 cycles, pick any random cell
            if (profile === 'creative') {
                subCreativeCycleCounter++;
                if (subCreativeCycleCounter >= 4) {
                    subCreativeCycleCounter = 0;
                    
                    // Find current active cell
                    let currentActiveRow = null;
                    let currentActiveCol = null;
                    for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                        if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                            currentActiveCol = i;
                        }
                        if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                            currentActiveRow = i;
                        }
                    }
                    
                    if (currentActiveRow !== null && currentActiveCol !== null) {
                        // Pick any random cell
                        const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                        const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                        
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        
                        if (bassDurationMultiplier && octaveDurationMultiplier) {
                            // Clear existing pending states
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Clear active cells
                            document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                c.classList.remove('active');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                subPendingBassDuration = bassDurationMultiplier;
                                subPendingOctaveDuration = octaveDurationMultiplier;
                                subPendingCellRow = randomRow;
                                subPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
            
            // Drunk profile: 34% chance to randomly select a cell
            if (profile === 'drunk' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveCol = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                        currentActiveRow = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow) {
                                availableRows.push(i);
                            }
                        }
                        randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                    } else {
                        // Same row, different column
                        randomRow = currentActiveRow;
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                    const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                    
                    if (bassDurationMultiplier && octaveDurationMultiplier) {
                        // Clear existing pending states
                        document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                            c.classList.remove('pending');
                        });
                        
                        // Set new pending cell
                        const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                        if (cell) {
                            cell.classList.add('pending');
                            subPendingBassDuration = bassDurationMultiplier;
                            subPendingOctaveDuration = octaveDurationMultiplier;
                            subPendingCellRow = randomRow;
                            subPendingCellCol = randomCol;
                        }
                    }
                }
            }
            
            // Threat profile: 34% chance to randomly select a cell (never picks rows 1 or 2)
            if (profile === 'threat' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveCol = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                        currentActiveRow = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row (but not row 1 or 2)
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow && i !== 1 && i !== 2) {
                                availableRows.push(i);
                            }
                        }
                        if (availableRows.length > 0) {
                            randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                        } else {
                            randomRow = null;
                        }
                    } else {
                        // Same row, different column (but if row is 1 or 2, pick different row)
                        randomRow = currentActiveRow;
                        if (randomRow === 1 || randomRow === 2) {
                            const availableRows = [];
                            for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                                if (i !== 1 && i !== 2) {
                                    availableRows.push(i);
                                }
                            }
                            if (availableRows.length > 0) {
                                randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                            } else {
                                randomRow = null;
                            }
                        }
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    if (randomRow !== null && randomCol !== null) {
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        
                        if (bassDurationMultiplier && octaveDurationMultiplier) {
                            // Clear existing pending states
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                subPendingBassDuration = bassDurationMultiplier;
                                subPendingOctaveDuration = octaveDurationMultiplier;
                                subPendingCellRow = randomRow;
                                subPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
        }
        
        function startPlaying() {
            if (!isFinite(currentBPM) || currentBPM <= 0) {
                console.error('Invalid BPM:', currentBPM);
                return;
            }
            
            if (!waterSynth || !pluckySynth || !subSynth) {
                console.error('Synths not initialized');
                return;
            }
            
            if (isPlaying) {
                stopPlaying();
            }
            
            isPlaying = true;
            updateSelectionScreenInteractions();
            updateChordPreviewVisualState();
            
            // Set defaults if not set
            if (waterCurrentBassDuration === null) waterCurrentBassDuration = 240;
            if (waterCurrentHighDuration === null) waterCurrentHighDuration = 30;
            if (pluckyCurrentBassDuration === null) pluckyCurrentBassDuration = 240;
            if (pluckyCurrentHighDuration === null) pluckyCurrentHighDuration = 30;
            if (subCurrentBassDuration === null) subCurrentBassDuration = 240;
            if (subCurrentOctaveDuration === null) subCurrentOctaveDuration = 30;
            
            if (!masterVolume) {
                console.error('Master volume not initialized');
                return;
            }
            
            const masterCycleDuration240 = 240 / currentBPM;
            const now = Tone.now();
            
            masterCycleStartTime = now;
            masterCycleNumber = 0;
            waterCreativeCycleCounter = 0;
            pluckyCreativeCycleCounter = 0;
            subCreativeCycleCounter = 0;
            
            // Setup volume modulation for each synth separately
            if (waterSynth) {
                setupVolumeModulation(waterSynth, now, masterCycleDuration240, waterVolumeModulation);
            }
            if (pluckySynth) {
                setupVolumeModulation(pluckySynth, now, masterCycleDuration240, pluckyVolumeModulation);
            }
            if (subSynth) {
                setupVolumeModulation(subSynth, now, masterCycleDuration240, subVolumeModulation);
            }
            
            // Start water synth
            startSynthLayers('water', waterSynth, waterCurrentBassDuration, waterCurrentHighDuration, waterProfile);
            
            // Start plucky synth
            startSynthLayers('plucky', pluckySynth, pluckyCurrentBassDuration, pluckyCurrentHighDuration, pluckyProfile);
            
            // Start sub synth (sub-only - two durations)
            startSubSynthLayer(subSynth, subCurrentBassDuration, subCurrentOctaveDuration, subProfile);
            
            // Update header animations for all grids
            gridManager.updateGridHeaderAnimations('waterGrid', waterCurrentBassDuration, waterCurrentHighDuration, 'water', waterActiveCellRow, waterActiveCellCol);
            gridManager.updateGridHeaderAnimations('pluckyGrid', pluckyCurrentBassDuration, pluckyCurrentHighDuration, 'plucky', pluckyActiveCellRow, pluckyActiveCellCol);
            gridManager.updateGridHeaderAnimations('subGrid', subCurrentBassDuration, subCurrentOctaveDuration, 'sub', subActiveCellRow, subActiveCellCol);
            
            // Update debug display
            const chordNotes = getCurrentChordNotes();
            updateDebugDisplay(chordNotes.bass, chordNotes.high);
            
            // Clear any existing intervals before creating new ones
            if (cycleInterval) {
                clearInterval(cycleInterval);
                cycleInterval = null;
            }
            if (transitionUpdateInterval) {
                clearInterval(transitionUpdateInterval);
                transitionUpdateInterval = null;
            }
            
            // Master cycle interval for chord changes and profile behaviors
            cycleInterval = setInterval(() => {
                if (isPlaying) {
                    masterCycleNumber++;
                    resyncToMasterCycle();
                    checkAndApplyPendingChanges();
                    
                    // Handle profile behaviors for water synth
                    handleProfileBehaviors('water', waterProfile, waterCurrentBassDuration, waterCurrentHighDuration);
                    
                    // Handle profile behaviors for plucky synth
                    handleProfileBehaviors('plucky', pluckyProfile, pluckyCurrentBassDuration, pluckyCurrentHighDuration);
                    
                    // Handle profile behaviors for sub synth
                    handleSubProfileBehaviors(subProfile, subCurrentBassDuration, subCurrentOctaveDuration);
                    
                    // Advance to the "next" chord that was queued
                    if (chordSequence.length > 0) {
                        currentChordIndex = nextChordIndex;
                        nextChordIndex = (nextChordIndex + 1) % chordSequence.length;
                        updateChordDisplay();
                        updateChordSequenceDisplay();
                        
                        // Play new chord on both synths
                        const chordNotes = getCurrentChordNotes();
                        const noteDuration = 0.8;
                        
                        // Water synth
                        if (waterCurrentBassDuration && waterCurrentHighDuration) {
                            const waterBassCycle = waterCurrentBassDuration / currentBPM;
                            const waterHighCycle = waterCurrentHighDuration / currentBPM;
                            playBassLayer(chordNotes.bass, waterBassCycle * noteDuration, waterBassCycle, waterSynth, 'water', waterCurrentBassDuration);
                            playHighLayer(chordNotes.high, waterHighCycle * noteDuration, waterHighCycle, waterSynth, 'water', waterProfile, waterCurrentHighDuration);
                        }
                        
                        // Plucky synth
                        if (pluckyCurrentBassDuration && pluckyCurrentHighDuration) {
                            const pluckyBassCycle = pluckyCurrentBassDuration / currentBPM;
                            const pluckyHighCycle = pluckyCurrentHighDuration / currentBPM;
                            playBassLayer(chordNotes.bass, pluckyBassCycle * noteDuration, pluckyBassCycle, pluckySynth, 'plucky', pluckyCurrentBassDuration);
                            playHighLayer(chordNotes.high, pluckyHighCycle * noteDuration, pluckyHighCycle, pluckySynth, 'plucky', pluckyProfile, pluckyCurrentHighDuration);
                        }
                        
                        // Sub synth (sub-only - lowest note + octave lower)
                        if (subCurrentBassDuration && subCurrentOctaveDuration) {
                            const subBassCycle = subCurrentBassDuration / currentBPM;
                            const subOctaveCycle = subCurrentOctaveDuration / currentBPM;
                            playSubLayer(chordNotes.bass, subBassCycle * noteDuration, subOctaveCycle * noteDuration, subBassCycle, subOctaveCycle, subSynth, subCurrentBassDuration, subCurrentOctaveDuration);
                        }
                    }
                    
                    // Cleanup old voices (cycle-based: remove voices older than 4 cycles)
                    cleanupOldVoices();
                    
                    // Also cleanup voices that have finished playing (backup cleanup)
                    [waterSynth, pluckySynth, subSynth].forEach(synth => {
                        if (synth && synth.activeVoices) {
                            const now = Tone.now();
                            const finishedVoices = synth.activeVoices.filter(voice => {
                                return voice.stopTime && (now > voice.stopTime + 0.5);
                            });
                            finishedVoices.forEach(voice => {
                                try {
                                    const index = synth.activeVoices.indexOf(voice);
                                    if (index > -1) {
                                        synth.activeVoices.splice(index, 1);
                                        voice.dispose();
                                    }
                                } catch (e) {}
                            });
                        }
                    });
                }
            }, masterCycleDuration240 * 1000);
            
            // Update parameter transitions frequently
            transitionUpdateInterval = setInterval(() => {
                if (isPlaying) {
                    updateParameterTransitions();
                }
            }, 50);
        }
        
        function startSynthLayers(synthType, synth, bassDurationMultiplier, highDurationMultiplier, profile) {
            const bassCycleDuration = bassDurationMultiplier / currentBPM;
            const highCycleDuration = highDurationMultiplier / currentBPM;
            const noteDuration = 0.8;
            
            if (!isFinite(bassCycleDuration) || bassCycleDuration <= 0 ||
                !isFinite(highCycleDuration) || highCycleDuration <= 0) {
                console.error('Invalid cycle durations calculated for', synthType);
                return;
            }
            
            const chordNotes = getCurrentChordNotes();
            playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType, bassDurationMultiplier);
            playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
            
            if (synthType === 'water') {
                // Clear any existing intervals before creating new ones
                if (waterBassInterval) {
                    clearInterval(waterBassInterval);
                    waterBassInterval = null;
                }
                if (waterHighInterval) {
                    clearInterval(waterHighInterval);
                    waterHighInterval = null;
                }
                waterBassInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType, bassDurationMultiplier);
                    }
                }, bassCycleDuration * 1000);
                
                waterHighInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
                    }
                }, highCycleDuration * 1000);
            } else if (synthType === 'plucky') {
                // Clear any existing intervals before creating new ones
                if (pluckyBassInterval) {
                    clearInterval(pluckyBassInterval);
                    pluckyBassInterval = null;
                }
                if (pluckyHighInterval) {
                    clearInterval(pluckyHighInterval);
                    pluckyHighInterval = null;
                }
                pluckyBassInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType, bassDurationMultiplier);
                    }
                }, bassCycleDuration * 1000);
                
                pluckyHighInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
                    }
                }, highCycleDuration * 1000);
            }
        }
        
        function startSubSynthLayer(synth, bassDurationMultiplier, octaveDurationMultiplier, profile) {
            const bassCycleDuration = bassDurationMultiplier / currentBPM;
            const octaveCycleDuration = octaveDurationMultiplier / currentBPM;
            const noteDuration = 0.8;
            
            if (!isFinite(bassCycleDuration) || bassCycleDuration <= 0 ||
                !isFinite(octaveCycleDuration) || octaveCycleDuration <= 0) {
                console.error('Invalid cycle duration calculated for sub synth');
                return;
            }
            
            const chordNotes = getCurrentChordNotes();
            playSubLayer(chordNotes.bass, bassCycleDuration * noteDuration, octaveCycleDuration * noteDuration, bassCycleDuration, octaveCycleDuration, synth, bassDurationMultiplier, octaveDurationMultiplier);
            
            // Clear any existing intervals before creating new ones
            if (subBassInterval) {
                clearInterval(subBassInterval);
                subBassInterval = null;
            }
            if (subOctaveInterval) {
                clearInterval(subOctaveInterval);
                subOctaveInterval = null;
            }
            
            // Interval for lowest note (column tempo)
            subBassInterval = setInterval(() => {
                if (isPlaying) {
                    const chordNotes = getCurrentChordNotes();
                    const lowestNote = Math.min(...chordNotes.bass);
                    const frequency = midiToFrequency(lowestNote);
                    const validNoteDuration = bassCycleDuration * noteDuration;
                    synth.createSubVoice(frequency, validNoteDuration, bassDurationMultiplier);
                }
            }, bassCycleDuration * 1000);
            
            // Interval for octave lower note (row tempo)
            subOctaveInterval = setInterval(() => {
                if (isPlaying) {
                    const chordNotes = getCurrentChordNotes();
                    const lowestNote = Math.min(...chordNotes.bass);
                    const octaveLowerNote = lowestNote - 12;
                    const octaveLowerFrequency = midiToFrequency(octaveLowerNote);
                    const validNoteDuration = octaveCycleDuration * noteDuration;
                    // Add 5-15ms random offset to prevent phase cancellation when both notes play together
                    const phaseOffset = 0.005 + (Math.random() * 0.01); // 5-15ms
                    setTimeout(() => {
                        if (isPlaying) {
                            synth.createSubVoice(octaveLowerFrequency, validNoteDuration, octaveDurationMultiplier);
                        }
                    }, phaseOffset * 1000);
                }
            }, octaveCycleDuration * 1000);
        }
        
        function playSubLayer(notes, bassNoteDuration, octaveNoteDuration, bassCycleDuration, octaveCycleDuration, synth, bassDurationMultiplier, octaveDurationMultiplier) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validBassNoteDuration = isFinite(bassNoteDuration) && bassNoteDuration > 0 ? bassNoteDuration : 0.8;
            const validOctaveNoteDuration = isFinite(octaveNoteDuration) && octaveNoteDuration > 0 ? octaveNoteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            // Play the lowest note (column tempo)
            const lowestNote = Math.min(...notes);
            const frequency = midiToFrequency(lowestNote);
            synth.createSubVoice(frequency, validBassNoteDuration, bassDurationMultiplier);
            
            // Play an octave lower (row tempo) with a small delay to reduce phase interference
            const octaveLowerNote = lowestNote - 12;
            const octaveLowerFrequency = midiToFrequency(octaveLowerNote);
            // Add 5-15ms random offset to prevent phase cancellation when both notes play together
            const phaseOffset = 0.005 + (Math.random() * 0.01); // 5-15ms
            setTimeout(() => {
                if (isPlaying) {
                    synth.createSubVoice(octaveLowerFrequency, validOctaveNoteDuration, octaveDurationMultiplier);
                }
            }, phaseOffset * 1000);
        }
        
        // Helper function to sync playHiddenBtn state with toggleBtn state
        function syncPlayHiddenBtn() {
            const toggleBtn = document.getElementById('toggleBtn');
            const playHiddenBtn = document.getElementById('playHiddenBtn');
            if (toggleBtn && playHiddenBtn) {
                // Sync the state: if toggleBtn shows "Stop" or has "active" class, playHiddenBtn should show stop
                if (toggleBtn.textContent.includes('Stop') || toggleBtn.classList.contains('active')) {
                    playHiddenBtn.textContent = '⏹';
                } else {
                    playHiddenBtn.textContent = '▶︎';
                }
            }
        }
        
        function stopPlaying() {
            isPlaying = false;
            updateSelectionScreenInteractions();
            updateChordPreviewVisualState();
            
            // Stop water synth intervals
            if (waterBassInterval) {
                clearInterval(waterBassInterval);
                waterBassInterval = null;
            }
            if (waterHighInterval) {
                clearInterval(waterHighInterval);
                waterHighInterval = null;
            }
            
            // Stop plucky synth intervals
            if (pluckyBassInterval) {
                clearInterval(pluckyBassInterval);
                pluckyBassInterval = null;
            }
            if (pluckyHighInterval) {
                clearInterval(pluckyHighInterval);
                pluckyHighInterval = null;
            }
            
            // Stop sub synth intervals
            if (subBassInterval) {
                clearInterval(subBassInterval);
                subBassInterval = null;
            }
            if (subOctaveInterval) {
                clearInterval(subOctaveInterval);
                subOctaveInterval = null;
            }
            
            // Stop header animations
            gridManager.updateGridHeaderAnimations('waterGrid', null, null, 'water');
            gridManager.updateGridHeaderAnimations('pluckyGrid', null, null, 'plucky');
            gridManager.updateGridHeaderAnimations('subGrid', null, null, 'sub');
            
            if (cycleInterval) {
                clearInterval(cycleInterval);
                cycleInterval = null;
            }
            if (transitionUpdateInterval) {
                clearInterval(transitionUpdateInterval);
                transitionUpdateInterval = null;
            }
            
            if (waterSynth && waterSynth.cleanupVoices) {
                waterSynth.cleanupVoices();
            }
            if (pluckySynth && pluckySynth.cleanupVoices) {
                pluckySynth.cleanupVoices();
            }
            if (subSynth && subSynth.cleanupVoices) {
                subSynth.cleanupVoices();
            }
            
            // Sync playHiddenBtn with toggleBtn state
            syncPlayHiddenBtn();
            
            // Don't reset durations - keep them for next start
            waterPendingBassDuration = null;
            waterPendingHighDuration = null;
            waterPendingCellRow = null;
            waterPendingCellCol = null;
            pluckyPendingBassDuration = null;
            pluckyPendingHighDuration = null;
            pluckyPendingCellRow = null;
            pluckyPendingCellCol = null;
            subPendingBassDuration = null;
            subPendingOctaveDuration = null;
            subPendingCellRow = null;
            subPendingCellCol = null;
            pendingBPM = null;
            masterCycleStartTime = null;
            masterCycleNumber = 0;
            waterCreativeCycleCounter = 0;
            pluckyCreativeCycleCounter = 0;
            subCreativeCycleCounter = 0;
            
            // Reset transition states
            attackTransitionStartTime = null;
            attackTransitionDuration = 0;
            harmonic2TransitionStartTime = null;
            harmonic2TransitionDuration = 0;
            
            // Clear pending state from cells
            document.querySelectorAll('.grid-cell.pending').forEach(c => {
                c.classList.remove('pending');
            });
            
            // Update debug display to show current chord notes (not playing)
            const chordNotes = getCurrentChordNotes();
            updateDebugDisplay(chordNotes.bass, chordNotes.high);
        }
        
        function updateChordDisplay() {
            if (chordSequence.length === 0) {
                updateDebugDisplay([], []);
                updateChordSequenceDisplay();
                updateChordPreviewVisualState();
                return;
            }
            
            // Update chord sequence display
            updateChordSequenceDisplay();
            
            // Update chord preview visual state (for selection screen)
            updateChordPreviewVisualState();
            
            // Update debug display with current chord notes
            const chordNotes = getCurrentChordNotes();
            updateDebugDisplay(chordNotes.bass, chordNotes.high);
            
            // If playing, restart with new chord (but not during auto-advance)
            // Auto-advance is handled in cycleInterval, so we don't restart here
        }
        
        function updateChordPreviewVisualState() {
            const preview = document.getElementById('chordPreview');
            if (!preview) return;
            
            // Check if on selection screen
            const selectionScreen = document.getElementById('selectionScreen');
            const isOnSelectionScreen = selectionScreen && !selectionScreen.classList.contains('hidden');
            
            // Only update visual state if on selection screen and playing
            if (!isOnSelectionScreen || !isPlaying) {
                // Remove 'playing' class from all items when not playing or not on selection screen
                const items = preview.querySelectorAll('.chord-preview-item');
                items.forEach(item => {
                    item.classList.remove('playing');
                });
                return;
            }
            
            // Update visual state for selection screen during playback
            const items = preview.querySelectorAll('.chord-preview-item');
            items.forEach((item, index) => {
                // Skip the piano emoji (last item)
                if (index >= chordSequence.length) return;
                
                if (index === currentChordIndex) {
                    item.classList.add('playing');
                } else {
                    item.classList.remove('playing');
                }
            });
        }
        
        function updateChordSequenceDisplay() {
            const list = document.getElementById('chordSequenceList');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (chordSequence.length === 0) {
                list.innerHTML = '<span style="color: #666;">No chord sequence</span>';
                return;
            }
            
            chordSequence.forEach((chord, index) => {
                const item = document.createElement('div');
                item.className = 'chord-sequence-item';
                if (index === currentChordIndex) {
                    // Green: Current chord playing
                    item.classList.add('current');
                } else if (index === nextChordIndex) {
                    // Blue: Next chord that will play
                    item.style.borderColor = 'rgb(33, 150, 243)';
                }
                item.textContent = chord.original;
                
                // Add click handler - behavior differs by screen
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Check which screen we're on
                    const mainScreen = document.getElementById('mainScreen');
                    const isOnMainScreen = mainScreen && mainScreen.classList.contains('visible');
                    
                    if (isOnMainScreen) {
                        // Main screen: tap to set as next chord
                        nextChordIndex = index;
                        updateChordDisplay();
                        updateChordSequenceDisplay();
                    } else {
                        // Selection screen: open piano visualizer
                        if (chord && window.ChordCortex) {
                            window.ChordCortex.showChordPopup(chord.rootNote, chord.chordType, chord.original);
                        }
                    }
                });
                
                list.appendChild(item);
            });
        }
        
        function nextChord() {
            if (chordSequence.length === 0) return;
            // Change the NEXT chord that will play (not the current one)
            nextChordIndex = (nextChordIndex + 1) % chordSequence.length;
            updateChordDisplay();
            // Don't restart playback - just queue the next chord
        }
        
        function prevChord() {
            if (chordSequence.length === 0) return;
            // Change the NEXT chord that will play (not the current one)
            nextChordIndex = (nextChordIndex - 1 + chordSequence.length) % chordSequence.length;
            updateChordDisplay();
            // Don't restart playback - just queue the next chord
        }
        
        // Grid functions are now handled by GridManager class
        // Initialize GridManager with callbacks
        function initializeGridManager() {
            gridManager = new GridManager({
                durationMultipliers: DURATION_MULTIPLIERS,
                getIsPlaying: () => isPlaying,
                getCurrentBPM: () => currentBPM,
                onCellClick: (synthType, row, col, bassDurationMultiplier, highDurationMultiplier, isPlayingState, cell) => {
                    handleGridCellClick(synthType, row, col, bassDurationMultiplier, highDurationMultiplier, isPlayingState, cell);
                }
            });
        }
        
        function handleGridCellClick(synthType, row, col, bassDurationMultiplier, highDurationMultiplier, isPlayingState, cell) {
            if (synthType === 'water') {
                // Clear water grid active and pending states
                gridManager.clearGridStates('waterGrid');
                
                if (isPlayingState) {
                    cell.classList.add('pending');
                    waterPendingBassDuration = bassDurationMultiplier;
                    waterPendingHighDuration = highDurationMultiplier;
                    waterPendingCellRow = row;
                    waterPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    waterCurrentBassDuration = bassDurationMultiplier;
                    waterCurrentHighDuration = highDurationMultiplier;
                    waterActiveCellRow = row;
                    waterActiveCellCol = col;
                    waterPendingCellRow = null;
                    waterPendingCellCol = null;
                }
                
                // Update header animations
                gridManager.updateGridHeaderAnimations('waterGrid', waterCurrentBassDuration, waterCurrentHighDuration, 'water', waterActiveCellRow, waterActiveCellCol);
            } else if (synthType === 'plucky') {
                // Clear plucky grid active and pending states
                gridManager.clearGridStates('pluckyGrid');
                
                if (isPlayingState) {
                    cell.classList.add('pending');
                    pluckyPendingBassDuration = bassDurationMultiplier;
                    pluckyPendingHighDuration = highDurationMultiplier;
                    pluckyPendingCellRow = row;
                    pluckyPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    pluckyCurrentBassDuration = bassDurationMultiplier;
                    pluckyCurrentHighDuration = highDurationMultiplier;
                    pluckyActiveCellRow = row;
                    pluckyActiveCellCol = col;
                    pluckyPendingCellRow = null;
                    pluckyPendingCellCol = null;
                }
                
                // Update header animations
                gridManager.updateGridHeaderAnimations('pluckyGrid', pluckyCurrentBassDuration, pluckyCurrentHighDuration, 'plucky', pluckyActiveCellRow, pluckyActiveCellCol);
            } else if (synthType === 'sub') {
                // Clear sub grid active and pending states
                gridManager.clearGridStates('subGrid');
                
                // Column = lowest note tempo, Row = octave lower tempo
                const octaveDurationMultiplier = DURATION_MULTIPLIERS[row];
                
                if (isPlayingState) {
                    cell.classList.add('pending');
                    subPendingBassDuration = bassDurationMultiplier;
                    subPendingOctaveDuration = octaveDurationMultiplier;
                    subPendingCellRow = row;
                    subPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    subCurrentBassDuration = bassDurationMultiplier;
                    subCurrentOctaveDuration = octaveDurationMultiplier;
                    subActiveCellRow = row;
                    subActiveCellCol = col;
                    subPendingCellRow = null;
                    subPendingCellCol = null;
                }
                
                // Update header animations (for sub: col = bass, row = octave)
                gridManager.updateGridHeaderAnimations('subGrid', subCurrentBassDuration, subCurrentOctaveDuration, 'sub', subActiveCellRow, subActiveCellCol);
            }
        }
        
        // ========== SELECTION SCREEN ==========
        function loadPresets() {
            const presetSelect = document.getElementById('presetSelect');
            const presets = window.CHORD_PRESETS || {};
            
            Object.keys(presets).forEach(key => {
                const preset = presets[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${preset.name} - ${preset.style}`;
                presetSelect.appendChild(option);
            });
        }
        
        function playChordSound(chord, itemElement) {
            if (!chord || !window.PianoSound) return;
            
            // Don't allow chord preview clicks when main sequence is playing
            if (isPlaying) return;
            
            // Add playing class to remove background and border
            if (itemElement) {
                itemElement.classList.add('playing');
                // Calculate duration to match sequential playback:
                // arpeggioDelay (0.4s) + (notes.length * arpeggioInterval (0.15s)) + sustainDuration (0.8s) + buffer (0.5s)
                // We'll calculate this after we know the note count
            }
            
            // Use PianoVisualizer to get the same full palette notes as piano visualizer
            // This ensures consistent volume between chord preview and piano visualizer
            let noteNames = [];
            if (window.PianoVisualizer && window.PianoVisualizer.getChordPaletteNotes) {
                const paletteNotes = window.PianoVisualizer.getChordPaletteNotes(chord.rootNote, chord.chordType);
                // Convert palette notes to note name strings (e.g., "C4", "E4", "G4")
                noteNames = paletteNotes.map(noteObj => `${noteObj.note}${noteObj.octave}`);
            } else {
                // Fallback to old method if PianoVisualizer is not available
                const midiNotes = chordToMIDINotes(chord);
                const allMidiNotes = [...midiNotes.bass, ...midiNotes.high];
                noteNames = allMidiNotes.map(midiNote => midiToNoteName(midiNote));
            }
            
            // Remove duplicates (in case there are any)
            const uniqueNoteNames = [...new Set(noteNames)];
            
            // Play the chord notes sequentially (same as piano visualizer tap)
            // This plays chord first, then arpeggio - exactly like tapping a piano key
            // For chord preview items, use short preview (no arpeggio)
            if (uniqueNoteNames.length > 0 && window.PianoSound.playChordNotes) {
                window.PianoSound.playChordNotes(uniqueNoteNames, 100, { shortPreview: true });
                
                // Calculate total duration for removing 'playing' class
                // For short preview: chordDuration (0.18s) + buffer (0.2s)
                const totalDuration = 0.18 + 0.2;
                if (itemElement) {
                    setTimeout(() => {
                        itemElement.classList.remove('playing');
                    }, totalDuration * 1000);
                }
            }
        }
        
        function updateChordPreview() {
            const preview = document.getElementById('chordPreview');
            preview.innerHTML = '';
            
            if (chordSequence.length === 0) {
                preview.innerHTML = '<span style="color: #666;">No chords entered</span>';
                return;
            }
            
            // Check if on selection screen to determine where to place 🕮 emoji
            const selectionScreen = document.getElementById('selectionScreen');
            const isOnSelectionScreen = selectionScreen && !selectionScreen.classList.contains('hidden');
            
            chordSequence.forEach((chord, index) => {
                const item = document.createElement('div');
                item.className = 'chord-preview-item';
                // Only highlight current chord on main screen, not on selection screen
                const selectionScreen = document.getElementById('selectionScreen');
                const isOnSelectionScreen = selectionScreen && !selectionScreen.classList.contains('hidden');
                if (index === currentChordIndex && !isOnSelectionScreen) {
                    item.classList.add('current');
                }
                // Display the formatted chord name instead of original text
                item.textContent = getChordDisplayName(chord.rootNote, chord.chordType);
                
                // Add click handler to play chord sound
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (chord) {
                        playChordSound(chord, item);
                    }
                });
                
                preview.appendChild(item);
            });
            
            // Create ✎ emoji and add it as the last item in chordPreview
            const pianoEmoji = document.createElement('div');
            pianoEmoji.id = 'previewHeading';
            pianoEmoji.className = 'chord-preview-item';
            pianoEmoji.textContent = '🔍';
            pianoEmoji.style.cssText = 'cursor: pointer; transition: opacity 0.2s;';
            
            // Add click handler for piano emoji
            pianoEmoji.addEventListener('click', () => {
                // Don't allow piano emoji clicks when playing
                if (isPlaying || (window.PianoSound && window.PianoSound.getIsPlaying && window.PianoSound.getIsPlaying())) {
                    return;
                }
                if (chordSequence.length > 0 && chordSequence[currentChordIndex] && window.ChordCortex) {
                    const currentChord = chordSequence[currentChordIndex];
                    window.ChordCortex.showChordPopup(currentChord.rootNote, currentChord.chordType, currentChord.original);
                }
            });
            
            // Add hover effect for piano emoji
            pianoEmoji.addEventListener('mouseenter', () => {
                pianoEmoji.style.opacity = '0.7';
            });
            pianoEmoji.addEventListener('mouseleave', () => {
                pianoEmoji.style.opacity = '1';
            });
            
            // Add ✎ emoji as the last item in chordPreview
            preview.appendChild(pianoEmoji);
            
            // Add Play emoji below the preview panel (only on selection screen)
            // Always show playHiddenBtn on selection screen as proxy for main screen toggle
            if (isOnSelectionScreen) {
                // Get the parent container (selection-section div)
                const parentContainer = preview.parentElement;
                
                // Remove existing button container if it exists
                const existingButtonContainer = document.getElementById('buttonContainer');
                if (existingButtonContainer) {
                    existingButtonContainer.remove();
                }
                
                // Remove existing nextBtn if it exists (check both inside preview and in parent)
                const existingBtn = document.getElementById('nextBtn');
                if (existingBtn) {
                    existingBtn.remove();
                }
                
                // Remove existing playHiddenBtn if it exists (check both inside preview and in parent)
                const existingPlayHiddenBtn = document.getElementById('playHiddenBtn');
                if (existingPlayHiddenBtn) {
                    existingPlayHiddenBtn.remove();
                }
                
                // Create a wrapper container to center the buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.id = 'buttonContainer';
                buttonContainer.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 8px; margin-top: 8px;';
                
                const playEmoji = document.createElement('span');
                playEmoji.id = 'nextBtn';
                playEmoji.textContent = '⁝';
                playEmoji.style.cssText = 'cursor: pointer; transition: opacity 0.2s; font-size: 1.2em;';
                
                // Add hover effect for play emoji
                playEmoji.addEventListener('mouseenter', () => {
                    playEmoji.style.opacity = '0.7';
                });
                playEmoji.addEventListener('mouseleave', () => {
                    playEmoji.style.opacity = '1';
                });
                
                // Add gear emoji for playing without revealing main screen
                const playHiddenEmoji = document.createElement('span');
                playHiddenEmoji.id = 'playHiddenBtn';
                playHiddenEmoji.style.cssText = 'cursor: pointer; transition: opacity 0.2s; font-size: 1.2em;';
                
                // Add hover effect for gear emoji
                playHiddenEmoji.addEventListener('mouseenter', () => {
                    playHiddenEmoji.style.opacity = '0.7';
                });
                playHiddenEmoji.addEventListener('mouseleave', () => {
                    playHiddenEmoji.style.opacity = '1';
                });
                
                // Attach the click handler - proxy to toggleBtn
                playHiddenEmoji.addEventListener('click', playSequenceHidden);
                
                // Attach the click handler to go to main screen
                playEmoji.addEventListener('click', goToMainScreen);
                
                // Add buttons to the centered container
                buttonContainer.appendChild(playHiddenEmoji);
                buttonContainer.appendChild(playEmoji);
                
                // Append the button container to parent (below chordPreview div)
                parentContainer.appendChild(buttonContainer);
                
                // Sync initial state with toggleBtn after button is in DOM
                syncPlayHiddenBtn();
            }
            
            // Update visual state after creating preview items
            updateChordPreviewVisualState();
        }
        
        function updateSelectionScreenInteractions() {
            const presetSelect = document.getElementById('presetSelect');
            const chordInput = document.getElementById('chordInput');
            const chordPreview = document.getElementById('chordPreview');
            
            // Check if main sequence is playing (piano sounds don't disable selection screen)
            const shouldDisable = isPlaying;
            
            // Disable/enable preset select
            if (presetSelect) {
                presetSelect.disabled = shouldDisable;
                presetSelect.style.cursor = shouldDisable ? 'not-allowed' : 'default';
            }
            
            // Disable/enable chord input
            if (chordInput) {
                chordInput.disabled = shouldDisable;
                chordInput.style.cursor = shouldDisable ? 'not-allowed' : 'text';
            }
            
            // Disable/enable chord preview panel (make it non-interactive)
            if (chordPreview) {
                chordPreview.style.pointerEvents = shouldDisable ? 'none' : 'auto';
            }
        }
        
        function handlePresetChange() {
            // Don't allow preset changes when playing
            if (isPlaying || (window.PianoSound && window.PianoSound.getIsPlaying && window.PianoSound.getIsPlaying())) {
                return;
            }
            
            const presetSelect = document.getElementById('presetSelect');
            const chordInput = document.getElementById('chordInput');
            
            if (presetSelect.value) {
                const presets = window.CHORD_PRESETS || {};
                const preset = presets[presetSelect.value];
                
                if (preset) {
                    chordInput.value = preset.chords;
                    chordSequence = parseChordSequence(preset.chords);
                    currentChordIndex = 0;
                    nextChordIndex = chordSequence.length > 1 ? 1 : 0;
                    updateChordPreview();
                    
                    // Set BPM from preset if available
                    if (preset.bpm && isFinite(preset.bpm) && preset.bpm > 0) {
                        setBPM(preset.bpm);
                    }
                }
            }
        }
        
        function handleChordInput() {
            // Don't allow chord input changes when main sequence is playing
            // But allow input during piano preview playback (PianoSound.getIsPlaying)
            if (isPlaying) {
                return;
            }
            
            const chordInput = document.getElementById('chordInput');
            const presetSelect = document.getElementById('presetSelect');
            
            if (chordInput.value.trim()) {
                presetSelect.value = '';
                chordSequence = parseChordSequence(chordInput.value);
                currentChordIndex = 0;
                nextChordIndex = chordSequence.length > 1 ? 1 : 0;
                updateChordPreview();
            } else {
                chordSequence = [];
                currentChordIndex = 0;
                nextChordIndex = 0;
                updateChordPreview();
            }
        }
        
        async function playSequenceHidden() {
            // Simply trigger the toggleBtn click event - it's a proxy button
            const toggleBtn = document.getElementById('toggleBtn');
            if (toggleBtn) {
                toggleBtn.click();
            }
        }
        
        // Toggle main screen visibility function
        function toggleMainScreen() {
            const mainScreen = document.getElementById('mainScreen');
            const selectionScreen = document.getElementById('selectionScreen');
            const isMainScreenVisible = mainScreen.classList.contains('visible');
            
            if (isMainScreenVisible) {
                // Hide main screen, show selection screen
                if (isPlaying) {
                    stopPlaying();
                    const toggleBtn = document.getElementById('toggleBtn');
                    toggleBtn.textContent = 'Start';
                    toggleBtn.classList.remove('active');
                    syncPlayHiddenBtn();
                }
                mainScreen.classList.remove('visible');
                selectionScreen.classList.remove('hidden');
                // Reset main tutorial so it can be shown again if user comes back
                mainTutorialShown = false;
                // Update selection screen interactions state
                updateSelectionScreenInteractions();
            } else {
                // Show main screen, hide selection screen
                if (chordSequence.length === 0) {
                    alert('Please enter or select a chord sequence first.');
                    return;
                }
                
                // Ensure BPM is set from preset if one is selected
                const presetSelect = document.getElementById('presetSelect');
                if (presetSelect && presetSelect.value) {
                    const presets = window.CHORD_PRESETS || {};
                    const preset = presets[presetSelect.value];
                    if (preset && preset.bpm && isFinite(preset.bpm) && preset.bpm > 0) {
                        setBPM(preset.bpm);
                    }
                    
                    // Randomly pick Water Profile (except 'none')
                    const waterProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                    const randomWaterProfile = waterProfileOptions[Math.floor(Math.random() * waterProfileOptions.length)];
                    waterProfile = randomWaterProfile;
                    const waterProfileSelect = document.getElementById('waterProfileSelect');
                    if (waterProfileSelect) {
                        waterProfileSelect.value = randomWaterProfile;
                    }
                    
                    // Randomly pick Plucky Profile (except 'none')
                    const pluckyProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                    const randomPluckyProfile = pluckyProfileOptions[Math.floor(Math.random() * pluckyProfileOptions.length)];
                    pluckyProfile = randomPluckyProfile;
                    const pluckyProfileSelect = document.getElementById('pluckyProfileSelect');
                    if (pluckyProfileSelect) {
                        pluckyProfileSelect.value = randomPluckyProfile;
                    }
                    
                    // Randomly pick Sub Profile (except 'none')
                    const subProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                    const randomSubProfile = subProfileOptions[Math.floor(Math.random() * subProfileOptions.length)];
                    subProfile = randomSubProfile;
                    const subProfileSelect = document.getElementById('subProfileSelect');
                    if (subProfileSelect) {
                        subProfileSelect.value = randomSubProfile;
                    }
                }
                
                selectionScreen.classList.add('hidden');
                mainScreen.classList.add('visible');
                updateChordDisplay();
                updateChordSequenceDisplay();
                
                // Show main screen tutorial after a short delay (wait for elements to render)
                // Only show if user hasn't disabled tutorials
                if (!mainTutorialShown && checkTutorialPreference()) {
                    setTimeout(() => {
                        // Double check that main screen is visible before showing tutorial
                        const mainScreen = document.getElementById('mainScreen');
                        if (mainScreen && mainScreen.classList.contains('visible')) {
                            showMainTutorialStep(0);
                        }
                    }, 1000);
                }
            }
        }
        
        // Keep goToMainScreen for backward compatibility (now just calls toggleMainScreen)
        function goToMainScreen() {
            toggleMainScreen();
        }
        
        // ========== SIMPLE TUTORIAL SYSTEM ==========
        let currentTutorialStep = 0;
        let tutorialTimeout = null;
        let globalClickHandler = null;
        
        const tutorialSteps = [
            {
                targetId: 'chordInput',
                message: 'Write your own chords here'
            },
            {
                targetId: '.chord-preview-item',
                message: 'Tap to check what they sounds like'
            },
            {
                targetId: 'previewHeading',
                message: 'Find more chords here!'
            },
            {
                targetId: 'playHiddenBtn',
                message: 'Play your chord sequence!'
            },
            {
                targetId: 'nextBtn',
                message: 'Change the sounds!'
            }
        ];
        
        function showTooltip(element, message) {
            // Remove any existing tooltip
            const existingTooltip = document.querySelector('.simple-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
            
            // Remove previous highlights
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight', 'active');
            });
            
            // Highlight the target element
            element.classList.add('tutorial-highlight', 'active');
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'simple-tooltip';
            tooltip.textContent = message;
            document.body.appendChild(tooltip);
            
            // Position tooltip above the element
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            tooltip.style.left = `${rect.left + (rect.width / 2) - (tooltipRect.width / 2)}px`;
            tooltip.style.top = `${rect.top - tooltipRect.height - 10}px`;
            
            // Keep within viewport
            const padding = 10;
            if (parseInt(tooltip.style.left) < padding) {
                tooltip.style.left = `${padding}px`;
            }
            if (parseInt(tooltip.style.left) + tooltipRect.width > window.innerWidth - padding) {
                tooltip.style.left = `${window.innerWidth - tooltipRect.width - padding}px`;
            }
            
            // Make tooltip clickable
            tooltip.style.cursor = 'pointer';
            
            // Show tooltip
            setTimeout(() => {
                tooltip.classList.add('show');
            }, 10);
            
            return tooltip;
        }
        
        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) {
                // Tutorial complete
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight', 'active');
                });
                const tooltip = document.querySelector('.simple-tooltip');
                if (tooltip) tooltip.remove();
                return;
            }
            
            const step = tutorialSteps[stepIndex];
            // Support both ID selectors and class selectors
            let element = null;
            if (step.targetId.startsWith('.')) {
                // Class selector - get first matching element
                element = document.querySelector(step.targetId);
            } else {
                // ID selector
                element = document.getElementById(step.targetId);
            }
            
            if (!element) {
                // Element not found, skip to next
                showTutorialStep(stepIndex + 1);
                return;
            }
            
            const tooltip = showTooltip(element, step.message);
            currentTutorialStep = stepIndex;
            
            // Function to advance to next step
            const advanceToNext = () => {
                // Remove all event listeners
                element.removeEventListener('click', clickHandler);
                element.removeEventListener('change', changeHandler);
                element.removeEventListener('input', inputHandler);
                tooltip.removeEventListener('click', tooltipClickHandler);
                
                // Remove global click listener if tutorial is complete
                if (stepIndex + 1 >= tutorialSteps.length) {
                    if (globalClickHandler) {
                        document.removeEventListener('click', globalClickHandler, true);
                        globalClickHandler = null;
                    }
                    tooltip.classList.remove('show');
                    tooltip.remove();
                    // Remove highlights
                    document.querySelectorAll('.tutorial-highlight').forEach(el => {
                        el.classList.remove('tutorial-highlight', 'active');
                    });
                    return;
                }
                
                // Hide current tooltip
                tooltip.classList.remove('show');
                setTimeout(() => {
                    tooltip.remove();
                    // Move to next step
                    showTutorialStep(stepIndex + 1);
                }, 200);
            };
            
            // Wait for user to interact with the highlighted element or tooltip
            const clickHandler = (e) => {
                e.stopPropagation();
                advanceToNext();
            };
            
            const changeHandler = (e) => {
                advanceToNext();
            };
            
            const inputHandler = (e) => {
                // For textarea/input, advance after user types something
                if (e.target.value.trim().length > 0) {
                    advanceToNext();
                }
            };
            
            // Allow clicking on the tooltip itself to advance
            const tooltipClickHandler = (e) => {
                e.stopPropagation();
                advanceToNext();
            };
            
            tooltip.addEventListener('click', tooltipClickHandler);
            
            // Add global click listener to advance on any tap
            if (globalClickHandler) {
                document.removeEventListener('click', globalClickHandler, true);
            }
            globalClickHandler = (e) => {
                // Don't advance if clicking on the tooltip itself (handled separately)
                if (e.target.closest('.simple-tooltip')) {
                    return;
                }
                advanceToNext();
            };
            document.addEventListener('click', globalClickHandler, true);
            
            // Add appropriate event listeners based on element type
            if (element.tagName === 'SELECT') {
                element.addEventListener('change', changeHandler);
            } else if (element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
                if (element.type === 'range') {
                    // For sliders, listen to input events
                    element.addEventListener('input', inputHandler);
                } else {
                    // For text inputs, listen to input events
                    element.addEventListener('input', inputHandler);
                }
                // Also allow clicking to advance
                element.addEventListener('click', clickHandler);
            } else {
                // For buttons and other elements, listen to clicks
                element.addEventListener('click', clickHandler);
            }
        }
        
        function closeTutorial() {
            if (tutorialTimeout) {
                clearTimeout(tutorialTimeout);
                tutorialTimeout = null;
            }
            
            // Remove global click listener
            if (globalClickHandler) {
                document.removeEventListener('click', globalClickHandler, true);
                globalClickHandler = null;
            }
            
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight', 'active');
            });
            
            const tooltip = document.querySelector('.simple-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                setTimeout(() => tooltip.remove(), 200);
            }
            
            currentTutorialStep = 0;
        }
        
        // Make function globally accessible
        window.closeTutorial = closeTutorial;
        
        // ========== MAIN SCREEN TUTORIAL SYSTEM ==========
        let currentMainTutorialStep = 0;
        let mainTutorialTimeout = null;
        let mainTutorialGlobalClickHandler = null;
        let mainTutorialShown = false;
        
        const mainTutorialSteps = [
            {
                targetId: 'toggleBtn',
                message: 'Start/Stop'
            },
            {
                targetId: 'nextChordBtn',
                message: 'Press ← → to go the next/previous chord'
            },
            {
                targetSelector: '.chord-sequence-item',
                message: 'Or tap one to go next'
            },
            {
                targetId: 'waterControlsTab',
                message: 'Tap a sound to see its settings'
            },
            {
                targetSelector: '#waterGrid .grid-cell.active',
                message: 'Tap a cell to set the tempo for that sound'
            },
            {
                targetSelector: '#waterGrid .grid-cell.row-header',
                message: 'Row means tempo for bass notes of that sound'
            },
            {
                targetSelector: '#waterGrid .grid-cell.col-header',
                message: 'Column means tempo for high notes of that sound'
            }
        ];
        
        function showMainTutorialStep(stepIndex) {
            if (stepIndex >= mainTutorialSteps.length) {
                // Tutorial complete
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight', 'active');
                });
                const tooltip = document.querySelector('.simple-tooltip');
                if (tooltip) tooltip.remove();
                mainTutorialShown = true;
                return;
            }
            
            const step = mainTutorialSteps[stepIndex];
            let element = null;
            
            // If step targets waterGrid, ensure we're on water grid
            if (step.targetSelector && step.targetSelector.includes('#waterGrid')) {
                const waterTab = document.getElementById('waterControlsTab');
                const waterGrid = document.getElementById('waterGrid');
                // Check if water grid is currently visible
                if (waterGrid && waterGrid.style.display === 'none') {
                    // Switch to water grid by clicking the tab
                    if (waterTab) {
                        waterTab.click();
                        // Wait for DOM to update before finding element
                        setTimeout(() => {
                            findAndShowElement();
                        }, 100);
                        return;
                    }
                }
                
                // If targeting active cell, ensure one exists
                if (step.targetSelector.includes('.active')) {
                    const activeCell = document.querySelector('#waterGrid .grid-cell.active');
                    if (!activeCell) {
                        // Create a default active cell (row 1, col 5)
                        const defaultCell = document.querySelector('#waterGrid .grid-cell[data-row="1"][data-col="5"]');
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                        }
                    }
                }
            }
            
            findAndShowElement();
            
            function findAndShowElement() {
                // Handle both ID and selector-based targeting
                if (step.targetId) {
                    element = document.getElementById(step.targetId);
                } else if (step.targetSelector) {
                    // For selectors, get the first matching element
                    element = document.querySelector(step.targetSelector);
                }
                
                if (!element) {
                    // Element not found, skip to next
                    showMainTutorialStep(stepIndex + 1);
                    return;
                }
                
                const tooltip = showTooltip(element, step.message);
                currentMainTutorialStep = stepIndex;
                
                // Function to advance to next step
                const advanceToNext = () => {
                    // Remove all event listeners
                    if (element) {
                        element.removeEventListener('click', clickHandler);
                        element.removeEventListener('change', changeHandler);
                        element.removeEventListener('input', inputHandler);
                    }
                    tooltip.removeEventListener('click', tooltipClickHandler);
                    
                    // Remove global click listener if tutorial is complete
                    if (stepIndex + 1 >= mainTutorialSteps.length) {
                        if (mainTutorialGlobalClickHandler) {
                            document.removeEventListener('click', mainTutorialGlobalClickHandler, true);
                            mainTutorialGlobalClickHandler = null;
                        }
                        tooltip.classList.remove('show');
                        tooltip.remove();
                        // Remove highlights
                        document.querySelectorAll('.tutorial-highlight').forEach(el => {
                            el.classList.remove('tutorial-highlight', 'active');
                        });
                        mainTutorialShown = true;
                        return;
                    }
                    
                    // Hide current tooltip
                    tooltip.classList.remove('show');
                    setTimeout(() => {
                        tooltip.remove();
                        // Move to next step
                        showMainTutorialStep(stepIndex + 1);
                    }, 200);
                };
                
                // Wait for user to interact with the highlighted element or tooltip
                const clickHandler = (e) => {
                    e.stopPropagation();
                    advanceToNext();
                };
                
                const changeHandler = (e) => {
                    advanceToNext();
                };
                
                const inputHandler = (e) => {
                    // For textarea/input, advance after user types something
                    if (e.target.value.trim().length > 0) {
                        advanceToNext();
                    }
                };
                
                // Allow clicking on the tooltip itself to advance
                const tooltipClickHandler = (e) => {
                    e.stopPropagation();
                    advanceToNext();
                };
                
                tooltip.addEventListener('click', tooltipClickHandler);
                
                // Add global click listener to advance on any tap
                if (mainTutorialGlobalClickHandler) {
                    document.removeEventListener('click', mainTutorialGlobalClickHandler, true);
                }
                mainTutorialGlobalClickHandler = (e) => {
                    // Don't advance if clicking on the tooltip itself (handled separately)
                    if (e.target.closest('.simple-tooltip')) {
                        return;
                    }
                    advanceToNext();
                };
                document.addEventListener('click', mainTutorialGlobalClickHandler, true);
                
                // Add appropriate event listeners based on element type
                if (element.tagName === 'SELECT') {
                    element.addEventListener('change', changeHandler);
                } else if (element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
                    if (element.type === 'range') {
                        // For sliders, listen to input events
                        element.addEventListener('input', inputHandler);
                    } else {
                        // For text inputs, listen to input events
                        element.addEventListener('input', inputHandler);
                    }
                    // Also allow clicking to advance
                    element.addEventListener('click', clickHandler);
                } else {
                    // For buttons and other elements, listen to clicks
                    element.addEventListener('click', clickHandler);
                }
            }
        }
        
        function closeMainTutorial() {
            if (mainTutorialTimeout) {
                clearTimeout(mainTutorialTimeout);
                mainTutorialTimeout = null;
            }
            
            // Remove global click listener
            if (mainTutorialGlobalClickHandler) {
                document.removeEventListener('click', mainTutorialGlobalClickHandler, true);
                mainTutorialGlobalClickHandler = null;
            }
            
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight', 'active');
            });
            
            const tooltip = document.querySelector('.simple-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                setTimeout(() => tooltip.remove(), 200);
            }
            
            currentMainTutorialStep = 0;
            mainTutorialShown = true;
        }
        
        // Make function globally accessible
        window.closeMainTutorial = closeMainTutorial;
        
        // ========== TUTORIAL PROMPT MODAL ==========
        function showTutorialPrompt() {
            const modal = document.getElementById('tutorialPromptModal');
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideTutorialPrompt() {
            const modal = document.getElementById('tutorialPromptModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function checkTutorialPreference() {
            const neverShow = localStorage.getItem('chordCanvasNeverShowTutorial');
            return neverShow !== 'true';
        }
        
        function setTutorialPreference(neverShow) {
            if (neverShow) {
                localStorage.setItem('chordCanvasNeverShowTutorial', 'true');
            } else {
                localStorage.removeItem('chordCanvasNeverShowTutorial');
            }
        }
        
        // Function to manually start tutorial (bypasses preference check)
        function startTutorialManually() {
            // Check if tutorial is already showing
            const existingTooltip = document.querySelector('.simple-tooltip');
            const selectionScreen = document.getElementById('selectionScreen');
            const isOnSelectionScreen = selectionScreen && !selectionScreen.classList.contains('hidden');
            
            if (existingTooltip && isOnSelectionScreen) {
                // Tutorial is already showing, advance to next step
                if (currentTutorialStep < tutorialSteps.length - 1) {
                    // Not the last step, advance to next
                    showTutorialStep(currentTutorialStep + 1);
                } else {
                    // Last step, restart from beginning
                    closeTutorial();
                    setTimeout(() => {
                        showTutorialStep(0);
                    }, 300);
                }
            } else {
                // No tutorial showing, start from beginning
                closeTutorial();
                closeMainTutorial();
                setTimeout(() => {
                    showTutorialStep(0);
                }, 300);
            }
        }
        
        // Function to manually start main screen tutorial (bypasses preference check)
        function startMainTutorialManually() {
            // Check if tutorial is already showing
            const existingTooltip = document.querySelector('.simple-tooltip');
            const mainScreen = document.getElementById('mainScreen');
            const isOnMainScreen = mainScreen && mainScreen.classList.contains('visible');
            
            if (existingTooltip && isOnMainScreen) {
                // Tutorial is already showing, advance to next step
                if (currentMainTutorialStep < mainTutorialSteps.length - 1) {
                    // Not the last step, advance to next
                    showMainTutorialStep(currentMainTutorialStep + 1);
                } else {
                    // Last step, restart from beginning
                    closeMainTutorial();
                    mainTutorialShown = false;
                    setTimeout(() => {
                        showMainTutorialStep(0);
                    }, 300);
                }
            } else {
                // No tutorial showing, start from beginning
                closeTutorial();
                closeMainTutorial();
                mainTutorialShown = false;
                setTimeout(() => {
                    showMainTutorialStep(0);
                }, 300);
            }
        }
        
        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            loadPresets();
            
            // Set up piano sound callbacks to update selection screen interactions
            if (window.PianoSound) {
                window.PianoSound.setOnPlayStart(() => {
                    updateSelectionScreenInteractions();
                });
                window.PianoSound.setOnPlayEnd(() => {
                    updateSelectionScreenInteractions();
                });
            }
            
            // Initialize selection screen interactions state
            updateSelectionScreenInteractions();
            
            // Check if user wants to see tutorials
            const showTutorials = checkTutorialPreference();
            
            if (showTutorials) {
                // Show tutorial prompt modal
                setTimeout(() => {
                    showTutorialPrompt();
                }, 500);
                
                // Handle tutorial prompt buttons
                document.getElementById('tutorialPromptYes').addEventListener('click', () => {
                    const neverShow = document.getElementById('neverShowTutorial').checked;
                    setTutorialPreference(neverShow);
                    hideTutorialPrompt();
                    // Show tutorial after modal closes
                    setTimeout(() => {
                        showTutorialStep(0);
                    }, 300);
                });
                
                document.getElementById('tutorialPromptNo').addEventListener('click', () => {
                    const neverShow = document.getElementById('neverShowTutorial').checked;
                    setTutorialPreference(neverShow);
                    hideTutorialPrompt();
                });
            }
            
            // Randomly pick a preset to load
            const presetSelect = document.getElementById('presetSelect');
            if (presetSelect) {
                const presets = window.CHORD_PRESETS || {};
                const presetKeys = Object.keys(presets);
                if (presetKeys.length > 0) {
                    const randomKey = presetKeys[Math.floor(Math.random() * presetKeys.length)];
                    presetSelect.value = randomKey;
                    handlePresetChange();
                }
            }
            
            initializeGridManager();
            gridManager.createGrid('waterGrid', 'water');
            gridManager.createGrid('pluckyGrid', 'plucky');
            gridManager.createGrid('subGrid', 'sub');
            updateBPM();
            
            
            document.getElementById('presetSelect').addEventListener('change', handlePresetChange);
            document.getElementById('chordInput').addEventListener('input', handleChordInput);
            // nextBtn is now dynamically created in updateChordPreview, so event listener is attached there
            // This line is kept for backward compatibility but button may not exist at init time
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn) {
                nextBtn.addEventListener('click', goToMainScreen);
            }
            
            // Tutorial button - allows users to see tutorial even if they said "never show again"
            document.getElementById('showTutorialBtn').addEventListener('click', () => {
                startTutorialManually();
            });
            
            document.getElementById('prevBtn').addEventListener('click', prevChord);
            document.getElementById('nextChordBtn').addEventListener('click', nextChord);
            
            document.getElementById('waterProfileSelect').addEventListener('change', (e) => {
                waterProfile = e.target.value;
                waterCreativeCycleCounter = 0;
            });
            
            document.getElementById('pluckyProfileSelect').addEventListener('change', (e) => {
                pluckyProfile = e.target.value;
                pluckyCreativeCycleCounter = 0;
            });
            
            document.getElementById('subProfileSelect').addEventListener('change', (e) => {
                subProfile = e.target.value;
                subCreativeCycleCounter = 0;
            });
            
            document.getElementById('bpmSlider').addEventListener('input', updateBPM);
            
            // Selection screen BPM slider
            const presetBpmSlider = document.getElementById('presetBpmSlider');
            const presetBpmDisplay = document.getElementById('presetBpmDisplay');
            if (presetBpmSlider && presetBpmDisplay) {
                presetBpmSlider.addEventListener('input', (e) => {
                    const newBPM = parseInt(e.target.value);
                    presetBpmDisplay.textContent = `${newBPM} BPM`;
                    setBPM(newBPM);
                });
            }
            
            // Tab switching (water tab handler moved above)
            
            // Sub synth volume control
            document.getElementById('subVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('subVolumeDisplay').textContent = volumeValue + '%';
                subVolumeGain = volumeValue / 100;
                if (subSynth && subSynth.outputVolume) {
                    subSynth.outputVolume.gain.value = subVolumeGain;
                }
            });
            
            // Sub synth controls
            document.getElementById('subReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('subReverbDisplay').textContent = reverbValue + '%';
                subReverbGain = reverbValue / 100;
                if (subSynth && subSynth.reverbGain) {
                    subSynth.reverbGain.gain.value = subReverbGain;
                }
            });
            
            document.getElementById('subAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('subAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                subAttackTime = attackValue / 1000;
            });
            
            document.getElementById('subSaturationSlider').addEventListener('input', (e) => {
                const saturationValue = parseInt(e.target.value);
                document.getElementById('subSaturationDisplay').textContent = saturationValue + '%';
                // Convert percentage to distortion value (0-1)
                subSaturationAmount = saturationValue / 100;
                if (subSynth && subSynth.saturation) {
                    subSynth.saturation.distortion = subSaturationAmount;
                }
            });
            
            // Sub volume modulation - applies on next cycle
            document.getElementById('subVolumeModulation').addEventListener('change', (e) => {
                subVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            document.getElementById('pluckyControlsTab').addEventListener('click', () => {
                document.getElementById('pluckyControlsTab').classList.add('active');
                document.getElementById('waterControlsTab').classList.remove('active');
                document.getElementById('subControlsTab').classList.remove('active');
                // Update tab colors
                document.getElementById('pluckyControlsTab').style.background = '#1a1a1a';
                document.getElementById('pluckyControlsTab').style.borderColor = '#1a1a1a';
                document.getElementById('pluckyControlsTab').style.color = '#ffffff';
                document.getElementById('waterControlsTab').style.background = '#ffffff';
                document.getElementById('waterControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('waterControlsTab').style.color = '#666';
                document.getElementById('subControlsTab').style.background = '#ffffff';
                document.getElementById('subControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('subControlsTab').style.color = '#666';
                document.getElementById('pluckyControlsPanel').style.display = 'block';
                document.getElementById('waterControlsPanel').style.display = 'none';
                document.getElementById('subControlsPanel').style.display = 'none';
                // Show/hide grids
                document.getElementById('pluckyGrid').style.display = 'grid';
                document.getElementById('waterGrid').style.display = 'none';
                document.getElementById('subGrid').style.display = 'none';
            });
            
            document.getElementById('subControlsTab').addEventListener('click', () => {
                document.getElementById('subControlsTab').classList.add('active');
                document.getElementById('waterControlsTab').classList.remove('active');
                document.getElementById('pluckyControlsTab').classList.remove('active');
                // Update tab colors
                document.getElementById('subControlsTab').style.background = '#1a1a1a';
                document.getElementById('subControlsTab').style.borderColor = '#1a1a1a';
                document.getElementById('subControlsTab').style.color = '#ffffff';
                document.getElementById('waterControlsTab').style.background = '#ffffff';
                document.getElementById('waterControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('waterControlsTab').style.color = '#666';
                document.getElementById('pluckyControlsTab').style.background = '#ffffff';
                document.getElementById('pluckyControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('pluckyControlsTab').style.color = '#666';
                document.getElementById('subControlsPanel').style.display = 'block';
                document.getElementById('waterControlsPanel').style.display = 'none';
                document.getElementById('pluckyControlsPanel').style.display = 'none';
                // Show/hide grids
                document.getElementById('subGrid').style.display = 'grid';
                document.getElementById('waterGrid').style.display = 'none';
                document.getElementById('pluckyGrid').style.display = 'none';
            });
            
            document.getElementById('waterControlsTab').addEventListener('click', () => {
                document.getElementById('waterControlsTab').classList.add('active');
                document.getElementById('pluckyControlsTab').classList.remove('active');
                document.getElementById('subControlsTab').classList.remove('active');
                // Update tab colors
                document.getElementById('waterControlsTab').style.background = '#1a1a1a';
                document.getElementById('waterControlsTab').style.borderColor = '#1a1a1a';
                document.getElementById('waterControlsTab').style.color = '#ffffff';
                document.getElementById('pluckyControlsTab').style.background = '#ffffff';
                document.getElementById('pluckyControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('pluckyControlsTab').style.color = '#666';
                document.getElementById('subControlsTab').style.background = '#ffffff';
                document.getElementById('subControlsTab').style.borderColor = '#e5e5e5';
                document.getElementById('subControlsTab').style.color = '#666';
                document.getElementById('pluckyControlsTab').style.color = '#666';
                document.getElementById('subControlsTab').style.background = '#e0e0e0';
                document.getElementById('subControlsTab').style.color = '#666';
                document.getElementById('waterControlsPanel').style.display = 'block';
                document.getElementById('pluckyControlsPanel').style.display = 'none';
                document.getElementById('subControlsPanel').style.display = 'none';
                // Show/hide grids
                document.getElementById('waterGrid').style.display = 'grid';
                document.getElementById('pluckyGrid').style.display = 'none';
                document.getElementById('subGrid').style.display = 'none';
            });
            
            // Water synth volume control
            document.getElementById('waterVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('waterVolumeDisplay').textContent = volumeValue + '%';
                waterVolumeGain = volumeValue / 100;
                if (waterSynth && waterSynth.outputVolume) {
                    waterSynth.outputVolume.gain.value = waterVolumeGain;
                }
            });
            
            // Water synth controls
            document.getElementById('waterReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('waterReverbDisplay').textContent = reverbValue + '%';
                waterReverbGain = reverbValue / 100;
                if (waterSynth && waterSynth.reverbGain) {
                    waterSynth.reverbGain.gain.value = waterReverbGain;
                }
            });
            
            document.getElementById('waterAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('waterAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                waterAttackTime = attackValue / 1000;
                attackTime = waterAttackTime; // Legacy compatibility
                // Cancel any ongoing transition for this parameter
                attackTransitionStartTime = null;
                attackTransitionDuration = 0;
                targetAttackTime = waterAttackTime;
            });
            
            document.getElementById('waterHarmonic2Slider').addEventListener('input', (e) => {
                const harmonicValue = parseInt(e.target.value);
                document.getElementById('waterHarmonic2Display').textContent = harmonicValue + '%';
                // Convert percentage to gain (0-1)
                waterHarmonic2Gain = harmonicValue / 100;
                harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                // Cancel any ongoing transition for this parameter
                harmonic2TransitionStartTime = null;
                harmonic2TransitionDuration = 0;
                targetHarmonic2Gain = waterHarmonic2Gain;
            });
            
            // Plucky synth volume control
            document.getElementById('pluckyVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('pluckyVolumeDisplay').textContent = volumeValue + '%';
                pluckyVolumeGain = volumeValue / 100;
                if (pluckySynth && pluckySynth.outputVolume) {
                    pluckySynth.outputVolume.gain.value = pluckyVolumeGain;
                }
            });
            
            // Plucky synth controls
            document.getElementById('pluckyReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('pluckyReverbDisplay').textContent = reverbValue + '%';
                pluckyReverbGain = reverbValue / 100;
                if (pluckySynth && pluckySynth.reverbGain) {
                    pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                }
            });
            
            document.getElementById('pluckyAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('pluckyAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                pluckyAttackTime = attackValue / 1000;
            });
            
            // Water volume modulation - applies on next cycle
            document.getElementById('waterVolumeModulation').addEventListener('change', (e) => {
                waterVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            // Plucky volume modulation - applies on next cycle
            document.getElementById('pluckyVolumeModulation').addEventListener('change', (e) => {
                pluckyVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            // Main screen toggle button click handler
            document.getElementById('toggleMainScreenBtn').addEventListener('click', toggleMainScreen);
            
            // Add hover effect for toggle button
            const toggleMainScreenBtn = document.getElementById('toggleMainScreenBtn');
            toggleMainScreenBtn.addEventListener('mouseenter', () => {
                toggleMainScreenBtn.style.opacity = '0.7';
            });
            toggleMainScreenBtn.addEventListener('mouseleave', () => {
                toggleMainScreenBtn.style.opacity = '1';
            });
            
            // Main screen tutorial button - allows users to see tutorial even if they said "never show again"
            document.getElementById('showMainTutorialBtn').addEventListener('click', () => {
                startMainTutorialManually();
            });
            
            document.getElementById('toggleBtn').addEventListener('click', async () => {
                const btn = document.getElementById('toggleBtn');
                
                if (isPlaying) {
                    stopPlaying();
                    btn.textContent = 'Start';
                    btn.classList.remove('active');
                    syncPlayHiddenBtn();
                } else {
                    await initAudio();
                    
                    // Set defaults if no cells are selected
                    const waterActiveCell = document.querySelector('#waterGrid .grid-cell.active');
                    const pluckyActiveCell = document.querySelector('#pluckyGrid .grid-cell.active');
                    const subActiveCell = document.querySelector('#subGrid .grid-cell.active');
                    
                    if (!waterActiveCell) {
                        // Default water: row 1, column 5 (240/bpm, 30/bpm)
                        const defaultCell = document.querySelector(`#waterGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            waterCurrentBassDuration = 240;
                            waterCurrentHighDuration = 30;
                            waterActiveCellRow = 1;
                            waterActiveCellCol = 5;
                        }
                    } else {
                        const row = parseInt(waterActiveCell.dataset.row);
                        const col = parseInt(waterActiveCell.dataset.col);
                        waterCurrentBassDuration = DURATION_MULTIPLIERS[row];
                        waterCurrentHighDuration = DURATION_MULTIPLIERS[col];
                        waterActiveCellRow = row;
                        waterActiveCellCol = col;
                    }
                    
                    if (!pluckyActiveCell) {
                        // Default plucky: row 1, column 5 (240/bpm, 30/bpm)
                        const defaultCell = document.querySelector(`#pluckyGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            pluckyCurrentBassDuration = 240;
                            pluckyCurrentHighDuration = 30;
                            pluckyActiveCellRow = 1;
                            pluckyActiveCellCol = 5;
                        }
                    } else {
                        const row = parseInt(pluckyActiveCell.dataset.row);
                        const col = parseInt(pluckyActiveCell.dataset.col);
                        pluckyCurrentBassDuration = DURATION_MULTIPLIERS[row];
                        pluckyCurrentHighDuration = DURATION_MULTIPLIERS[col];
                        pluckyActiveCellRow = row;
                        pluckyActiveCellCol = col;
                    }
                    
                    if (!subActiveCell) {
                        // Default sub: row 1, column 5 (240/bpm for lowest, 30/bpm for octave)
                        const defaultCell = document.querySelector(`#subGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            subCurrentBassDuration = 240;
                            subCurrentOctaveDuration = 30;
                            subActiveCellRow = 1;
                            subActiveCellCol = 5;
                        }
                    } else {
                        const row = parseInt(subActiveCell.dataset.row);
                        const col = parseInt(subActiveCell.dataset.col);
                        subCurrentBassDuration = DURATION_MULTIPLIERS[col];
                        subCurrentOctaveDuration = DURATION_MULTIPLIERS[row];
                        subActiveCellRow = row;
                        subActiveCellCol = col;
                    }
                    
                    // Clear any pending cells
                    document.querySelectorAll('.grid-cell.pending').forEach(c => {
                        c.classList.remove('pending');
                    });
                    
                    startPlaying();
                    btn.textContent = '⏹ Stop';
                    btn.classList.add('active');
                    syncPlayHiddenBtn();
                }
            });
        });
    </script>
</body>
</html>

