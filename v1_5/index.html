<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Canvas - V1.5</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Pacifico&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="chord-intervals-config.js"></script>
    <script src="chord-presets.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            max-width: 100%;
            margin: 0;
            padding: 10px 20px;
            background: #ffffff;
            color: #000;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        
        .page-header {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-start;
        }
        
        .header-section {
            flex: 1;
            min-width: 200px;
        }
        
        .header-section.bpm-section {
            min-width: 250px;
        }
        
        .header-section.full-width {
            flex: 1 1 100%;
        }
        
        .header-section h3 {
            margin: 0 0 6px 0;
            color: #4CAF50;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        
        #selectionScreen { display: block; }
        #selectionScreen.hidden { display: none; }
        #mainScreen { display: none; }
        #mainScreen.visible { display: block; }
        
        .selection-container {
            max-width: 700px;
            margin: 0 auto;
            padding: 15px;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .selection-container h1 {
            margin: 0 0 12px 0;
            color: #4CAF50;
            font-size: 18px;
            font-family: 'Pacifico', 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            font-weight: 400;
            letter-spacing: -0.02em;
        }
        
        .selection-section {
            margin-bottom: 12px;
        }
        
        .selection-section h2 {
            margin: 0 0 6px 0;
            color: #666;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        #chordInput {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 13px;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            background: #ffffff;
            color: #000;
            resize: vertical;
            font-family: monospace;
        }
        
        #presetSelect {
            width: 100%;
            padding: 6px;
            font-size: 13px;
            background: #ffffff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-bottom: 6px;
        }
        
        .preset-info {
            padding: 6px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 3px;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        
        .chord-preview {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            min-height: 40px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .chord-preview-item {
            padding: 3px 8px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .chord-preview-item.current {
            background: rgba(76, 175, 80, 0.5);
            border-color: #8BC34A;
            font-weight: bold;
        }
        
        button {
            padding: 6px 12px;
            font-size: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 6px;
        }
        
        button:hover { background: #45a049; }
        button.active { background: #f44336; }
        button:disabled { background: #ccc; color: #666; cursor: not-allowed; }
        
        #prevBtn, #nextChordBtn {
            background: rgba(33, 150, 243, 0.3);
            border: 1px solid #2196F3;
            color: #2196F3;
        }
        
        #prevBtn:hover, #nextChordBtn:hover {
            background: rgba(33, 150, 243, 0.4);
        }
        
        h1 { 
            margin: 0 0 8px 0; 
            font-size: 16px; 
            font-family: 'Pacifico', 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            font-weight: 400;
            letter-spacing: -0.02em;
            color: #000;
        }
        
        h2 {
            font-weight: 500;
            letter-spacing: -0.01em;
            color: #000;
        }
        
        .controls {
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        .controls-row:last-child { margin-bottom: 0; }
        
        .bpm-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bpm-slider { flex: 1; min-width: 150px; }
        .bpm-display { min-width: 70px; font-size: 13px; font-weight: bold; }
        
        .chord-navigation {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: #e0e0e0;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            padding: 0;
            width: 100%;
        }
        
        
        .grid-cell {
            padding: 1px;
            margin: 0;
            background: #ffffff;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 11px;
            line-height: 1;
            color: #000;
        }
        
        .grid-cell:hover:not(.header) { background: #f0f0f0; }
        .grid-cell.header {
            background: #f5f5f5;
            cursor: default;
            font-weight: bold;
            color: #666;
        }
        
        .grid-cell.header.row-header {
            color: #9C27B0; /* Purple for bass (first column) */
        }
        
        .grid-cell.header.col-header {
            color: #FF5722; /* Red for high notes (first row) */
        }
        .grid-cell.active {
            background: #4CAF50;
            color: #fff;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.2);
        }
        .grid-cell.pending {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196F3;
            box-shadow: inset 0 0 4px rgba(33, 150, 243, 0.2);
        }
        .grid-cell.pending:hover:not(.header) {
            background: rgba(33, 150, 243, 0.3);
        }
        
        .volume-modulation-display {
            margin-top: 8px;
            padding: 8px;
            background: #ffffff;
            border-radius: 3px;
            border: 1px solid #4CAF50;
        }
        
        .volume-modulation-display h3 {
            margin: 0 0 4px 0;
            color: #4CAF50;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .chord-sequence-display {
            padding: 0;
        }
        
        .chord-sequence-display h3 {
            margin: 0 0 6px 0;
            color: #4CAF50;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .chord-sequence-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .chord-sequence-item {
            padding: 3px 8px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 3px;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .chord-sequence-item.current {
            background: rgba(76, 175, 80, 0.6);
            border-color: #8BC34A;
            font-weight: bold;
        }
        
        .debug-display {
            padding: 0;
        }
        
        .debug-display h3 {
            margin: 0 0 6px 0;
            color: #FF9800;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .debug-section {
            margin-bottom: 0;
            margin-right: 16px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .debug-section:last-child { margin-right: 0; }
        
        .debug-section-label {
            font-weight: bold;
            color: #666;
            margin-bottom: 0;
            font-size: 11px;
            white-space: nowrap;
        }
        
        .debug-notes {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        
        .debug-note-item {
            padding: 3px 6px;
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #FF9800;
            border-radius: 2px;
            font-size: 11px;
            font-family: monospace;
            color: #000;
        }
        
        .debug-note-item.bass {
            background: rgba(156, 39, 176, 0.2);
            border-color: #9C27B0;
        }
        
        .debug-note-item.high {
            background: rgba(255, 87, 34, 0.2);
            border-color: #FF5722;
        }
        
        label { font-size: 12px; white-space: nowrap; color: #000; }
        select { padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px; }
        
        .synth-tab {
            transition: all 0.2s;
        }
        
        .synth-tab.active {
            background: #4CAF50 !important;
            color: white !important;
        }
        
        .synth-tab:not(.active) {
            background: #e0e0e0 !important;
            color: #666 !important;
        }
        
        .synth-controls-panel {
            padding: 8px 0;
        }
    </style>
</head>
<body>
    <!-- Selection Screen -->
    <div id="selectionScreen">
        <div class="selection-container">
            <h1>Chord Canvas</h1>
            <div class="selection-section">
                <h2>Preset</h2>
                <select id="presetSelect"><option value="">-- Select --</option></select>
                <div id="presetInfo" class="preset-info" style="display: none;"></div>
            </div>
            <div class="selection-section">
                <h2>Or Enter Chords</h2>
                <textarea id="chordInput" placeholder="Am, D7, G, C"></textarea>
            </div>
            <div class="selection-section">
                <h2>Preview</h2>
                <div id="chordPreview" class="chord-preview"></div>
            </div>
            <button id="nextBtn" style="width: 100%; margin-top: 8px;">Next →</button>
        </div>
    </div>
    
    <!-- Main Screen -->
    <div id="mainScreen">
        <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px; flex-wrap: wrap;">
            <h1 style="margin: 0;">Chord Canvas</h1>
            <div class="bpm-control" style="display: flex; align-items: center; gap: 8px;">
                <input type="range" id="bpmSlider" class="bpm-slider" min="40" max="240" value="120" step="1" style="flex: 1; min-width: 150px;">
                <div class="bpm-display" id="bpmDisplay" style="min-width: 70px; font-size: 13px; font-weight: bold;">120BPM</div>
                <div style="font-size: 11px; color: #666;" id="durationDisplay">2.00s</div>
            </div>
        </div>
        
        <!-- Page Header -->
        <div class="page-header">
            
            <!-- Synth Controls Navbar -->
            <div class="header-section full-width" style="margin-top: 8px;">
                <div style="display: flex; gap: 8px; margin-bottom: 8px; border-bottom: 1px solid #ddd;">
                    <button id="waterControlsTab" class="synth-tab active" style="padding: 6px 12px; background: #4CAF50; border: none; border-radius: 3px 3px 0 0; color: white; cursor: pointer; font-size: 12px;">Water Synth</button>
                    <button id="pluckyControlsTab" class="synth-tab" style="padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 3px 3px 0 0; color: #666; cursor: pointer; font-size: 12px;">Plucky Synth</button>
                    <button id="subControlsTab" class="synth-tab" style="padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 3px 3px 0 0; color: #666; cursor: pointer; font-size: 12px;">Sub Synth</button>
                </div>
                
                <!-- Water Synth Controls -->
                <div id="waterControlsPanel" class="synth-controls-panel">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Water Profile</div>
                            <select id="waterProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="waterVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterVolumeSlider" class="bpm-slider" min="0" max="100" value="50" step="1">
                                <div class="bpm-display" id="waterVolumeDisplay">50%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterReverbSlider" class="bpm-slider" min="0" max="100" value="77" step="1">
                                <div class="bpm-display" id="waterReverbDisplay">77%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterAttackSlider" class="bpm-slider" min="1" max="100" value="20" step="1">
                                <div class="bpm-display" id="waterAttackDisplay">20ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="waterHarmonic2Slider" class="bpm-slider" min="0" max="100" value="30" step="1">
                                <div class="bpm-display" id="waterHarmonic2Display">30%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">2nd Harmonic</div>
                        </div>
                    </div>
                </div>
                
                <!-- Plucky Synth Controls -->
                <div id="pluckyControlsPanel" class="synth-controls-panel" style="display: none;">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Plucky Profile</div>
                            <select id="pluckyProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="pluckyVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyVolumeSlider" class="bpm-slider" min="0" max="100" value="50" step="1">
                                <div class="bpm-display" id="pluckyVolumeDisplay">50%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyReverbSlider" class="bpm-slider" min="0" max="100" value="77" step="1">
                                <div class="bpm-display" id="pluckyReverbDisplay">77%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="pluckyAttackSlider" class="bpm-slider" min="1" max="100" value="66" step="1">
                                <div class="bpm-display" id="pluckyAttackDisplay">66ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                    </div>
                </div>
                
                <!-- Sub Synth Controls -->
                <div id="subControlsPanel" class="synth-controls-panel" style="display: none;">
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div class="header-section">
                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Sub Profile</div>
                            <select id="subProfileSelect" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="none">none</option>
                                <option value="drunk">drunk</option>
                                <option value="creative">creative</option>
                                <option value="lazy">lazy</option>
                                <option value="threat">threat</option>
                            </select>
                        </div>
                        
                        <div class="header-section">
                            <select id="subVolumeModulation" style="width: 100%; padding: 4px; font-size: 12px; background: #ffffff; color: #000; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="triangle">Triangle</option>
                                <option value="ascend">Ascend</option>
                                <option value="descend">Descend</option>
                            </select>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Volume Mod</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subVolumeSlider" class="bpm-slider" min="0" max="100" value="22" step="1">
                                <div class="bpm-display" id="subVolumeDisplay">22%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Output Volume</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subReverbSlider" class="bpm-slider" min="0" max="100" value="12" step="1">
                                <div class="bpm-display" id="subReverbDisplay">12%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Reverb</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subAttackSlider" class="bpm-slider" min="1" max="100" value="80" step="1">
                                <div class="bpm-display" id="subAttackDisplay">80ms</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Attack</div>
                        </div>
                        
                        <div class="header-section bpm-section">
                            <div class="bpm-control">
                                <input type="range" id="subSaturationSlider" class="bpm-slider" min="0" max="100" value="5" step="1">
                                <div class="bpm-display" id="subSaturationDisplay">5%</div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Saturation</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chord-sequence-display" style="flex: 1 1 100%;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                    <div style="display: flex; gap: 6px;">
                        <button id="prevBtn">←</button>
                        <button id="nextChordBtn">→</button>
                        <button id="toggleBtn">Start</button>
                        <button id="editBtn">Edit</button>
                    </div>
                </div>
                <div class="chord-sequence-list" id="chordSequenceList"></div>
            </div>
            
            <div class="header-section">
                <div class="debug-display">
                    <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 0;">
                        <div class="debug-section">
                            <div class="debug-section-label">Bass:</div>
                            <div class="debug-notes" id="debugBassNotes"><span style="color: #666;">-</span></div>
                        </div>
                        <div class="debug-section">
                            <div class="debug-section-label">High:</div>
                            <div class="debug-notes" id="debugHighNotes"><span style="color: #666;">-</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #4CAF50; font-size: 14px; margin: 0 0 8px 0; font-weight: 500; letter-spacing: -0.01em;">Water Synth Grid</h2>
                <div class="grid" id="waterGrid"></div>
            </div>
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #FF9800; font-size: 14px; margin: 0 0 8px 0; font-weight: 500; letter-spacing: -0.01em;">Plucky Synth Grid</h2>
                <div class="grid" id="pluckyGrid"></div>
            </div>
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #9C27B0; font-size: 14px; margin: 0 0 8px 0; font-weight: 500; letter-spacing: -0.01em;">Sub Synth Grid</h2>
                <div class="grid" id="subGrid"></div>
            </div>
        </div>
    </div>
    
    <script>
        // ========== CHORD PARSER ==========
        // Use values from chord-intervals-config.js (already loaded)
        // Create local references to avoid redeclaration errors
        const NOTE_TO_INDEX_REF = window.NOTE_TO_INDEX || {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8,
            'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };
        
        const CHORD_INTERVALS_REF = window.CHORD_INTERVALS || {
            'major-triad': [-24, -12, -5, 0, 4, 7],
            'minor-triad': [-24, -12, -5, 0, 3, 7],
            'dominant-7th': [-24, -12, -5, 0, 4, 7, 10],
            'minor-7th': [-24, -12, -5, 0, 3, 7, 10],
            'major-7th': [-24, -12, -5, 0, 4, 7, 11],
            'diminished-7th': [-24, -12, -6, 0, 3, 6, 9],
            'diminished-triad': [-24, -12, -6, 0, 3, 6],
            'augmented-triad': [-24, -12, -4, 0, 4, 8],
            'major-6th': [-24, -12, -5, 0, 4, 7, 9],
            'minor-6th': [-24, -12, -5, 0, 3, 7, 9],
            'dominant-9th': [-24, -12, -5, 0, 4, 7, 10, 14],
            'major-9th': [-24, -12, -5, 0, 4, 7, 11, 14],
            'minor-9th': [-24, -12, -5, 0, 3, 7, 10, 14],
            'add9': [-24, -12, -5, 0, 4, 7, 14],
            'add11': [-24, -12, -5, 0, 4, 7, 17],
            'add13': [-24, -12, -5, 0, 4, 7, 21],
            '7sharp11': [-24, -12, -5, 0, 4, 7, 10, 18],
            '9sharp11': [-24, -12, -5, 0, 4, 7, 10, 14, 18],
            'sus2': [-24, -12, -5, 0, 2, 7],
            'sus4': [-24, -12, -5, 0, 5, 7]
        };
        
        function parseChord(input) {
            const trimmed = input.trim();
            if (!trimmed) return null;
            
            const match = trimmed.match(/^([A-Ga-g])([#b]?)(.*)$/i);
            if (!match) return null;
            
            const rootLetter = match[1].toUpperCase();
            const accidental = match[2] || '';
            const suffix = match[3].toLowerCase();
            const noteName = rootLetter + accidental;
            
            if (!NOTE_TO_INDEX_REF.hasOwnProperty(noteName)) return null;
            
            let chordType = 'major-triad';
            let processedSuffix = suffix;
            
            const slashIndex = suffix.indexOf('/');
            if (slashIndex !== -1) {
                processedSuffix = suffix.substring(0, slashIndex);
            }
            
            if (processedSuffix === 'm' || processedSuffix === 'min' || processedSuffix === '-') {
                chordType = 'minor-triad';
            } else if (processedSuffix === '7' || processedSuffix === 'dom' || processedSuffix === 'dom7') {
                chordType = 'dominant-7th';
            } else if (processedSuffix === 'm7' || processedSuffix === 'min7') {
                chordType = 'minor-7th';
            } else if (processedSuffix.includes('dim')) {
                chordType = processedSuffix.includes('7') ? 'diminished-7th' : 'diminished-triad';
            } else if (processedSuffix.includes('aug') || processedSuffix === '+') {
                chordType = 'augmented-triad';
            } else if (processedSuffix === 'maj9' || processedSuffix === 'major9' || processedSuffix === 'M9') {
                chordType = 'major-9th';
            } else if (processedSuffix === 'm9' || processedSuffix === 'min9' || processedSuffix === '-9') {
                chordType = 'minor-9th';
            } else if (processedSuffix === '9') {
                chordType = 'dominant-9th';
            } else if (processedSuffix === 'maj7' || processedSuffix === 'major7' || processedSuffix === 'M7' || processedSuffix === 'ma7') {
                chordType = 'major-7th';
            } else if (processedSuffix === '6') {
                chordType = 'major-6th';
            } else if (processedSuffix === 'm6' || processedSuffix === 'min6' || processedSuffix === '-6') {
                chordType = 'minor-6th';
            } else if (processedSuffix.includes('add9')) {
                chordType = 'add9';
            } else if (processedSuffix.includes('add11')) {
                chordType = 'add11';
            } else if (processedSuffix.includes('add13')) {
                chordType = 'add13';
            } else if (processedSuffix.includes('7#11') || processedSuffix.includes('7(#11)') || processedSuffix.includes('7+11')) {
                chordType = '7sharp11';
            } else if (processedSuffix.includes('9#11') || processedSuffix.includes('9(#11)') || processedSuffix.includes('9+11')) {
                chordType = '9sharp11';
            } else if (processedSuffix.includes('sus2') || processedSuffix === 'sus2') {
                chordType = 'sus2';
            } else if (processedSuffix.includes('sus4') || processedSuffix === 'sus' || processedSuffix === 'sus4') {
                chordType = 'sus4';
            }
            
            return { rootNote: noteName, chordType, original: trimmed };
        }
        
        function parseChordSequence(input) {
            return input.split(',').map(s => s.trim()).filter(s => s)
                .map(str => parseChord(str)).filter(c => c !== null);
        }
        
        function chordToMIDINotes(chord, rootMIDI = 64) {
            if (!chord) return { bass: [], high: [] };
            
            const rootIndex = NOTE_TO_INDEX_REF[chord.rootNote];
            if (rootIndex === undefined) return { bass: [], high: [] };
            
            // Calculate root MIDI note (C4 = 60, so we adjust based on root)
            const C4_MIDI = 60;
            const rootMIDINote = C4_MIDI + rootIndex;
            
            const intervals = CHORD_INTERVALS_REF[chord.chordType];
            if (!intervals) return { bass: [], high: [] };
            
            // Convert intervals to MIDI notes
            const midiNotes = intervals.map(interval => rootMIDINote + interval);
            
            // Split into bass (lowest 3) and high (highest 3)
            const sorted = [...midiNotes].sort((a, b) => a - b);
            const bass = sorted.slice(0, 3);
            const high = sorted.slice(-3);
            
            return { bass, high };
        }
        
        // ========== STATE ==========
        let chordSequence = [];
        let currentChordIndex = 0;
        let nextChordIndex = 1; // Index of chord that will play in the next cycle
        let waterSynth = null;
        let pluckySynth = null;
        let isPlaying = false;
        
        // Water synth state
        let waterBassInterval = null;
        let waterHighInterval = null;
        let waterCurrentBassDuration = null;
        let waterCurrentHighDuration = null;
        let waterPendingBassDuration = null;
        let waterPendingHighDuration = null;
        let waterPendingCellRow = null;
        let waterPendingCellCol = null;
        let waterProfile = 'none';
        let waterCreativeCycleCounter = 0;
        
        // Plucky synth state
        let pluckyBassInterval = null;
        let pluckyHighInterval = null;
        let pluckyCurrentBassDuration = null;
        let pluckyCurrentHighDuration = null;
        let pluckyPendingBassDuration = null;
        let pluckyPendingHighDuration = null;
        let pluckyPendingCellRow = null;
        let pluckyPendingCellCol = null;
        let pluckyProfile = 'none';
        let pluckyCreativeCycleCounter = 0;
        
        // Sub synth state
        let subSynth = null;
        let subBassInterval = null;
        let subOctaveInterval = null;
        let subCurrentBassDuration = null;
        let subCurrentOctaveDuration = null;
        let subPendingBassDuration = null;
        let subPendingOctaveDuration = null;
        let subPendingCellRow = null;
        let subPendingCellCol = null;
        let subProfile = 'none';
        let subCreativeCycleCounter = 0;
        
        // Shared state
        let cycleInterval = null;
        let transitionUpdateInterval = null;
        let currentBPM = 120;
        let waterVolumeModulation = 'triangle';
        let pluckyVolumeModulation = 'triangle';
        let subVolumeModulation = 'triangle';
        let masterCycleStartTime = null;
        let masterCycleNumber = 0;
        let pendingBPM = null;
        let masterVolume = null;
        let masterLimiter = null;
        // Water synth parameters
        let waterAttackTime = 0.02; // in seconds (20ms default)
        let waterHarmonic2Gain = 0.3; // 30% default
        let waterHarmonic3Gain = 0.2; // 20% default (fixed, not randomized)
        let waterHarmonic4Gain = 0.1; // 10% default (fixed, not randomized)
        let waterReverbGain = 0.77; // 77% default
        
        // Plucky synth parameters (attack only, no harmonics)
        let pluckyAttackTime = 0.066; // in seconds (66ms default)
        let pluckyReverbGain = 0.77; // 77% default
        
        // Sub synth parameters
        let subAttackTime = 0.08; // in seconds (80ms default)
        let subReverbGain = 0.12; // 12% default
        let subSaturationAmount = 0.05; // 5% default
        let subVolumeGain = 0.22; // 22% default
        
        // Water synth volume
        let waterVolumeGain = 0.5; // 50% default
        
        // Plucky synth volume
        let pluckyVolumeGain = 0.5; // 50% default
        
        // Legacy variables for compatibility (used by water synth)
        let attackTime = 0.02;
        let harmonic2Gain = 0.3;
        let harmonic3Gain = 0.2;
        let harmonic4Gain = 0.1;
        
        // Transition tracking for smooth parameter changes (water synth only)
        let targetAttackTime = 0.02;
        let targetHarmonic2Gain = 0.3;
        let attackTransitionStartTime = null;
        let attackTransitionStartValue = 0.02;
        let attackTransitionDuration = 0;
        let harmonic2TransitionStartTime = null;
        let harmonic2TransitionStartValue = 0.3;
        let harmonic2TransitionDuration = 0;
        
        // Transition tracking for plucky reverb
        let targetPluckyReverbGain = 0.77;
        let pluckyReverbTransitionStartTime = null;
        let pluckyReverbTransitionStartValue = 0.77;
        let pluckyReverbTransitionDuration = 0;
        
        // Transition tracking for water reverb
        let targetWaterReverbGain = 0.77;
        let waterReverbTransitionStartTime = null;
        let waterReverbTransitionStartValue = 0.77;
        let waterReverbTransitionDuration = 0;
        
        // Transition tracking for sub reverb
        let targetSubReverbGain = 0.12;
        let subReverbTransitionStartTime = null;
        let subReverbTransitionStartValue = 0.12;
        let subReverbTransitionDuration = 0;
        
        const DURATION_MULTIPLIERS = [null, 240, 120, 60, 40, 30, 20];
        
        // ========== WATER SYNTH ==========
        class WaterSynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied before reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 150,
                    Q: 0.7
                });
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.5); // Output volume control before reverb (default 50%)
                this.dryGain = new Tone.Gain(0.08);
                this.reverbGain = new Tone.Gain(0.77);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Volume modulation affects both dry and reverb paths BEFORE reverb
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.dryGain);
                this.outputVolume.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.oscillator3) voice.oscillator3.dispose();
                        if (voice.oscillator4) voice.oscillator4.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.envelope3) voice.envelope3.dispose();
                        if (voice.envelope4) voice.envelope4.dispose();
                        if (voice.noise) voice.noise.dispose();
                        if (voice.noiseEnv) voice.noiseEnv.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createWaterVoice(frequency, noteDuration, pitchDrop = 0.02, noiseAmount = 0.03, isHighNote = false) {
                const now = Tone.now();
                
                // Random delay 0-20ms
                const startDelay = Math.random() * 0.02;
                const startTime = now + startDelay;
                
                // Random decay reduction 0-40ms
                const decayReduction = Math.random() * 0.04;
                
                const finalPitchDrop = frequency * (pitchDrop + Math.random() * 0.02);
                const finalNoiseAmount = noiseAmount * (0.8 + Math.random() * 0.4);
                
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency + finalPitchDrop
                });
                osc.frequency.exponentialRampTo(frequency, 0.08);
                
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 2) + (finalPitchDrop * 2)
                });
                osc2.frequency.exponentialRampTo(frequency * 2, 0.08);
                
                const osc3 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 3) + (finalPitchDrop * 3)
                });
                osc3.frequency.exponentialRampTo(frequency * 3, 0.08);
                
                const osc4 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (frequency * 4) + (finalPitchDrop * 4)
                });
                osc4.frequency.exponentialRampTo(frequency * 4, 0.08);
                
                // Calculate release time with decay reduction
                const baseRelease = Math.min(0.3, noteDuration * 0.3);
                const reducedRelease = Math.max(0.01, baseRelease - decayReduction);
                
                // Random sustain variation: -0 to -2dB (linear: 1.0 to 0.794)
                const sustainVariation = Math.random() * (1.0 - 0.794) + 0.794; // Random between 0.794 and 1.0
                const sustainVariation2 = Math.random() * (1.0 - 0.794) + 0.794;
                const sustainVariation3 = Math.random() * (1.0 - 0.794) + 0.794;
                const sustainVariation4 = Math.random() * (1.0 - 0.794) + 0.794;
                
                // Use water-specific attack time
                const currentAttack = typeof waterAttackTime === 'number' ? waterAttackTime : 0.02;
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.35 * sustainVariation,
                    release: reducedRelease
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.25 * sustainVariation2,
                    release: reducedRelease
                });
                
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.15 * sustainVariation3,
                    release: reducedRelease
                });
                
                const env4 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: 0.01,
                    sustain: 0.1 * sustainVariation4,
                    release: reducedRelease
                });
                
                // Use water-specific harmonic gains
                const currentHarmonic2 = typeof waterHarmonic2Gain === 'number' ? waterHarmonic2Gain : 0.3;
                const currentHarmonic3 = typeof waterHarmonic3Gain === 'number' ? waterHarmonic3Gain : 0.2;
                const currentHarmonic4 = typeof waterHarmonic4Gain === 'number' ? waterHarmonic4Gain : 0.1;
                
                const harmonicGain2 = new Tone.Gain(currentHarmonic2);
                const harmonicGain3 = new Tone.Gain(currentHarmonic3);
                const harmonicGain4 = new Tone.Gain(currentHarmonic4);
                
                const noise = new Tone.Noise({
                    type: 'white',
                    volume: -20
                });
                
                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,
                    sustain: 0,
                    release: 0
                });
                
                const noiseGain = new Tone.Gain();
                noiseGain.gain.value = finalNoiseAmount * 0.5;
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                // Apply -12 dB reduction for high notes (linear gain ≈ 0.251)
                const highNoteVolumeReduction = isHighNote ? 0.251 : 1.0;
                const volumeGain = new Tone.Gain(highNoteVolumeReduction);
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(harmonicGain2);
                harmonicGain2.connect(volumeGain);
                osc3.connect(env3);
                env3.connect(harmonicGain3);
                harmonicGain3.connect(volumeGain);
                osc4.connect(env4);
                env4.connect(harmonicGain4);
                harmonicGain4.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);
                
                osc.start(startTime);
                osc2.start(startTime);
                osc3.start(startTime);
                osc4.start(startTime);
                noise.start(startTime);
                env.triggerAttack(startTime);
                env2.triggerAttack(startTime);
                env3.triggerAttack(startTime);
                env4.triggerAttack(startTime);
                noiseEnv.triggerAttack(startTime);
                
                noise.stop(startTime + 0.15);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                osc3.stop(stopTime);
                osc4.stop(stopTime);
                
                const releaseTime = Math.max(startTime + 0.01, stopTime - reducedRelease);
                env.triggerRelease(releaseTime);
                env2.triggerRelease(releaseTime);
                env3.triggerRelease(releaseTime);
                env4.triggerRelease(releaseTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    oscillator3: osc3,
                    oscillator4: osc4,
                    envelope: env,
                    envelope2: env2,
                    envelope3: env3,
                    envelope4: env4,
                    noise: noise,
                    noiseEnv: noiseEnv,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            env3.triggerRelease();
                            env4.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                            osc3.stop('+0.1');
                            osc4.stop('+0.1');
                            noise.stop();
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            osc3.dispose();
                            osc4.dispose();
                            env.dispose();
                            env2.dispose();
                            env3.dispose();
                            env4.dispose();
                            noise.dispose();
                            noiseEnv.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== PLUCKY SYNTH ==========
        class PluckySynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied before reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 150,
                    Q: 0.7
                });
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.5); // Output volume control before reverb (default 50%)
                this.dryGain = new Tone.Gain(0.08);
                this.reverbGain = new Tone.Gain(0.77);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Volume modulation affects both dry and reverb paths BEFORE reverb
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.dryGain);
                this.outputVolume.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.filter) voice.filter.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createPluckyVoice(frequency, noteDuration, isHighNote = false) {
                const now = Tone.now();
                
                // Random delay 0-20ms
                const startDelay = Math.random() * 0.02;
                const startTime = now + startDelay;
                
                // Very short attack for plucky sound
                // Use plucky-specific attack time
                const currentAttack = typeof pluckyAttackTime === 'number' ? Math.min(pluckyAttackTime, 0.005) : 0.005;
                
                // Create plucky sound with sharp attack and quick decay
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: frequency
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: frequency * 2 // Octave for richness
                });
                
                // Sharp pluck envelope: very fast attack, quick decay
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.1, noteDuration * 0.3),
                    sustain: 0.1,
                    release: Math.min(0.2, noteDuration * 0.4)
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.08, noteDuration * 0.25),
                    sustain: 0.05,
                    release: Math.min(0.15, noteDuration * 0.35)
                });
                
                // Lowpass filter for warmth
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: frequency * 6,
                    Q: 1.5
                });
                
                // Apply -12 dB reduction for high notes
                const highNoteVolumeReduction = isHighNote ? 0.251 : 1.0;
                const volumeGain = new Tone.Gain(highNoteVolumeReduction);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                
                // Routing
                osc.connect(env);
                env.connect(filter);
                osc2.connect(env2);
                env2.connect(filter);
                filter.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                // Start oscillators and trigger envelopes
                osc.start(startTime);
                osc2.start(startTime);
                env.triggerAttackRelease(noteDuration, startTime);
                env2.triggerAttackRelease(noteDuration * 0.9, startTime);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            env.dispose();
                            env2.dispose();
                            filter.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== SUB SYNTH ==========
        class SubSynthTone {
            constructor(masterVolumeNode) {
                this.masterVolumeNode = masterVolumeNode;
                this.activeVoices = [];
                
                // Volume modulation node (applied before reverb)
                this.volumeModulation = new Tone.Volume(0);
                
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 1.0
                });
                
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                });
                
                // Lowpass filter for sub-bass character
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 200,
                    Q: 0.7
                });
                
                // High pass filter for reverb to reduce low-end mud
                this.reverbHighPass = new Tone.Filter({
                    type: 'highpass',
                    frequency: 150,
                    Q: 0.7
                });
                
                // Saturation for warmth and character
                this.saturation = new Tone.Distortion(0);
                
                this.masterGain = new Tone.Gain(1.0);
                this.outputVolume = new Tone.Gain(0.22); // Output volume control before reverb (default 22%)
                this.dryGain = new Tone.Gain(0.1);
                this.reverbGain = new Tone.Gain(0.12);
                
                // Audio chain: masterGain -> volumeModulation -> outputVolume -> saturation -> (dryGain + reverbGain) -> reverb/eq -> compressor -> masterVolume
                // Output volume is independent control before reverb chain
                this.masterGain.connect(this.volumeModulation);
                this.volumeModulation.connect(this.outputVolume);
                this.outputVolume.connect(this.saturation);
                this.saturation.connect(this.dryGain);
                this.saturation.connect(this.reverbGain);
                
                // Dry path: dryGain -> eq -> compressor
                this.dryGain.connect(this.eq);
                this.eq.connect(this.compressor);
                
                // Reverb path: reverbGain -> reverb -> reverbHighPass -> compressor
                this.reverbGain.connect(this.reverb);
                this.reverb.connect(this.reverbHighPass);
                this.reverbHighPass.connect(this.compressor);
                
                if (this.masterVolumeNode) {
                    this.compressor.connect(this.masterVolumeNode);
                } else {
                    this.compressor.toDestination();
                }
                
                this.reverb.generate().catch(console.error);
            }
            
            cleanupVoices() {
                this.activeVoices.forEach(voice => {
                    try {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                        if (voice.oscillator) voice.oscillator.dispose();
                        if (voice.oscillator2) voice.oscillator2.dispose();
                        if (voice.envelope) voice.envelope.dispose();
                        if (voice.envelope2) voice.envelope2.dispose();
                        if (voice.filter) voice.filter.dispose();
                        if (voice.pan) voice.pan.dispose();
                        if (voice.volumeGain) voice.volumeGain.dispose();
                    } catch (e) {
                        console.warn('Error cleaning up voice:', e);
                    }
                });
                this.activeVoices = [];
            }
            
            createSubVoice(frequency, noteDuration) {
                const now = Tone.now();
                
                // Random delay 0-20ms
                const startDelay = Math.random() * 0.02;
                const startTime = now + startDelay;
                
                // Use sub-specific attack time
                const currentAttack = typeof subAttackTime === 'number' ? subAttackTime : 0.08;
                
                // Sub-bass: sine wave for pure low end
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency
                });
                
                // Add a subtle second harmonic (octave) for warmth
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: frequency * 2
                });
                
                // Envelope with longer sustain for bass
                const env = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.15, noteDuration * 0.2),
                    sustain: 0.6,
                    release: Math.min(0.3, noteDuration * 0.5)
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: currentAttack,
                    decay: Math.min(0.12, noteDuration * 0.18),
                    sustain: 0.3,
                    release: Math.min(0.25, noteDuration * 0.45)
                });
                
                // Lowpass filter for sub-bass
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: frequency * 3,
                    Q: 1.0
                });
                
                const volumeGain = new Tone.Gain(1.0);
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.1); // Less panning for bass
                
                // Routing
                osc.connect(env);
                env.connect(filter);
                osc2.connect(env2);
                env2.connect(filter);
                filter.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.masterGain);
                
                // Start oscillators and trigger envelopes
                osc.start(startTime);
                osc2.start(startTime);
                env.triggerAttackRelease(noteDuration, startTime);
                env2.triggerAttackRelease(noteDuration * 0.95, startTime);
                
                const stopTime = startTime + noteDuration;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                const voice = {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stopTime: stopTime,
                    cycleNumber: masterCycleNumber, // Track which cycle this voice was created in
                    stop: () => {
                        try {
                            env.triggerRelease();
                            env2.triggerRelease();
                            osc.stop('+0.1');
                            osc2.stop('+0.1');
                        } catch (e) {
                            console.warn('Error stopping voice:', e);
                        }
                    },
                    dispose: () => {
                        try {
                            osc.dispose();
                            osc2.dispose();
                            env.dispose();
                            env2.dispose();
                            filter.dispose();
                            pan.dispose();
                            volumeGain.dispose();
                        } catch (e) {
                            console.warn('Error disposing voice:', e);
                        }
                    }
                };
                
                this.activeVoices.push(voice);
                
                setTimeout(() => {
                    const index = this.activeVoices.indexOf(voice);
                    if (index > -1) {
                        this.activeVoices.splice(index, 1);
                        voice.dispose();
                    }
                }, (noteDuration + 0.5) * 1000);
                
                return voice;
            }
        }
        
        // ========== CPU/RAM MANAGEMENT ==========
        // Cleanup function to remove voices older than 4 cycles
        function cleanupOldVoices() {
            if (!isPlaying || masterCycleNumber < 4) return;
            
            const cyclesToKeep = 4;
            const oldestCycleToKeep = masterCycleNumber - cyclesToKeep;
            
            [waterSynth, pluckySynth, subSynth].forEach(synth => {
                if (synth && synth.activeVoices) {
                    const voicesToRemove = synth.activeVoices.filter(voice => {
                        // Remove voices older than 4 cycles
                        return voice.cycleNumber !== undefined && voice.cycleNumber < oldestCycleToKeep;
                    });
                    
                    voicesToRemove.forEach(voice => {
                        try {
                            const index = synth.activeVoices.indexOf(voice);
                            if (index > -1) {
                                synth.activeVoices.splice(index, 1);
                                voice.stop();
                                voice.dispose();
                            }
                        } catch (e) {
                            console.warn('Error cleaning up old voice:', e);
                        }
                    });
                }
            });
        }
        
        // ========== AUDIO FUNCTIONS ==========
        function initAudio() {
            return new Promise((resolve, reject) => {
                if (!waterSynth || !pluckySynth || !subSynth) {
                    Tone.start().then(() => {
                        if (!masterVolume) {
                            masterVolume = new Tone.Volume(0);
                        }
                        if (!masterLimiter) {
                            // Limiter to prevent clipping at final master output
                            masterLimiter = new Tone.Limiter(-0.1); // -0.1 dB ceiling to prevent clipping
                            // Disconnect masterVolume from destination if already connected
                            try {
                                masterVolume.disconnect();
                            } catch (e) {
                                // Already disconnected or never connected
                            }
                            masterVolume.connect(masterLimiter);
                            masterLimiter.toDestination();
                        }
                        if (!waterSynth) {
                            waterSynth = new WaterSynthTone(masterVolume);
                            // Set initial reverb gain
                        if (waterSynth.reverbGain) {
                            waterSynth.reverbGain.gain.value = waterReverbGain;
                        }
                        if (waterSynth.outputVolume) {
                            waterSynth.outputVolume.gain.value = waterVolumeGain;
                        }
                    }
                    if (!pluckySynth) {
                        pluckySynth = new PluckySynthTone(masterVolume);
                        // Set initial reverb gain
                        if (pluckySynth.reverbGain) {
                            pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                        }
                        if (pluckySynth.outputVolume) {
                            pluckySynth.outputVolume.gain.value = pluckyVolumeGain;
                        }
                    }
                    if (!subSynth) {
                        subSynth = new SubSynthTone(masterVolume);
                        // Set initial reverb gain and saturation
                        if (subSynth.reverbGain) {
                            subSynth.reverbGain.gain.value = subReverbGain;
                        }
                        if (subSynth.saturation) {
                            subSynth.saturation.distortion = subSaturationAmount;
                        }
                        if (subSynth.outputVolume) {
                            subSynth.outputVolume.gain.value = subVolumeGain;
                        }
                    }
                        console.log('Audio initialized with all three synths');
                        resolve();
                    }).catch(reject);
                } else {
                    resolve();
                }
            });
        }
        
        function setupVolumeModulation(synth, cycleStartTime, cycleDuration, modulation) {
            if (!synth || !synth.volumeModulation || !isFinite(cycleDuration) || cycleDuration <= 0) return;
            
            const minVolume = -20;
            const maxVolume = 0;
            const now = Tone.now();
            
            // Get current volume value before canceling
            const currentVolume = synth.volumeModulation.volume.value;
            
            // Cancel scheduled values slightly before the cycle start to allow smooth transition
            const cancelTime = Math.max(now, cycleStartTime - 0.01);
            synth.volumeModulation.volume.cancelScheduledValues(cancelTime);
            
            // Smooth transition from current volume to cycle start volume
            const transitionTime = Math.max(now + 0.001, cycleStartTime);
            
            if (modulation === 'triangle') {
                const peakTime = cycleStartTime + cycleDuration * 0.5;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, peakTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, endTime);
            } else if (modulation === 'ascend') {
                const peakTime = cycleStartTime + cycleDuration * 0.9;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, peakTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, endTime);
            } else if (modulation === 'descend') {
                const quietTime = cycleStartTime + cycleDuration * 0.9;
                const endTime = cycleStartTime + cycleDuration;
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, transitionTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(minVolume, quietTime);
                synth.volumeModulation.volume.linearRampToValueAtTime(maxVolume, endTime);
            } else {
                synth.volumeModulation.volume.linearRampToValueAtTime((minVolume + maxVolume) / 2, transitionTime);
            }
        }
        
        function resyncToMasterCycle() {
            if (!isPlaying || masterCycleStartTime === null) return;
            
            const masterCycleDuration240 = 240 / currentBPM;
            const exactCycleTime = masterCycleStartTime + (masterCycleNumber * masterCycleDuration240);
            
            // Setup volume modulation for each synth separately
            if (waterSynth) {
                setupVolumeModulation(waterSynth, exactCycleTime, masterCycleDuration240, waterVolumeModulation);
            }
            if (pluckySynth) {
                setupVolumeModulation(pluckySynth, exactCycleTime, masterCycleDuration240, pluckyVolumeModulation);
            }
            if (subSynth) {
                setupVolumeModulation(subSynth, exactCycleTime, masterCycleDuration240, subVolumeModulation);
            }
        }
        
        function checkAndApplyPendingChanges() {
            let changed = false;
            
            // Handle BPM changes
            if (pendingBPM !== null) {
                currentBPM = pendingBPM;
                pendingBPM = null;
                changed = true;
            }
            
            // Handle water synth pending changes
            if (waterPendingBassDuration !== null || waterPendingHighDuration !== null) {
                const newBass = waterPendingBassDuration !== null ? waterPendingBassDuration : waterCurrentBassDuration;
                const newHigh = waterPendingHighDuration !== null ? waterPendingHighDuration : waterCurrentHighDuration;
                
                if (waterPendingCellRow !== null && waterPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#waterGrid .grid-cell[data-row="${waterPendingCellRow}"][data-col="${waterPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#waterGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                    }
                }
                
                waterCurrentBassDuration = newBass;
                waterCurrentHighDuration = newHigh;
                waterPendingBassDuration = null;
                waterPendingHighDuration = null;
                waterPendingCellRow = null;
                waterPendingCellCol = null;
                changed = true;
            }
            
            // Handle plucky synth pending changes
            if (pluckyPendingBassDuration !== null || pluckyPendingHighDuration !== null) {
                const newBass = pluckyPendingBassDuration !== null ? pluckyPendingBassDuration : pluckyCurrentBassDuration;
                const newHigh = pluckyPendingHighDuration !== null ? pluckyPendingHighDuration : pluckyCurrentHighDuration;
                
                if (pluckyPendingCellRow !== null && pluckyPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#pluckyGrid .grid-cell[data-row="${pluckyPendingCellRow}"][data-col="${pluckyPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#pluckyGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                    }
                }
                
                pluckyCurrentBassDuration = newBass;
                pluckyCurrentHighDuration = newHigh;
                pluckyPendingBassDuration = null;
                pluckyPendingHighDuration = null;
                pluckyPendingCellRow = null;
                pluckyPendingCellCol = null;
                changed = true;
            }
            
            // Handle sub synth pending changes
            if (subPendingBassDuration !== null || subPendingOctaveDuration !== null) {
                const newBass = subPendingBassDuration !== null ? subPendingBassDuration : subCurrentBassDuration;
                const newOctave = subPendingOctaveDuration !== null ? subPendingOctaveDuration : subCurrentOctaveDuration;
                
                if (subPendingCellRow !== null && subPendingCellCol !== null) {
                    const pendingCell = document.querySelector(`#subGrid .grid-cell[data-row="${subPendingCellRow}"][data-col="${subPendingCellCol}"]`);
                    if (pendingCell) {
                        document.querySelectorAll('#subGrid .grid-cell.active').forEach(c => c.classList.remove('active'));
                        pendingCell.classList.remove('pending');
                        pendingCell.classList.add('active');
                    }
                }
                
                subCurrentBassDuration = newBass;
                subCurrentOctaveDuration = newOctave;
                subPendingBassDuration = null;
                subPendingOctaveDuration = null;
                subPendingCellRow = null;
                subPendingCellCol = null;
                changed = true;
            }
            
            // Restart if needed
            if (changed && isPlaying) {
                stopPlaying();
                startPlaying();
                return true;
            }
            
            return false;
        }
        
        function midiToFrequency(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        function midiToNoteName(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            return `${noteNames[noteIndex]}${octave}`;
        }
        
        function updateDebugDisplay(bassNotes, highNotes) {
            const bassContainer = document.getElementById('debugBassNotes');
            const highContainer = document.getElementById('debugHighNotes');
            
            if (!bassContainer || !highContainer) return;
            
            // Update bass notes
            if (bassNotes && bassNotes.length > 0) {
                bassContainer.innerHTML = '';
                bassNotes.forEach(midiNote => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'debug-note-item bass';
                    noteItem.textContent = `${midiToNoteName(midiNote)}`;
                    bassContainer.appendChild(noteItem);
                });
            } else {
                bassContainer.innerHTML = '<span style="color: #666;">-</span>';
            }
            
            // Update high notes
            if (highNotes && highNotes.length > 0) {
                highContainer.innerHTML = '';
                highNotes.forEach(midiNote => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'debug-note-item high';
                    noteItem.textContent = `${midiToNoteName(midiNote)}`;
                    highContainer.appendChild(noteItem);
                });
            } else {
                highContainer.innerHTML = '<span style="color: #666;">-</span>';
            }
        }
        
        function playBassLayer(notes, noteDuration, cycleDuration, synth, synthType) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validNoteDuration = isFinite(noteDuration) && noteDuration > 0 ? noteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            notes.forEach((midiNote) => {
                const frequency = midiToFrequency(midiNote);
                if (synthType === 'water') {
                    synth.createWaterVoice(frequency, validNoteDuration, 0.02, 0.03, false);
                } else if (synthType === 'plucky') {
                    synth.createPluckyVoice(frequency, validNoteDuration, false);
                } else if (synthType === 'sub') {
                    synth.createSubVoice(frequency, validNoteDuration);
                }
            });
        }
        
        function playHighLayer(notes, noteDuration, cycleDuration, synth, synthType, profile, currentHighDuration) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validNoteDuration = isFinite(noteDuration) && noteDuration > 0 ? noteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            // Drunk/Creative/Lazy/Threat profile: Check for special variations first (120/bpm or 60/bpm)
            if ((profile === 'drunk' || profile === 'creative' || profile === 'lazy' || profile === 'threat') && (currentHighDuration === 120 || currentHighDuration === 60) && Math.random() < 0.34) {
                // Another 34% chance to play special variations
                if (Math.random() < 0.34) {
                    const currentBassNotes = getCurrentChordNotes().bass;
                    
                    // Randomly choose: 1/3rd duration three times OR half duration twice
                    if (Math.random() < 0.5) {
                        // Play at 1/3rd duration three times
                        const thirdNoteDuration = validNoteDuration / 3;
                        
                        // Play first third (each note individually decides to skip)
                        notes.forEach((midiNote) => {
                            if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                const frequency = midiToFrequency(midiNote);
                                if (synthType === 'water') {
                                    synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true);
                                } else if (synthType === 'plucky') {
                                    synth.createPluckyVoice(frequency, thirdNoteDuration, true);
                                }
                            }
                        });
                        
                        // Play second third after delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, thirdNoteDuration, true);
                                        }
                                    }
                                });
                            }
                        }, thirdNoteDuration * 1000);
                        
                        // Play third third after another delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, thirdNoteDuration, 0.02, 0.03, true);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, thirdNoteDuration, true);
                                        }
                                    }
                                });
                            }
                        }, thirdNoteDuration * 2000);
                    } else {
                        // Play at half duration twice
                        const halfNoteDuration = validNoteDuration / 2;
                        
                        // Play first half (each note individually decides to skip)
                        notes.forEach((midiNote) => {
                            if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                const frequency = midiToFrequency(midiNote);
                                if (synthType === 'water') {
                                    synth.createWaterVoice(frequency, halfNoteDuration, 0.02, 0.03, true);
                                } else if (synthType === 'plucky') {
                                    synth.createPluckyVoice(frequency, halfNoteDuration, true);
                                }
                            }
                        });
                        
                        // Play second half after a delay
                        setTimeout(() => {
                            if (isPlaying) {
                                notes.forEach((midiNote) => {
                                    if (profile !== 'drunk' && profile !== 'creative' && profile !== 'lazy' && profile !== 'threat' || Math.random() >= 0.34) {
                                        const frequency = midiToFrequency(midiNote);
                                        if (synthType === 'water') {
                                            synth.createWaterVoice(frequency, halfNoteDuration, 0.02, 0.03, true);
                                        } else if (synthType === 'plucky') {
                                            synth.createPluckyVoice(frequency, halfNoteDuration, true);
                                        }
                                    }
                                });
                            }
                        }, halfNoteDuration * 1000);
                    }
                    
                    return;
                }
            }
            
            // Normal playback: each note individually decides whether to skip (34% chance)
            notes.forEach((midiNote) => {
                // Each note individually decides: 34% chance to skip in drunk/creative/lazy/threat profile
                if ((profile === 'drunk' || profile === 'creative' || profile === 'lazy' || profile === 'threat') && Math.random() < 0.34) {
                    // Skip this note
                    return;
                }
                
                // Play this note
                const frequency = midiToFrequency(midiNote);
                if (synthType === 'water') {
                    synth.createWaterVoice(frequency, validNoteDuration, 0.02, 0.03, true);
                } else if (synthType === 'plucky') {
                    synth.createPluckyVoice(frequency, validNoteDuration, true);
                }
            });
        }
        
        function updateParameterTransitions() {
            const now = Tone.now();
            
            // Update water attack transition
            if (attackTransitionStartTime !== null && attackTransitionDuration > 0) {
                const elapsed = now - attackTransitionStartTime;
                if (elapsed < attackTransitionDuration) {
                    const progress = elapsed / attackTransitionDuration;
                    // Linear interpolation
                    waterAttackTime = attackTransitionStartValue + (targetAttackTime - attackTransitionStartValue) * progress;
                    attackTime = waterAttackTime; // Legacy compatibility
                    
                    // Update slider and display in real-time
                    const attackSlider = document.getElementById('waterAttackSlider');
                    const attackDisplay = document.getElementById('waterAttackDisplay');
                    if (attackSlider && attackDisplay) {
                        const currentAttackMs = Math.round(waterAttackTime * 1000);
                        attackSlider.value = currentAttackMs;
                        attackDisplay.textContent = currentAttackMs + 'ms';
                    }
                } else {
                    // Transition complete
                    waterAttackTime = targetAttackTime;
                    attackTime = waterAttackTime; // Legacy compatibility
                    attackTransitionStartTime = null;
                    attackTransitionDuration = 0;
                    
                    // Final update to slider
                    const attackSlider = document.getElementById('waterAttackSlider');
                    const attackDisplay = document.getElementById('waterAttackDisplay');
                    if (attackSlider && attackDisplay) {
                        const finalAttackMs = Math.round(targetAttackTime * 1000);
                        attackSlider.value = finalAttackMs;
                        attackDisplay.textContent = finalAttackMs + 'ms';
                    }
                }
            }
            
            // Update water harmonic2 transition
            if (harmonic2TransitionStartTime !== null && harmonic2TransitionDuration > 0) {
                const elapsed = now - harmonic2TransitionStartTime;
                if (elapsed < harmonic2TransitionDuration) {
                    const progress = elapsed / harmonic2TransitionDuration;
                    // Linear interpolation
                    waterHarmonic2Gain = harmonic2TransitionStartValue + (targetHarmonic2Gain - harmonic2TransitionStartValue) * progress;
                    harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                    
                    // Update slider and display in real-time
                    const harmonic2Slider = document.getElementById('waterHarmonic2Slider');
                    const harmonic2Display = document.getElementById('waterHarmonic2Display');
                    if (harmonic2Slider && harmonic2Display) {
                        const currentHarmonic2Percent = Math.round(waterHarmonic2Gain * 100);
                        harmonic2Slider.value = currentHarmonic2Percent;
                        harmonic2Display.textContent = currentHarmonic2Percent + '%';
                    }
                } else {
                    // Transition complete
                    waterHarmonic2Gain = targetHarmonic2Gain;
                    harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                    harmonic2TransitionStartTime = null;
                    harmonic2TransitionDuration = 0;
                    
                    // Final update to slider
                    const harmonic2Slider = document.getElementById('waterHarmonic2Slider');
                    const harmonic2Display = document.getElementById('waterHarmonic2Display');
                    if (harmonic2Slider && harmonic2Display) {
                        const finalHarmonic2Percent = Math.round(targetHarmonic2Gain * 100);
                        harmonic2Slider.value = finalHarmonic2Percent;
                        harmonic2Display.textContent = finalHarmonic2Percent + '%';
                    }
                }
            }
            
            // Update plucky reverb transition
            if (pluckyReverbTransitionStartTime !== null && pluckyReverbTransitionDuration > 0) {
                const elapsed = now - pluckyReverbTransitionStartTime;
                if (elapsed < pluckyReverbTransitionDuration) {
                    const progress = elapsed / pluckyReverbTransitionDuration;
                    // Linear interpolation
                    pluckyReverbGain = pluckyReverbTransitionStartValue + (targetPluckyReverbGain - pluckyReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (pluckySynth && pluckySynth.reverbGain) {
                        pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const pluckyReverbSlider = document.getElementById('pluckyReverbSlider');
                    const pluckyReverbDisplay = document.getElementById('pluckyReverbDisplay');
                    if (pluckyReverbSlider && pluckyReverbDisplay) {
                        const currentReverbPercent = Math.round(pluckyReverbGain * 100);
                        pluckyReverbSlider.value = currentReverbPercent;
                        pluckyReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    pluckyReverbGain = targetPluckyReverbGain;
                    pluckyReverbTransitionStartTime = null;
                    pluckyReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (pluckySynth && pluckySynth.reverbGain) {
                        pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                    }
                    
                    // Final update to slider
                    const pluckyReverbSlider = document.getElementById('pluckyReverbSlider');
                    const pluckyReverbDisplay = document.getElementById('pluckyReverbDisplay');
                    if (pluckyReverbSlider && pluckyReverbDisplay) {
                        const finalReverbPercent = Math.round(targetPluckyReverbGain * 100);
                        pluckyReverbSlider.value = finalReverbPercent;
                        pluckyReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
            
            // Update water reverb transition
            if (waterReverbTransitionStartTime !== null && waterReverbTransitionDuration > 0) {
                const elapsed = now - waterReverbTransitionStartTime;
                if (elapsed < waterReverbTransitionDuration) {
                    const progress = elapsed / waterReverbTransitionDuration;
                    // Linear interpolation
                    waterReverbGain = waterReverbTransitionStartValue + (targetWaterReverbGain - waterReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (waterSynth && waterSynth.reverbGain) {
                        waterSynth.reverbGain.gain.value = waterReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const waterReverbSlider = document.getElementById('waterReverbSlider');
                    const waterReverbDisplay = document.getElementById('waterReverbDisplay');
                    if (waterReverbSlider && waterReverbDisplay) {
                        const currentReverbPercent = Math.round(waterReverbGain * 100);
                        waterReverbSlider.value = currentReverbPercent;
                        waterReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    waterReverbGain = targetWaterReverbGain;
                    waterReverbTransitionStartTime = null;
                    waterReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (waterSynth && waterSynth.reverbGain) {
                        waterSynth.reverbGain.gain.value = waterReverbGain;
                    }
                    
                    // Final update to slider
                    const waterReverbSlider = document.getElementById('waterReverbSlider');
                    const waterReverbDisplay = document.getElementById('waterReverbDisplay');
                    if (waterReverbSlider && waterReverbDisplay) {
                        const finalReverbPercent = Math.round(targetWaterReverbGain * 100);
                        waterReverbSlider.value = finalReverbPercent;
                        waterReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
            
            // Update sub reverb transition
            if (subReverbTransitionStartTime !== null && subReverbTransitionDuration > 0) {
                const elapsed = now - subReverbTransitionStartTime;
                if (elapsed < subReverbTransitionDuration) {
                    const progress = elapsed / subReverbTransitionDuration;
                    // Linear interpolation
                    subReverbGain = subReverbTransitionStartValue + (targetSubReverbGain - subReverbTransitionStartValue) * progress;
                    
                    // Apply to synth in real-time
                    if (subSynth && subSynth.reverbGain) {
                        subSynth.reverbGain.gain.value = subReverbGain;
                    }
                    
                    // Update slider and display in real-time
                    const subReverbSlider = document.getElementById('subReverbSlider');
                    const subReverbDisplay = document.getElementById('subReverbDisplay');
                    if (subReverbSlider && subReverbDisplay) {
                        const currentReverbPercent = Math.round(subReverbGain * 100);
                        subReverbSlider.value = currentReverbPercent;
                        subReverbDisplay.textContent = currentReverbPercent + '%';
                    }
                } else {
                    // Transition complete
                    subReverbGain = targetSubReverbGain;
                    subReverbTransitionStartTime = null;
                    subReverbTransitionDuration = 0;
                    
                    // Apply final value to synth
                    if (subSynth && subSynth.reverbGain) {
                        subSynth.reverbGain.gain.value = subReverbGain;
                    }
                    
                    // Final update to slider
                    const subReverbSlider = document.getElementById('subReverbSlider');
                    const subReverbDisplay = document.getElementById('subReverbDisplay');
                    if (subReverbSlider && subReverbDisplay) {
                        const finalReverbPercent = Math.round(targetSubReverbGain * 100);
                        subReverbSlider.value = finalReverbPercent;
                        subReverbDisplay.textContent = finalReverbPercent + '%';
                    }
                }
            }
        }
        
        function randomizeSynthParameters(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize water attack: 1-100ms (convert to seconds)
            const randomAttack = Math.floor(Math.random() * 100) + 1;
            targetAttackTime = randomAttack / 1000;
            
            // Randomize water 2nd harmonic only: 0-100% (convert to gain 0-1)
            const randomHarmonic2 = Math.floor(Math.random() * 101);
            targetHarmonic2Gain = randomHarmonic2 / 100;
            
            // Start smooth transitions
            // Note: We don't update sliders here - let updateParameterTransitions() handle smooth updates
            attackTransitionStartTime = now;
            attackTransitionStartValue = waterAttackTime;
            attackTransitionDuration = transitionDuration;
            
            harmonic2TransitionStartTime = now;
            harmonic2TransitionStartValue = waterHarmonic2Gain;
            harmonic2TransitionDuration = transitionDuration;
        }
        
        function randomizePluckyReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize plucky reverb: 3% to 40% (convert to gain 0.03 to 0.40)
            const randomReverb = Math.floor(Math.random() * 38) + 3; // 3 to 40
            targetPluckyReverbGain = randomReverb / 100;
            
            // Start smooth transition
            pluckyReverbTransitionStartTime = now;
            pluckyReverbTransitionStartValue = pluckyReverbGain;
            pluckyReverbTransitionDuration = transitionDuration;
        }
        
        function randomizeWaterReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize water reverb: 8% to 80% (convert to gain 0.08 to 0.80)
            const randomReverb = Math.floor(Math.random() * 73) + 8; // 8 to 80
            targetWaterReverbGain = randomReverb / 100;
            
            // Start smooth transition
            waterReverbTransitionStartTime = now;
            waterReverbTransitionStartValue = waterReverbGain;
            waterReverbTransitionDuration = transitionDuration;
        }
        
        function randomizeSubReverb(transitionCycles = 1) {
            const now = Tone.now();
            const masterCycleDuration240 = 240 / currentBPM;
            const transitionDuration = masterCycleDuration240 * transitionCycles;
            
            // Randomize sub reverb: 10% to 70% (convert to gain 0.1 to 0.7)
            const randomReverb = Math.floor(Math.random() * 61) + 10; // 10 to 70
            targetSubReverbGain = randomReverb / 100;
            
            // Start smooth transition
            subReverbTransitionStartTime = now;
            subReverbTransitionStartValue = subReverbGain;
            subReverbTransitionDuration = transitionDuration;
        }
        
        function setBPM(newBPM) {
            if (!isFinite(newBPM) || newBPM <= 0) {
                console.error('Invalid BPM value:', newBPM);
                return;
            }
            
            const slider = document.getElementById('bpmSlider');
            if (slider) {
                slider.value = newBPM;
            }
            
            document.getElementById('bpmDisplay').textContent = `${newBPM}BPM`;
            const duration = 240 / newBPM;
            document.getElementById('durationDisplay').textContent = `${duration.toFixed(2)}s`;
            
            if (isPlaying) {
                pendingBPM = newBPM;
            } else {
                currentBPM = newBPM;
            }
        }
        
        function updateBPM() {
            const slider = document.getElementById('bpmSlider');
            const newBPM = parseInt(slider.value);
            setBPM(newBPM);
        }
        
        function getCurrentChordNotes() {
            if (chordSequence.length === 0) return { bass: [], high: [] };
            const currentChord = chordSequence[currentChordIndex];
            return chordToMIDINotes(currentChord);
        }
        
        function handleProfileBehaviors(synthType, profile, currentBassDuration, currentHighDuration) {
            const gridId = synthType === 'water' ? 'waterGrid' : 'pluckyGrid';
            
            // Volume modulation randomization for profiles
            const volumeModulationOptions = ['triangle', 'ascend', 'descend'];
            
            // Drunk profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'drunk' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                if (synthType === 'water') {
                    waterVolumeModulation = randomModulation;
                    const select = document.getElementById('waterVolumeModulation');
                    if (select) select.value = randomModulation;
                } else if (synthType === 'plucky') {
                    pluckyVolumeModulation = randomModulation;
                    const select = document.getElementById('pluckyVolumeModulation');
                    if (select) select.value = randomModulation;
                }
            }
            
            // Creative profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'creative' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                if (synthType === 'water') {
                    waterVolumeModulation = randomModulation;
                    const select = document.getElementById('waterVolumeModulation');
                    if (select) select.value = randomModulation;
                } else if (synthType === 'plucky') {
                    pluckyVolumeModulation = randomModulation;
                    const select = document.getElementById('pluckyVolumeModulation');
                    if (select) select.value = randomModulation;
                }
            }
            
            // Lazy profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'lazy' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                if (synthType === 'water') {
                    waterVolumeModulation = randomModulation;
                    const select = document.getElementById('waterVolumeModulation');
                    if (select) select.value = randomModulation;
                } else if (synthType === 'plucky') {
                    pluckyVolumeModulation = randomModulation;
                    const select = document.getElementById('pluckyVolumeModulation');
                    if (select) select.value = randomModulation;
                }
            }
            
            // Threat profile: every 3 cycles has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'threat' && masterCycleNumber % 3 === 0 && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                if (synthType === 'water') {
                    waterVolumeModulation = randomModulation;
                    const select = document.getElementById('waterVolumeModulation');
                    if (select) select.value = randomModulation;
                } else if (synthType === 'plucky') {
                    pluckyVolumeModulation = randomModulation;
                    const select = document.getElementById('pluckyVolumeModulation');
                    if (select) select.value = randomModulation;
                }
            }
            
            // Creative profile: randomize synth parameters every cycle, transition over 3 cycles
            if (profile === 'creative') {
                if (synthType === 'water') {
                    randomizeSynthParameters(3);
                    randomizeWaterReverb(3);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(3);
                }
            }
            
            // Lazy profile: randomize synth parameters every cycle, transition over 3 cycles (same as creative, but NO cell selection)
            if (profile === 'lazy') {
                if (synthType === 'water') {
                    randomizeSynthParameters(3);
                    randomizeWaterReverb(3);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(3);
                }
            }
            
            // Drunk profile: randomize synth parameters every half cycle (every other cycle), transition over 1 cycle
            if (profile === 'drunk' && masterCycleNumber % 2 === 0) {
                if (synthType === 'water') {
                    randomizeSynthParameters(1);
                } else if (synthType === 'plucky') {
                    randomizePluckyReverb(1);
                }
            }
            
            // Creative profile: every 4 cycles, pick any random cell
            if (profile === 'creative') {
                if (synthType === 'water') {
                    waterCreativeCycleCounter++;
                    if (waterCreativeCycleCounter >= 4) {
                        waterCreativeCycleCounter = 0;
                        
                        // Find current active cell
                        let currentActiveRow = null;
                        let currentActiveCol = null;
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                                currentActiveRow = i;
                            }
                            if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                                currentActiveCol = i;
                            }
                        }
                        
                        if (currentActiveRow !== null && currentActiveCol !== null) {
                            // Pick any random cell
                            const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            
                            const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                            const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                            
                            if (bassDurationMultiplier && highDurationMultiplier) {
                                // Clear existing pending states for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                    c.classList.remove('pending');
                                });
                                
                                // Clear active cells for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                    c.classList.remove('active');
                                });
                                
                                // Set new pending cell
                                const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                                if (cell) {
                                    cell.classList.add('pending');
                                    waterPendingBassDuration = bassDurationMultiplier;
                                    waterPendingHighDuration = highDurationMultiplier;
                                    waterPendingCellRow = randomRow;
                                    waterPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                } else if (synthType === 'plucky') {
                    pluckyCreativeCycleCounter++;
                    if (pluckyCreativeCycleCounter >= 4) {
                        pluckyCreativeCycleCounter = 0;
                        
                        // Find current active cell
                        let currentActiveRow = null;
                        let currentActiveCol = null;
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                                currentActiveRow = i;
                            }
                            if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                                currentActiveCol = i;
                            }
                        }
                        
                        if (currentActiveRow !== null && currentActiveCol !== null) {
                            // Pick any random cell
                            const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                            
                            const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                            const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                            
                            if (bassDurationMultiplier && highDurationMultiplier) {
                                // Clear existing pending states for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                    c.classList.remove('pending');
                                });
                                
                                // Clear active cells for this grid
                                document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                    c.classList.remove('active');
                                });
                                
                                // Set new pending cell
                                const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                                if (cell) {
                                    cell.classList.add('pending');
                                    pluckyPendingBassDuration = bassDurationMultiplier;
                                    pluckyPendingHighDuration = highDurationMultiplier;
                                    pluckyPendingCellRow = randomRow;
                                    pluckyPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                }
            }
            
            // Drunk profile: 34% chance to randomly select a cell
            if (profile === 'drunk' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveRow = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                        currentActiveCol = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow) {
                                availableRows.push(i);
                            }
                        }
                        randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                    } else {
                        // Same row, different column
                        randomRow = currentActiveRow;
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                    const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                    
                    if (bassDurationMultiplier && highDurationMultiplier) {
                        // Clear existing pending states for this grid
                        document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                            c.classList.remove('pending');
                        });
                        
                        // Set new pending cell
                        const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                        if (cell) {
                            cell.classList.add('pending');
                            if (synthType === 'water') {
                                waterPendingBassDuration = bassDurationMultiplier;
                                waterPendingHighDuration = highDurationMultiplier;
                                waterPendingCellRow = randomRow;
                                waterPendingCellCol = randomCol;
                            } else {
                                pluckyPendingBassDuration = bassDurationMultiplier;
                                pluckyPendingHighDuration = highDurationMultiplier;
                                pluckyPendingCellRow = randomRow;
                                pluckyPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
            
            // Threat profile: 34% chance to randomly select a cell (never picks rows 1 or 2)
            if (profile === 'threat' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveRow = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentHighDuration) {
                        currentActiveCol = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row (but not row 1 or 2)
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow && i !== 1 && i !== 2) {
                                availableRows.push(i);
                            }
                        }
                        if (availableRows.length > 0) {
                            randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                        } else {
                            randomRow = null;
                        }
                    } else {
                        // Same row, different column (but if row is 1 or 2, pick different row)
                        randomRow = currentActiveRow;
                        if (randomRow === 1 || randomRow === 2) {
                            const availableRows = [];
                            for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                                if (i !== 1 && i !== 2) {
                                    availableRows.push(i);
                                }
                            }
                            if (availableRows.length > 0) {
                                randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                            } else {
                                randomRow = null;
                            }
                        }
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    if (randomRow !== null && randomCol !== null) {
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        const highDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        
                        if (bassDurationMultiplier && highDurationMultiplier) {
                            // Clear existing pending states for this grid
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                if (synthType === 'water') {
                                    waterPendingBassDuration = bassDurationMultiplier;
                                    waterPendingHighDuration = highDurationMultiplier;
                                    waterPendingCellRow = randomRow;
                                    waterPendingCellCol = randomCol;
                                } else {
                                    pluckyPendingBassDuration = bassDurationMultiplier;
                                    pluckyPendingHighDuration = highDurationMultiplier;
                                    pluckyPendingCellRow = randomRow;
                                    pluckyPendingCellCol = randomCol;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function handleSubProfileBehaviors(profile, currentBassDuration, currentOctaveDuration) {
            const gridId = 'subGrid';
            
            // Volume modulation randomization for profiles
            const volumeModulationOptions = ['triangle', 'ascend', 'descend'];
            
            // Drunk profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'drunk' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                subVolumeModulation = randomModulation;
                const select = document.getElementById('subVolumeModulation');
                if (select) select.value = randomModulation;
            }
            
            // Creative profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'creative' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                subVolumeModulation = randomModulation;
                const select = document.getElementById('subVolumeModulation');
                if (select) select.value = randomModulation;
            }
            
            // Lazy profile: every cycle has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'lazy' && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                subVolumeModulation = randomModulation;
                const select = document.getElementById('subVolumeModulation');
                if (select) select.value = randomModulation;
            }
            
            // Threat profile: every 3 cycles has 30% chance to change vol modulation to a random one next cycle
            if (profile === 'threat' && masterCycleNumber % 3 === 0 && Math.random() < 0.3) {
                const randomModulation = volumeModulationOptions[Math.floor(Math.random() * volumeModulationOptions.length)];
                subVolumeModulation = randomModulation;
                const select = document.getElementById('subVolumeModulation');
                if (select) select.value = randomModulation;
            }
            
            // Creative profile: every 4 cycles, pick any random cell
            if (profile === 'creative') {
                subCreativeCycleCounter++;
                if (subCreativeCycleCounter >= 4) {
                    subCreativeCycleCounter = 0;
                    
                    // Find current active cell
                    let currentActiveRow = null;
                    let currentActiveCol = null;
                    for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                        if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                            currentActiveCol = i;
                        }
                        if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                            currentActiveRow = i;
                        }
                    }
                    
                    if (currentActiveRow !== null && currentActiveCol !== null) {
                        // Pick any random cell
                        const randomRow = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                        const randomCol = Math.floor(Math.random() * (DURATION_MULTIPLIERS.length - 1)) + 1;
                        
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        
                        if (bassDurationMultiplier && octaveDurationMultiplier) {
                            // Clear existing pending states
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Clear active cells
                            document.querySelectorAll(`#${gridId} .grid-cell.active`).forEach(c => {
                                c.classList.remove('active');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                subPendingBassDuration = bassDurationMultiplier;
                                subPendingOctaveDuration = octaveDurationMultiplier;
                                subPendingCellRow = randomRow;
                                subPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
            
            // Drunk profile: 34% chance to randomly select a cell
            if (profile === 'drunk' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveCol = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                        currentActiveRow = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow) {
                                availableRows.push(i);
                            }
                        }
                        randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                    } else {
                        // Same row, different column
                        randomRow = currentActiveRow;
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                    const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                    
                    if (bassDurationMultiplier && octaveDurationMultiplier) {
                        // Clear existing pending states
                        document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                            c.classList.remove('pending');
                        });
                        
                        // Set new pending cell
                        const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                        if (cell) {
                            cell.classList.add('pending');
                            subPendingBassDuration = bassDurationMultiplier;
                            subPendingOctaveDuration = octaveDurationMultiplier;
                            subPendingCellRow = randomRow;
                            subPendingCellCol = randomCol;
                        }
                    }
                }
            }
            
            // Threat profile: 34% chance to randomly select a cell (never picks rows 1 or 2)
            if (profile === 'threat' && Math.random() < 0.34) {
                // Find current active cell
                let currentActiveRow = null;
                let currentActiveCol = null;
                for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                    if (DURATION_MULTIPLIERS[i] === currentBassDuration) {
                        currentActiveCol = i;
                    }
                    if (DURATION_MULTIPLIERS[i] === currentOctaveDuration) {
                        currentActiveRow = i;
                    }
                }
                
                if (currentActiveRow !== null && currentActiveCol !== null) {
                    let randomRow, randomCol;
                    
                    // Randomly choose: same column (different row) OR same row (different column)
                    if (Math.random() < 0.5) {
                        // Same column, different row (but not row 1 or 2)
                        randomCol = currentActiveCol;
                        const availableRows = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveRow && i !== 1 && i !== 2) {
                                availableRows.push(i);
                            }
                        }
                        if (availableRows.length > 0) {
                            randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                        } else {
                            randomRow = null;
                        }
                    } else {
                        // Same row, different column (but if row is 1 or 2, pick different row)
                        randomRow = currentActiveRow;
                        if (randomRow === 1 || randomRow === 2) {
                            const availableRows = [];
                            for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                                if (i !== 1 && i !== 2) {
                                    availableRows.push(i);
                                }
                            }
                            if (availableRows.length > 0) {
                                randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                            } else {
                                randomRow = null;
                            }
                        }
                        const availableCols = [];
                        for (let i = 1; i < DURATION_MULTIPLIERS.length; i++) {
                            if (i !== currentActiveCol) {
                                availableCols.push(i);
                            }
                        }
                        randomCol = availableCols[Math.floor(Math.random() * availableCols.length)];
                    }
                    
                    if (randomRow !== null && randomCol !== null) {
                        const bassDurationMultiplier = DURATION_MULTIPLIERS[randomCol];
                        const octaveDurationMultiplier = DURATION_MULTIPLIERS[randomRow];
                        
                        if (bassDurationMultiplier && octaveDurationMultiplier) {
                            // Clear existing pending states
                            document.querySelectorAll(`#${gridId} .grid-cell.pending`).forEach(c => {
                                c.classList.remove('pending');
                            });
                            
                            // Set new pending cell
                            const cell = document.querySelector(`#${gridId} .grid-cell[data-row="${randomRow}"][data-col="${randomCol}"]`);
                            if (cell) {
                                cell.classList.add('pending');
                                subPendingBassDuration = bassDurationMultiplier;
                                subPendingOctaveDuration = octaveDurationMultiplier;
                                subPendingCellRow = randomRow;
                                subPendingCellCol = randomCol;
                            }
                        }
                    }
                }
            }
        }
        
        function startPlaying() {
            if (!isFinite(currentBPM) || currentBPM <= 0) {
                console.error('Invalid BPM:', currentBPM);
                return;
            }
            
            if (!waterSynth || !pluckySynth || !subSynth) {
                console.error('Synths not initialized');
                return;
            }
            
            if (isPlaying) {
                stopPlaying();
            }
            
            isPlaying = true;
            
            // Set defaults if not set
            if (waterCurrentBassDuration === null) waterCurrentBassDuration = 240;
            if (waterCurrentHighDuration === null) waterCurrentHighDuration = 30;
            if (pluckyCurrentBassDuration === null) pluckyCurrentBassDuration = 240;
            if (pluckyCurrentHighDuration === null) pluckyCurrentHighDuration = 30;
            if (subCurrentBassDuration === null) subCurrentBassDuration = 240;
            if (subCurrentOctaveDuration === null) subCurrentOctaveDuration = 30;
            
            if (!masterVolume) {
                console.error('Master volume not initialized');
                return;
            }
            
            const masterCycleDuration240 = 240 / currentBPM;
            const now = Tone.now();
            
            masterCycleStartTime = now;
            masterCycleNumber = 0;
            waterCreativeCycleCounter = 0;
            pluckyCreativeCycleCounter = 0;
            subCreativeCycleCounter = 0;
            
            // Setup volume modulation for each synth separately
            if (waterSynth) {
                setupVolumeModulation(waterSynth, now, masterCycleDuration240, waterVolumeModulation);
            }
            if (pluckySynth) {
                setupVolumeModulation(pluckySynth, now, masterCycleDuration240, pluckyVolumeModulation);
            }
            if (subSynth) {
                setupVolumeModulation(subSynth, now, masterCycleDuration240, subVolumeModulation);
            }
            
            // Start water synth
            startSynthLayers('water', waterSynth, waterCurrentBassDuration, waterCurrentHighDuration, waterProfile);
            
            // Start plucky synth
            startSynthLayers('plucky', pluckySynth, pluckyCurrentBassDuration, pluckyCurrentHighDuration, pluckyProfile);
            
            // Start sub synth (sub-only - two durations)
            startSubSynthLayer(subSynth, subCurrentBassDuration, subCurrentOctaveDuration, subProfile);
            
            // Update debug display
            const chordNotes = getCurrentChordNotes();
            updateDebugDisplay(chordNotes.bass, chordNotes.high);
            
            // Clear any existing intervals before creating new ones
            if (cycleInterval) {
                clearInterval(cycleInterval);
                cycleInterval = null;
            }
            if (transitionUpdateInterval) {
                clearInterval(transitionUpdateInterval);
                transitionUpdateInterval = null;
            }
            
            // Master cycle interval for chord changes and profile behaviors
            cycleInterval = setInterval(() => {
                if (isPlaying) {
                    masterCycleNumber++;
                    resyncToMasterCycle();
                    checkAndApplyPendingChanges();
                    
                    // Handle profile behaviors for water synth
                    handleProfileBehaviors('water', waterProfile, waterCurrentBassDuration, waterCurrentHighDuration);
                    
                    // Handle profile behaviors for plucky synth
                    handleProfileBehaviors('plucky', pluckyProfile, pluckyCurrentBassDuration, pluckyCurrentHighDuration);
                    
                    // Handle profile behaviors for sub synth
                    handleSubProfileBehaviors(subProfile, subCurrentBassDuration, subCurrentOctaveDuration);
                    
                    // Advance to the "next" chord that was queued
                    if (chordSequence.length > 0) {
                        currentChordIndex = nextChordIndex;
                        nextChordIndex = (nextChordIndex + 1) % chordSequence.length;
                        updateChordDisplay();
                        updateChordSequenceDisplay();
                        
                        // Play new chord on both synths
                        const chordNotes = getCurrentChordNotes();
                        const noteDuration = 0.8;
                        
                        // Water synth
                        if (waterCurrentBassDuration && waterCurrentHighDuration) {
                            const waterBassCycle = waterCurrentBassDuration / currentBPM;
                            const waterHighCycle = waterCurrentHighDuration / currentBPM;
                            playBassLayer(chordNotes.bass, waterBassCycle * noteDuration, waterBassCycle, waterSynth, 'water');
                            playHighLayer(chordNotes.high, waterHighCycle * noteDuration, waterHighCycle, waterSynth, 'water', waterProfile, waterCurrentHighDuration);
                        }
                        
                        // Plucky synth
                        if (pluckyCurrentBassDuration && pluckyCurrentHighDuration) {
                            const pluckyBassCycle = pluckyCurrentBassDuration / currentBPM;
                            const pluckyHighCycle = pluckyCurrentHighDuration / currentBPM;
                            playBassLayer(chordNotes.bass, pluckyBassCycle * noteDuration, pluckyBassCycle, pluckySynth, 'plucky');
                            playHighLayer(chordNotes.high, pluckyHighCycle * noteDuration, pluckyHighCycle, pluckySynth, 'plucky', pluckyProfile, pluckyCurrentHighDuration);
                        }
                        
                        // Sub synth (sub-only - lowest note + octave lower)
                        if (subCurrentBassDuration && subCurrentOctaveDuration) {
                            const subBassCycle = subCurrentBassDuration / currentBPM;
                            const subOctaveCycle = subCurrentOctaveDuration / currentBPM;
                            playSubLayer(chordNotes.bass, subBassCycle * noteDuration, subOctaveCycle * noteDuration, subBassCycle, subOctaveCycle, subSynth);
                        }
                    }
                    
                    // Cleanup old voices (cycle-based: remove voices older than 4 cycles)
                    cleanupOldVoices();
                    
                    // Also cleanup voices that have finished playing (backup cleanup)
                    [waterSynth, pluckySynth, subSynth].forEach(synth => {
                        if (synth && synth.activeVoices) {
                            const now = Tone.now();
                            const finishedVoices = synth.activeVoices.filter(voice => {
                                return voice.stopTime && (now > voice.stopTime + 0.5);
                            });
                            finishedVoices.forEach(voice => {
                                try {
                                    const index = synth.activeVoices.indexOf(voice);
                                    if (index > -1) {
                                        synth.activeVoices.splice(index, 1);
                                        voice.dispose();
                                    }
                                } catch (e) {}
                            });
                        }
                    });
                }
            }, masterCycleDuration240 * 1000);
            
            // Update parameter transitions frequently
            transitionUpdateInterval = setInterval(() => {
                if (isPlaying) {
                    updateParameterTransitions();
                }
            }, 50);
        }
        
        function startSynthLayers(synthType, synth, bassDurationMultiplier, highDurationMultiplier, profile) {
            const bassCycleDuration = bassDurationMultiplier / currentBPM;
            const highCycleDuration = highDurationMultiplier / currentBPM;
            const noteDuration = 0.8;
            
            if (!isFinite(bassCycleDuration) || bassCycleDuration <= 0 ||
                !isFinite(highCycleDuration) || highCycleDuration <= 0) {
                console.error('Invalid cycle durations calculated for', synthType);
                return;
            }
            
            const chordNotes = getCurrentChordNotes();
            playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType);
            playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
            
            if (synthType === 'water') {
                // Clear any existing intervals before creating new ones
                if (waterBassInterval) {
                    clearInterval(waterBassInterval);
                    waterBassInterval = null;
                }
                if (waterHighInterval) {
                    clearInterval(waterHighInterval);
                    waterHighInterval = null;
                }
                waterBassInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType);
                    }
                }, bassCycleDuration * 1000);
                
                waterHighInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
                    }
                }, highCycleDuration * 1000);
            } else if (synthType === 'plucky') {
                // Clear any existing intervals before creating new ones
                if (pluckyBassInterval) {
                    clearInterval(pluckyBassInterval);
                    pluckyBassInterval = null;
                }
                if (pluckyHighInterval) {
                    clearInterval(pluckyHighInterval);
                    pluckyHighInterval = null;
                }
                pluckyBassInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playBassLayer(chordNotes.bass, bassCycleDuration * noteDuration, bassCycleDuration, synth, synthType);
                    }
                }, bassCycleDuration * 1000);
                
                pluckyHighInterval = setInterval(() => {
                    if (isPlaying) {
                        const chordNotes = getCurrentChordNotes();
                        playHighLayer(chordNotes.high, highCycleDuration * noteDuration, highCycleDuration, synth, synthType, profile, highDurationMultiplier);
                    }
                }, highCycleDuration * 1000);
            }
        }
        
        function startSubSynthLayer(synth, bassDurationMultiplier, octaveDurationMultiplier, profile) {
            const bassCycleDuration = bassDurationMultiplier / currentBPM;
            const octaveCycleDuration = octaveDurationMultiplier / currentBPM;
            const noteDuration = 0.8;
            
            if (!isFinite(bassCycleDuration) || bassCycleDuration <= 0 ||
                !isFinite(octaveCycleDuration) || octaveCycleDuration <= 0) {
                console.error('Invalid cycle duration calculated for sub synth');
                return;
            }
            
            const chordNotes = getCurrentChordNotes();
            playSubLayer(chordNotes.bass, bassCycleDuration * noteDuration, octaveCycleDuration * noteDuration, bassCycleDuration, octaveCycleDuration, synth);
            
            // Clear any existing intervals before creating new ones
            if (subBassInterval) {
                clearInterval(subBassInterval);
                subBassInterval = null;
            }
            if (subOctaveInterval) {
                clearInterval(subOctaveInterval);
                subOctaveInterval = null;
            }
            
            // Interval for lowest note (column tempo)
            subBassInterval = setInterval(() => {
                if (isPlaying) {
                    const chordNotes = getCurrentChordNotes();
                    const lowestNote = Math.min(...chordNotes.bass);
                    const frequency = midiToFrequency(lowestNote);
                    const validNoteDuration = bassCycleDuration * noteDuration;
                    synth.createSubVoice(frequency, validNoteDuration);
                }
            }, bassCycleDuration * 1000);
            
            // Interval for octave lower note (row tempo)
            subOctaveInterval = setInterval(() => {
                if (isPlaying) {
                    const chordNotes = getCurrentChordNotes();
                    const lowestNote = Math.min(...chordNotes.bass);
                    const octaveLowerNote = lowestNote - 12;
                    const octaveLowerFrequency = midiToFrequency(octaveLowerNote);
                    const validNoteDuration = octaveCycleDuration * noteDuration;
                    // Add 5-15ms random offset to prevent phase cancellation when both notes play together
                    const phaseOffset = 0.005 + (Math.random() * 0.01); // 5-15ms
                    setTimeout(() => {
                        if (isPlaying) {
                            synth.createSubVoice(octaveLowerFrequency, validNoteDuration);
                        }
                    }, phaseOffset * 1000);
                }
            }, octaveCycleDuration * 1000);
        }
        
        function playSubLayer(notes, bassNoteDuration, octaveNoteDuration, bassCycleDuration, octaveCycleDuration, synth) {
            if (!synth || !notes || notes.length === 0) {
                return;
            }
            
            const validBassNoteDuration = isFinite(bassNoteDuration) && bassNoteDuration > 0 ? bassNoteDuration : 0.8;
            const validOctaveNoteDuration = isFinite(octaveNoteDuration) && octaveNoteDuration > 0 ? octaveNoteDuration : 0.8;
            
            if (synth.activeVoices && synth.activeVoices.length > 50) {
                const toRemove = synth.activeVoices.slice(0, synth.activeVoices.length - 30);
                toRemove.forEach(voice => {
                    try {
                        voice.stop();
                        voice.dispose();
                    } catch (e) {}
                });
                synth.activeVoices = synth.activeVoices.slice(synth.activeVoices.length - 30);
            }
            
            // Play the lowest note (column tempo)
            const lowestNote = Math.min(...notes);
            const frequency = midiToFrequency(lowestNote);
            synth.createSubVoice(frequency, validBassNoteDuration);
            
            // Play an octave lower (row tempo) with a small delay to reduce phase interference
            const octaveLowerNote = lowestNote - 12;
            const octaveLowerFrequency = midiToFrequency(octaveLowerNote);
            // Add 5-15ms random offset to prevent phase cancellation when both notes play together
            const phaseOffset = 0.005 + (Math.random() * 0.01); // 5-15ms
            setTimeout(() => {
                if (isPlaying) {
                    synth.createSubVoice(octaveLowerFrequency, validOctaveNoteDuration);
                }
            }, phaseOffset * 1000);
        }
        
        function stopPlaying() {
            isPlaying = false;
            
            // Stop water synth intervals
            if (waterBassInterval) {
                clearInterval(waterBassInterval);
                waterBassInterval = null;
            }
            if (waterHighInterval) {
                clearInterval(waterHighInterval);
                waterHighInterval = null;
            }
            
            // Stop plucky synth intervals
            if (pluckyBassInterval) {
                clearInterval(pluckyBassInterval);
                pluckyBassInterval = null;
            }
            if (pluckyHighInterval) {
                clearInterval(pluckyHighInterval);
                pluckyHighInterval = null;
            }
            
            // Stop sub synth intervals
            if (subBassInterval) {
                clearInterval(subBassInterval);
                subBassInterval = null;
            }
            if (subOctaveInterval) {
                clearInterval(subOctaveInterval);
                subOctaveInterval = null;
            }
            
            if (cycleInterval) {
                clearInterval(cycleInterval);
                cycleInterval = null;
            }
            if (transitionUpdateInterval) {
                clearInterval(transitionUpdateInterval);
                transitionUpdateInterval = null;
            }
            
            if (waterSynth && waterSynth.cleanupVoices) {
                waterSynth.cleanupVoices();
            }
            if (pluckySynth && pluckySynth.cleanupVoices) {
                pluckySynth.cleanupVoices();
            }
            if (subSynth && subSynth.cleanupVoices) {
                subSynth.cleanupVoices();
            }
            
            // Don't reset durations - keep them for next start
            waterPendingBassDuration = null;
            waterPendingHighDuration = null;
            waterPendingCellRow = null;
            waterPendingCellCol = null;
            pluckyPendingBassDuration = null;
            pluckyPendingHighDuration = null;
            pluckyPendingCellRow = null;
            pluckyPendingCellCol = null;
            subPendingBassDuration = null;
            subPendingOctaveDuration = null;
            subPendingCellRow = null;
            subPendingCellCol = null;
            pendingBPM = null;
            masterCycleStartTime = null;
            masterCycleNumber = 0;
            waterCreativeCycleCounter = 0;
            pluckyCreativeCycleCounter = 0;
            subCreativeCycleCounter = 0;
            
            // Reset transition states
            attackTransitionStartTime = null;
            attackTransitionDuration = 0;
            harmonic2TransitionStartTime = null;
            harmonic2TransitionDuration = 0;
            
            // Clear pending state from cells
            document.querySelectorAll('.grid-cell.pending').forEach(c => {
                c.classList.remove('pending');
            });
            
            // Update debug display to show current chord notes (not playing)
            const chordNotes = getCurrentChordNotes();
            updateDebugDisplay(chordNotes.bass, chordNotes.high);
        }
        
        function updateChordDisplay() {
            if (chordSequence.length === 0) {
                updateDebugDisplay([], []);
                updateChordSequenceDisplay();
                return;
            }
            
            // Update chord sequence display
            updateChordSequenceDisplay();
            
            // Update debug display with current chord notes
            const chordNotes = getCurrentChordNotes();
            if (!isPlaying) {
                updateDebugDisplay(chordNotes.bass, chordNotes.high);
            }
            
            // If playing, restart with new chord (but not during auto-advance)
            // Auto-advance is handled in cycleInterval, so we don't restart here
        }
        
        function updateChordSequenceDisplay() {
            const list = document.getElementById('chordSequenceList');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (chordSequence.length === 0) {
                list.innerHTML = '<span style="color: #666;">No chord sequence</span>';
                return;
            }
            
            chordSequence.forEach((chord, index) => {
                const item = document.createElement('div');
                item.className = 'chord-sequence-item';
                if (index === currentChordIndex) {
                    // Green: Current chord playing
                    item.classList.add('current');
                } else if (index === nextChordIndex) {
                    // Blue: Next chord that will play
                    item.style.borderColor = '#2196F3';
                    item.style.background = 'rgba(33, 150, 243, 0.3)';
                }
                item.textContent = chord.original;
                list.appendChild(item);
            });
        }
        
        function nextChord() {
            if (chordSequence.length === 0) return;
            // Change the NEXT chord that will play (not the current one)
            nextChordIndex = (nextChordIndex + 1) % chordSequence.length;
            updateChordDisplay();
            // Don't restart playback - just queue the next chord
        }
        
        function prevChord() {
            if (chordSequence.length === 0) return;
            // Change the NEXT chord that will play (not the current one)
            nextChordIndex = (nextChordIndex - 1 + chordSequence.length) % chordSequence.length;
            updateChordDisplay();
            // Don't restart playback - just queue the next chord
        }
        
        function createGrid(gridId, synthType) {
            const grid = document.getElementById(gridId);
            const headers = ['', '240/bpm', '120/bpm', '60/bpm', '40/bpm', '30/bpm', '20/bpm'];
            
            // Sub grid is 7x7 like others (column = lowest note tempo, row = octave lower tempo)
            if (synthType === 'sub') {
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 7; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.synthType = synthType;
                        
                        if (row === 0 || col === 0) {
                            cell.className += ' header';
                            if (row === 0 && col === 0) {
                                cell.textContent = '';
                            } else if (row === 0) {
                                cell.className += ' col-header'; // First row = column headers (high notes)
                                cell.textContent = headers[col];
                            } else {
                                cell.className += ' row-header'; // First column = row headers (bass)
                                cell.textContent = headers[row];
                            }
                        } else {
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            cell.addEventListener('click', () => {
                                handleGridCellClick(row, col, synthType, cell);
                            });
                        }
                        
                        grid.appendChild(cell);
                    }
                }
            } else {
                // Regular 7x7 grid for water and plucky
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 7; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.synthType = synthType;
                        
                        if (row === 0 || col === 0) {
                            cell.className += ' header';
                            if (row === 0 && col === 0) {
                                cell.textContent = '';
                            } else if (row === 0) {
                                cell.className += ' col-header'; // First row = column headers (high notes)
                                cell.textContent = headers[col];
                            } else {
                                cell.className += ' row-header'; // First column = row headers (bass)
                                cell.textContent = headers[row];
                            }
                        } else {
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            cell.addEventListener('click', () => {
                                handleGridCellClick(row, col, synthType, cell);
                            });
                        }
                        
                        grid.appendChild(cell);
                    }
                }
            }
        }
        
        function handleGridCellClick(row, col, synthType, cell) {
            const bassDurationMultiplier = DURATION_MULTIPLIERS[row];
            const highDurationMultiplier = DURATION_MULTIPLIERS[col];
            
            if (!bassDurationMultiplier || !isFinite(bassDurationMultiplier) || bassDurationMultiplier <= 0 ||
                !highDurationMultiplier || !isFinite(highDurationMultiplier) || highDurationMultiplier <= 0) {
                console.error('Invalid duration multipliers');
                return;
            }
            
            if (synthType === 'water') {
                // Clear water grid active and pending states
                document.querySelectorAll('#waterGrid .grid-cell.active').forEach(c => {
                    c.classList.remove('active');
                });
                document.querySelectorAll('#waterGrid .grid-cell.pending').forEach(c => {
                    c.classList.remove('pending');
                });
                
                if (isPlaying) {
                    cell.classList.add('pending');
                    waterPendingBassDuration = bassDurationMultiplier;
                    waterPendingHighDuration = highDurationMultiplier;
                    waterPendingCellRow = row;
                    waterPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    waterCurrentBassDuration = bassDurationMultiplier;
                    waterCurrentHighDuration = highDurationMultiplier;
                    waterPendingCellRow = null;
                    waterPendingCellCol = null;
                }
            } else if (synthType === 'plucky') {
                // Clear plucky grid active and pending states
                document.querySelectorAll('#pluckyGrid .grid-cell.active').forEach(c => {
                    c.classList.remove('active');
                });
                document.querySelectorAll('#pluckyGrid .grid-cell.pending').forEach(c => {
                    c.classList.remove('pending');
                });
                
                if (isPlaying) {
                    cell.classList.add('pending');
                    pluckyPendingBassDuration = bassDurationMultiplier;
                    pluckyPendingHighDuration = highDurationMultiplier;
                    pluckyPendingCellRow = row;
                    pluckyPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    pluckyCurrentBassDuration = bassDurationMultiplier;
                    pluckyCurrentHighDuration = highDurationMultiplier;
                    pluckyPendingCellRow = null;
                    pluckyPendingCellCol = null;
                }
            } else if (synthType === 'sub') {
                // Clear sub grid active and pending states
                document.querySelectorAll('#subGrid .grid-cell.active').forEach(c => {
                    c.classList.remove('active');
                });
                document.querySelectorAll('#subGrid .grid-cell.pending').forEach(c => {
                    c.classList.remove('pending');
                });
                
                // Column = lowest note tempo, Row = octave lower tempo
                const octaveDurationMultiplier = DURATION_MULTIPLIERS[row];
                
                if (isPlaying) {
                    cell.classList.add('pending');
                    subPendingBassDuration = bassDurationMultiplier;
                    subPendingOctaveDuration = octaveDurationMultiplier;
                    subPendingCellRow = row;
                    subPendingCellCol = col;
                } else {
                    cell.classList.add('active');
                    subCurrentBassDuration = bassDurationMultiplier;
                    subCurrentOctaveDuration = octaveDurationMultiplier;
                    subPendingCellRow = null;
                    subPendingCellCol = null;
                }
            }
        }
        
        // ========== SELECTION SCREEN ==========
        function loadPresets() {
            const presetSelect = document.getElementById('presetSelect');
            const presets = window.CHORD_PRESETS || {};
            
            Object.keys(presets).forEach(key => {
                const preset = presets[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${preset.name} - ${preset.style}`;
                presetSelect.appendChild(option);
            });
        }
        
        function updateChordPreview() {
            const preview = document.getElementById('chordPreview');
            preview.innerHTML = '';
            
            if (chordSequence.length === 0) {
                preview.innerHTML = '<span style="color: #666;">No chords entered</span>';
                return;
            }
            
            chordSequence.forEach((chord, index) => {
                const item = document.createElement('div');
                item.className = 'chord-preview-item';
                if (index === currentChordIndex) {
                    item.classList.add('current');
                }
                item.textContent = chord.original;
                preview.appendChild(item);
            });
        }
        
        function handlePresetChange() {
            const presetSelect = document.getElementById('presetSelect');
            const presetInfo = document.getElementById('presetInfo');
            const chordInput = document.getElementById('chordInput');
            
            if (presetSelect.value) {
                const presets = window.CHORD_PRESETS || {};
                const preset = presets[presetSelect.value];
                
                if (preset) {
                    presetInfo.style.display = 'block';
                    presetInfo.innerHTML = `<strong>${preset.name}</strong> - ${preset.style}<br>${preset.description}`;
                    chordInput.value = preset.chords;
                    chordSequence = parseChordSequence(preset.chords);
                    currentChordIndex = 0;
                    nextChordIndex = chordSequence.length > 1 ? 1 : 0;
                    updateChordPreview();
                    
                    // Set BPM from preset if available
                    if (preset.bpm && isFinite(preset.bpm) && preset.bpm > 0) {
                        setBPM(preset.bpm);
                    }
                }
            } else {
                presetInfo.style.display = 'none';
            }
        }
        
        function handleChordInput() {
            const chordInput = document.getElementById('chordInput');
            const presetSelect = document.getElementById('presetSelect');
            
            if (chordInput.value.trim()) {
                presetSelect.value = '';
                document.getElementById('presetInfo').style.display = 'none';
                chordSequence = parseChordSequence(chordInput.value);
                currentChordIndex = 0;
                nextChordIndex = chordSequence.length > 1 ? 1 : 0;
                updateChordPreview();
            } else {
                chordSequence = [];
                currentChordIndex = 0;
                nextChordIndex = 0;
                updateChordPreview();
            }
        }
        
        function goToMainScreen() {
            if (chordSequence.length === 0) {
                alert('Please enter or select a chord sequence first.');
                return;
            }
            
            // Ensure BPM is set from preset if one is selected
            const presetSelect = document.getElementById('presetSelect');
            if (presetSelect && presetSelect.value) {
                const presets = window.CHORD_PRESETS || {};
                const preset = presets[presetSelect.value];
                if (preset && preset.bpm && isFinite(preset.bpm) && preset.bpm > 0) {
                    setBPM(preset.bpm);
                }
                
                // Randomly pick Water Profile (except 'none')
                const waterProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                const randomWaterProfile = waterProfileOptions[Math.floor(Math.random() * waterProfileOptions.length)];
                waterProfile = randomWaterProfile;
                const waterProfileSelect = document.getElementById('waterProfileSelect');
                if (waterProfileSelect) {
                    waterProfileSelect.value = randomWaterProfile;
                }
                
                // Randomly pick Plucky Profile (except 'none')
                const pluckyProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                const randomPluckyProfile = pluckyProfileOptions[Math.floor(Math.random() * pluckyProfileOptions.length)];
                pluckyProfile = randomPluckyProfile;
                const pluckyProfileSelect = document.getElementById('pluckyProfileSelect');
                if (pluckyProfileSelect) {
                    pluckyProfileSelect.value = randomPluckyProfile;
                }
                
                // Randomly pick Sub Profile (except 'none')
                const subProfileOptions = ['drunk', 'creative', 'lazy', 'threat'];
                const randomSubProfile = subProfileOptions[Math.floor(Math.random() * subProfileOptions.length)];
                subProfile = randomSubProfile;
                const subProfileSelect = document.getElementById('subProfileSelect');
                if (subProfileSelect) {
                    subProfileSelect.value = randomSubProfile;
                }
            }
            
            document.getElementById('selectionScreen').classList.add('hidden');
            document.getElementById('mainScreen').classList.add('visible');
            updateChordDisplay();
            updateChordSequenceDisplay();
        }
        
        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            loadPresets();
            
            // Randomly pick a preset to load
            const presetSelect = document.getElementById('presetSelect');
            if (presetSelect) {
                const presets = window.CHORD_PRESETS || {};
                const presetKeys = Object.keys(presets);
                if (presetKeys.length > 0) {
                    const randomKey = presetKeys[Math.floor(Math.random() * presetKeys.length)];
                    presetSelect.value = randomKey;
                    handlePresetChange();
                }
            }
            
            createGrid('waterGrid', 'water');
            createGrid('pluckyGrid', 'plucky');
            createGrid('subGrid', 'sub');
            updateBPM();
            
            document.getElementById('presetSelect').addEventListener('change', handlePresetChange);
            document.getElementById('chordInput').addEventListener('input', handleChordInput);
            document.getElementById('nextBtn').addEventListener('click', goToMainScreen);
            
            document.getElementById('prevBtn').addEventListener('click', prevChord);
            document.getElementById('nextChordBtn').addEventListener('click', nextChord);
            
            document.getElementById('waterProfileSelect').addEventListener('change', (e) => {
                waterProfile = e.target.value;
                waterCreativeCycleCounter = 0;
            });
            
            document.getElementById('pluckyProfileSelect').addEventListener('change', (e) => {
                pluckyProfile = e.target.value;
                pluckyCreativeCycleCounter = 0;
            });
            
            document.getElementById('subProfileSelect').addEventListener('change', (e) => {
                subProfile = e.target.value;
                subCreativeCycleCounter = 0;
            });
            
            document.getElementById('bpmSlider').addEventListener('input', updateBPM);
            
            // Tab switching (water tab handler moved above)
            
            // Sub synth volume control
            document.getElementById('subVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('subVolumeDisplay').textContent = volumeValue + '%';
                subVolumeGain = volumeValue / 100;
                if (subSynth && subSynth.outputVolume) {
                    subSynth.outputVolume.gain.value = subVolumeGain;
                }
            });
            
            // Sub synth controls
            document.getElementById('subReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('subReverbDisplay').textContent = reverbValue + '%';
                subReverbGain = reverbValue / 100;
                if (subSynth && subSynth.reverbGain) {
                    subSynth.reverbGain.gain.value = subReverbGain;
                }
            });
            
            document.getElementById('subAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('subAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                subAttackTime = attackValue / 1000;
            });
            
            document.getElementById('subSaturationSlider').addEventListener('input', (e) => {
                const saturationValue = parseInt(e.target.value);
                document.getElementById('subSaturationDisplay').textContent = saturationValue + '%';
                // Convert percentage to distortion value (0-1)
                subSaturationAmount = saturationValue / 100;
                if (subSynth && subSynth.saturation) {
                    subSynth.saturation.distortion = subSaturationAmount;
                }
            });
            
            // Sub volume modulation - applies on next cycle
            document.getElementById('subVolumeModulation').addEventListener('change', (e) => {
                subVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            document.getElementById('pluckyControlsTab').addEventListener('click', () => {
                document.getElementById('pluckyControlsTab').classList.add('active');
                document.getElementById('waterControlsTab').classList.remove('active');
                document.getElementById('subControlsTab').classList.remove('active');
                document.getElementById('pluckyControlsPanel').style.display = 'block';
                document.getElementById('waterControlsPanel').style.display = 'none';
                document.getElementById('subControlsPanel').style.display = 'none';
            });
            
            document.getElementById('subControlsTab').addEventListener('click', () => {
                document.getElementById('subControlsTab').classList.add('active');
                document.getElementById('waterControlsTab').classList.remove('active');
                document.getElementById('pluckyControlsTab').classList.remove('active');
                document.getElementById('subControlsPanel').style.display = 'block';
                document.getElementById('waterControlsPanel').style.display = 'none';
                document.getElementById('pluckyControlsPanel').style.display = 'none';
            });
            
            document.getElementById('waterControlsTab').addEventListener('click', () => {
                document.getElementById('waterControlsTab').classList.add('active');
                document.getElementById('pluckyControlsTab').classList.remove('active');
                document.getElementById('subControlsTab').classList.remove('active');
                document.getElementById('waterControlsPanel').style.display = 'block';
                document.getElementById('pluckyControlsPanel').style.display = 'none';
                document.getElementById('subControlsPanel').style.display = 'none';
            });
            
            // Water synth volume control
            document.getElementById('waterVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('waterVolumeDisplay').textContent = volumeValue + '%';
                waterVolumeGain = volumeValue / 100;
                if (waterSynth && waterSynth.outputVolume) {
                    waterSynth.outputVolume.gain.value = waterVolumeGain;
                }
            });
            
            // Water synth controls
            document.getElementById('waterReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('waterReverbDisplay').textContent = reverbValue + '%';
                waterReverbGain = reverbValue / 100;
                if (waterSynth && waterSynth.reverbGain) {
                    waterSynth.reverbGain.gain.value = waterReverbGain;
                }
            });
            
            document.getElementById('waterAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('waterAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                waterAttackTime = attackValue / 1000;
                attackTime = waterAttackTime; // Legacy compatibility
                // Cancel any ongoing transition for this parameter
                attackTransitionStartTime = null;
                attackTransitionDuration = 0;
                targetAttackTime = waterAttackTime;
            });
            
            document.getElementById('waterHarmonic2Slider').addEventListener('input', (e) => {
                const harmonicValue = parseInt(e.target.value);
                document.getElementById('waterHarmonic2Display').textContent = harmonicValue + '%';
                // Convert percentage to gain (0-1)
                waterHarmonic2Gain = harmonicValue / 100;
                harmonic2Gain = waterHarmonic2Gain; // Legacy compatibility
                // Cancel any ongoing transition for this parameter
                harmonic2TransitionStartTime = null;
                harmonic2TransitionDuration = 0;
                targetHarmonic2Gain = waterHarmonic2Gain;
            });
            
            // Plucky synth volume control
            document.getElementById('pluckyVolumeSlider').addEventListener('input', (e) => {
                const volumeValue = parseInt(e.target.value);
                document.getElementById('pluckyVolumeDisplay').textContent = volumeValue + '%';
                pluckyVolumeGain = volumeValue / 100;
                if (pluckySynth && pluckySynth.outputVolume) {
                    pluckySynth.outputVolume.gain.value = pluckyVolumeGain;
                }
            });
            
            // Plucky synth controls
            document.getElementById('pluckyReverbSlider').addEventListener('input', (e) => {
                const reverbValue = parseInt(e.target.value);
                document.getElementById('pluckyReverbDisplay').textContent = reverbValue + '%';
                pluckyReverbGain = reverbValue / 100;
                if (pluckySynth && pluckySynth.reverbGain) {
                    pluckySynth.reverbGain.gain.value = pluckyReverbGain;
                }
            });
            
            document.getElementById('pluckyAttackSlider').addEventListener('input', (e) => {
                const attackValue = parseInt(e.target.value);
                document.getElementById('pluckyAttackDisplay').textContent = attackValue + 'ms';
                // Convert milliseconds to seconds
                pluckyAttackTime = attackValue / 1000;
            });
            
            // Water volume modulation - applies on next cycle
            document.getElementById('waterVolumeModulation').addEventListener('change', (e) => {
                waterVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            // Plucky volume modulation - applies on next cycle
            document.getElementById('pluckyVolumeModulation').addEventListener('change', (e) => {
                pluckyVolumeModulation = e.target.value;
                // Don't restart - let resyncToMasterCycle() apply it on the next cycle
            });
            
            document.getElementById('editBtn').addEventListener('click', () => {
                if (isPlaying) {
                    stopPlaying();
                    const toggleBtn = document.getElementById('toggleBtn');
                    toggleBtn.textContent = 'Start';
                    toggleBtn.classList.remove('active');
                }
                document.getElementById('mainScreen').classList.remove('visible');
                document.getElementById('selectionScreen').classList.remove('hidden');
            });
            
            document.getElementById('toggleBtn').addEventListener('click', async () => {
                const btn = document.getElementById('toggleBtn');
                
                if (isPlaying) {
                    stopPlaying();
                    btn.textContent = 'Start';
                    btn.classList.remove('active');
                } else {
                    await initAudio();
                    
                    // Set defaults if no cells are selected
                    const waterActiveCell = document.querySelector('#waterGrid .grid-cell.active');
                    const pluckyActiveCell = document.querySelector('#pluckyGrid .grid-cell.active');
                    const subActiveCell = document.querySelector('#subGrid .grid-cell.active');
                    
                    if (!waterActiveCell) {
                        // Default water: row 1, column 5 (240/bpm, 30/bpm)
                        const defaultCell = document.querySelector(`#waterGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            waterCurrentBassDuration = 240;
                            waterCurrentHighDuration = 30;
                        }
                    } else {
                        const row = parseInt(waterActiveCell.dataset.row);
                        const col = parseInt(waterActiveCell.dataset.col);
                        waterCurrentBassDuration = DURATION_MULTIPLIERS[row];
                        waterCurrentHighDuration = DURATION_MULTIPLIERS[col];
                    }
                    
                    if (!pluckyActiveCell) {
                        // Default plucky: row 1, column 5 (240/bpm, 30/bpm)
                        const defaultCell = document.querySelector(`#pluckyGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            pluckyCurrentBassDuration = 240;
                            pluckyCurrentHighDuration = 30;
                        }
                    } else {
                        const row = parseInt(pluckyActiveCell.dataset.row);
                        const col = parseInt(pluckyActiveCell.dataset.col);
                        pluckyCurrentBassDuration = DURATION_MULTIPLIERS[row];
                        pluckyCurrentHighDuration = DURATION_MULTIPLIERS[col];
                    }
                    
                    if (!subActiveCell) {
                        // Default sub: row 1, column 5 (240/bpm for lowest, 30/bpm for octave)
                        const defaultCell = document.querySelector(`#subGrid .grid-cell[data-row="1"][data-col="5"]`);
                        if (defaultCell) {
                            defaultCell.classList.add('active');
                            subCurrentBassDuration = 240;
                            subCurrentOctaveDuration = 30;
                        }
                    } else {
                        const row = parseInt(subActiveCell.dataset.row);
                        const col = parseInt(subActiveCell.dataset.col);
                        subCurrentBassDuration = DURATION_MULTIPLIERS[col];
                        subCurrentOctaveDuration = DURATION_MULTIPLIERS[row];
                    }
                    
                    // Clear any pending cells
                    document.querySelectorAll('.grid-cell.pending').forEach(c => {
                        c.classList.remove('pending');
                    });
                    
                    startPlaying();
                    btn.textContent = 'Stop';
                    btn.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>

