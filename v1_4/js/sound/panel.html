<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Am7 Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #f5f5f5;
            overflow-x: hidden;
        }
        .header {
            background: white;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .header-item label {
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }
        .header-item select {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .header-item input[type="range"] {
            width: 100px;
        }
        .bpm-value {
            font-size: 12px;
            min-width: 30px;
        }
        .status {
            font-size: 11px;
            color: #666;
            padding: 4px 8px;
            background: #f0f0f0;
            border-radius: 3px;
        }
        .sound-diagram {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 2px;
            background: transparent;
            position: relative;
        }
        .sound-output {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            padding: 2px 6px;
            background: transparent;
            white-space: nowrap;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            width: 100%;
        }
        .sound-output:hover {
            background: rgba(102, 102, 102, 0.1);
        }
        .sound-output.active {
            background: rgba(102, 102, 102, 0.2);
            color: #333;
        }
        .sound-percentage {
            font-size: 10px;
            font-weight: normal;
            color: #666;
            min-width: 35px;
        }
        .sound-diagrams-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .layers-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .layer-select {
            padding: 2px 4px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 2px;
            background: #fff;
            cursor: pointer;
        }
        .connection-lines {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 0;
            overflow: visible;
        }
        .connection-lines svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .sound-diagram > * {
            position: relative;
            z-index: 1;
        }
        .test-panel {
            width: 100vw;
            height: 40vh;
            display: flex;
            position: relative;
            background: #e0e0e0;
        }
        .cycle-region {
            flex: 1;
            border-right: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }
        .cycle-region:last-child {
            border-right: none;
        }
        .cycle-region.active {
            background: #666;
            color: white;
        }
        .cycle-region.hover {
            background: #888;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-item">
            <label for="chordPalette">Chord:</label>
            <select id="chordPalette">
                <option value="Am7" selected>Am7</option>
                <option value="C">C</option>
                <option value="Cm">Cm</option>
                <option value="C7">C7</option>
                <option value="Dm">Dm</option>
                <option value="Dm7">Dm7</option>
                <option value="E">E</option>
                <option value="Em">Em</option>
                <option value="E7">E7</option>
                <option value="F">F</option>
                <option value="Fm">Fm</option>
                <option value="F7">F7</option>
                <option value="G">G</option>
                <option value="Gm">Gm</option>
                <option value="G7">G7</option>
                <option value="A">A</option>
                <option value="Am">Am</option>
                <option value="A7">A7</option>
                <option value="B">B</option>
                <option value="Bm">Bm</option>
                <option value="B7">B7</option>
                <option value="C#">C#</option>
                <option value="C#m">C#m</option>
                <option value="D#">D#</option>
                <option value="D#m">D#m</option>
                <option value="F#">F#</option>
                <option value="F#m">F#m</option>
                <option value="G#">G#</option>
                <option value="G#m">G#m</option>
                <option value="A#">A#</option>
                <option value="A#m">A#m</option>
                <option value="Cdim">Cdim</option>
                <option value="Caug">Caug</option>
                <option value="Cmaj7">Cmaj7</option>
                <option value="Amaj7">Amaj7</option>
            </select>
        </div>
        <div class="sound-diagrams-container">
            <div class="sound-diagram" id="soundDiagram1" title="SOUND1 is a merge of Layer 1 and Layer 2">
                <div class="connection-lines" id="connectionLines1"></div>
                <div class="layers-container" id="layersContainer1">
                    <div class="sound-output active" id="soundOutput1" data-sound="1">
                        <span>SOUND1</span>
                        <span class="sound-percentage" id="soundPercentage1">100%</span>
                    </div>
                    <select class="layer-select" id="layerSelect1_1"></select>
                    <select class="layer-select" id="layerSelect1_2"></select>
                </div>
            </div>
            <div class="sound-diagram" id="soundDiagram2" title="SOUND2 is a merge of Layer 1 and Layer 2">
                <div class="connection-lines" id="connectionLines2"></div>
                <div class="layers-container" id="layersContainer2">
                    <div class="sound-output" id="soundOutput2" data-sound="2">
                        <span>SOUND2</span>
                        <span class="sound-percentage" id="soundPercentage2">0%</span>
                    </div>
                    <select class="layer-select" id="layerSelect2_1"></select>
                    <select class="layer-select" id="layerSelect2_2"></select>
                </div>
            </div>
            <div class="sound-diagram" id="soundDiagram3" title="SOUND3 is a merge of Layer 1 and Layer 2">
                <div class="connection-lines" id="connectionLines3"></div>
                <div class="layers-container" id="layersContainer3">
                    <div class="sound-output" id="soundOutput3" data-sound="3">
                        <span>SOUND3</span>
                        <span class="sound-percentage" id="soundPercentage3">0%</span>
                    </div>
                    <select class="layer-select" id="layerSelect3_1"></select>
                    <select class="layer-select" id="layerSelect3_2"></select>
                </div>
            </div>
        </div>
        <div class="header-item">
            <label for="bpmSlider">BPM:</label>
            <input type="range" id="bpmSlider" min="60" max="200" value="120">
            <span class="bpm-value" id="bpmValue">120</span>
        </div>
        <div class="header-item">
            <label for="autoManageCheckbox">Auto Manage Sound:</label>
            <input type="checkbox" id="autoManageCheckbox">
        </div>
        <div class="status" id="status">Ready</div>
    </div>
    
    <div class="test-panel" id="testPanel">
        <div class="cycle-region" data-rate="240">240/bpm</div>
        <div class="cycle-region" data-rate="120">120/bpm</div>
        <div class="cycle-region" data-rate="60">60/bpm</div>
        <div class="cycle-region" data-rate="40">40/bpm</div>
        <div class="cycle-region" data-rate="30">30/bpm</div>
        <div class="cycle-region" data-rate="20">20/bpm</div>
        <div class="cycle-region" data-rate="15">15/bpm</div>
    </div>

    <!-- Load all required scripts -->
    <script src="../config.js"></script>
    <script src="synth-methods.js"></script>
    <script src="harmonic-content.js"></script>
    <script src="envelope-shapes.js"></script>
    <script src="harmonic-modulation.js"></script>
    <script src="sound-generator.js"></script>
    <script src="audio-manager.js"></script>
    <script src="../chord-parser.js"></script>
    
    <!-- Load reusable sound system modules -->
    <script src="sound-presets.js"></script>
    <script src="sound-generator-helper.js"></script>
    <script src="sound-manager.js"></script>
    
    <script>
        // Use presets from sound-presets.js module
        const presets = window.SoundPresets;
        
        // Use helper function from sound-generator-helper.js module
        const createSoundGeneratorFromPreset = window.createSoundGeneratorFromPreset;
        
        /* Original presets moved to sound-presets.js
        const presets = {
            'warm-plucked': {
                layer1: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'None' },
                layer2: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'None' }
            },
            'bright-bell': {
                layer1: { method: 'Additive', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Natural Decay' },
                layer2: { method: 'Additive', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Natural Decay' }
            },
            'vintage-rhodes': {
                layer1: { method: 'FM', harmonics: 'Tine', envelope: 'Rhodes', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'FM', harmonics: 'Tine', envelope: 'Rhodes', modulation: 'High-Freq Rolloff' }
            },
            'rich-pad': {
                layer1: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Pad', modulation: 'Dynamic Resonance' },
                layer2: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Pad', modulation: 'Dynamic Resonance' }
            },
            'metallic-organ': {
                layer1: { method: 'Waveform', harmonics: 'Organ', envelope: 'Organ', modulation: 'Formant Shift' },
                layer2: { method: 'Waveform', harmonics: 'Organ', envelope: 'Organ', modulation: 'Formant Shift' }
            },
            'brass-synth': {
                layer1: { method: 'Subtractive', harmonics: 'Brass', envelope: 'Synth', modulation: 'Subtle Vibrato' },
                layer2: { method: 'Subtractive', harmonics: 'Brass', envelope: 'Synth', modulation: 'Subtle Vibrato' }
            },
            'natural-piano': {
                layer1: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Piano', modulation: 'Natural Decay' },
                layer2: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Piano', modulation: 'Natural Decay' }
            },
            'ethereal-harp': {
                layer1: { method: 'Additive', harmonics: 'Detuned', envelope: 'Harp', modulation: 'Harmonic Evolution' },
                layer2: { method: 'Additive', harmonics: 'Detuned', envelope: 'Harp', modulation: 'Harmonic Evolution' }
            },
            'warm-bell': {
                layer1: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'None' },
                layer2: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'None' }
            },
            'crystal-pad': {
                layer1: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Pad', modulation: 'Decaying Filter' },
                layer2: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Pad', modulation: 'Decaying Filter' }
            },
            'dark-strings': {
                layer1: { method: 'Subtractive', harmonics: 'Harmonic', envelope: 'Warm', modulation: 'Decaying Filter' },
                layer2: { method: 'Additive', harmonics: 'Detuned', envelope: 'Pad', modulation: 'None' }
            },
            'bright-piano': {
                layer1: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Piano', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Piano', modulation: 'Natural Decay' }
            },
            'soft-pad': {
                layer1: { method: 'Additive', harmonics: 'Detuned', envelope: 'Pad', modulation: 'Dynamic Resonance' },
                layer2: { method: 'FM', harmonics: 'Harmonic', envelope: 'Pad', modulation: 'Subtle Vibrato' }
            },
            'metallic-bell': {
                layer1: { method: 'Waveform', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Formant Shift' },
                layer2: { method: 'Additive', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Natural Decay' }
            },
            'warm-strings': {
                layer1: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'Harmonic Evolution' },
                layer2: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Warm', modulation: 'None' }
            },
            'crystal-bell': {
                layer1: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Decaying Filter' },
                layer2: { method: 'Additive', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'High-Freq Rolloff' }
            },
            'vintage-organ': {
                layer1: { method: 'Waveform', harmonics: 'Organ', envelope: 'Organ', modulation: 'Formant Shift' },
                layer2: { method: 'FM', harmonics: 'Organ', envelope: 'Organ', modulation: 'Subtle Vibrato' }
            },
            'ethereal-pad': {
                layer1: { method: 'Additive', harmonics: 'Detuned', envelope: 'Pad', modulation: 'Harmonic Evolution' },
                layer2: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Pad', modulation: 'Dynamic Resonance' }
            },
            'brass-horn': {
                layer1: { method: 'Subtractive', harmonics: 'Brass', envelope: 'Synth', modulation: 'Subtle Vibrato' },
                layer2: { method: 'Physical Modeling', harmonics: 'Brass', envelope: 'Synth', modulation: 'Formant Shift' }
            },
            'plucked-harp': {
                layer1: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Harp', modulation: 'None' },
                layer2: { method: 'Additive', harmonics: 'Detuned', envelope: 'Harp', modulation: 'Natural Decay' }
            },
            'synth-lead': {
                layer1: { method: 'Subtractive', harmonics: 'Harmonic', envelope: 'Synth', modulation: 'Subtle Vibrato' },
                layer2: { method: 'FM', harmonics: 'Harmonic', envelope: 'Synth', modulation: 'Dynamic Resonance' }
            },
            'warm-organ': {
                layer1: { method: 'Waveform', harmonics: 'Organ', envelope: 'Organ', modulation: 'None' },
                layer2: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'Subtle Vibrato' }
            },
            'bright-harp': {
                layer1: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Harp', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Harp', modulation: 'Natural Decay' }
            },
            'dark-pad': {
                layer1: { method: 'Subtractive', harmonics: 'Harmonic', envelope: 'Pad', modulation: 'Decaying Filter' },
                layer2: { method: 'FM', harmonics: 'Detuned', envelope: 'Pad', modulation: 'None' }
            },
            'metallic-strings': {
                layer1: { method: 'Waveform', harmonics: 'Harmonic', envelope: 'Warm', modulation: 'Formant Shift' },
                layer2: { method: 'Additive', harmonics: 'Inharmonic', envelope: 'Warm', modulation: 'High-Freq Rolloff' }
            },
            'soft-bell': {
                layer1: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Bell', modulation: 'None' },
                layer2: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Bell', modulation: 'Natural Decay' }
            },
            'crystal-strings': {
                layer1: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Warm', modulation: 'Decaying Filter' },
                layer2: { method: 'Additive', harmonics: 'Detuned', envelope: 'Warm', modulation: 'Harmonic Evolution' }
            },
            'vintage-piano': {
                layer1: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Piano', modulation: 'Natural Decay' },
                layer2: { method: 'FM', harmonics: 'Tine', envelope: 'Piano', modulation: 'High-Freq Rolloff' }
            },
            'ethereal-bell': {
                layer1: { method: 'Additive', harmonics: 'Detuned', envelope: 'Bell', modulation: 'Harmonic Evolution' },
                layer2: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Dynamic Resonance' }
            },
            'warm-synth': {
                layer1: { method: 'Subtractive', harmonics: 'Detuned', envelope: 'Synth', modulation: 'None' },
                layer2: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Warm', modulation: 'Subtle Vibrato' }
            },
            'aggressive-lead': {
                layer1: { method: 'Subtractive', harmonics: 'Brass', envelope: 'Synth', modulation: 'Dynamic Resonance' },
                layer2: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Synth', modulation: 'Formant Shift' }
            },
            'mellow-pluck': {
                layer1: { method: 'Physical Modeling', harmonics: 'Simple', envelope: 'Pluck', modulation: 'Natural Decay' },
                layer2: { method: 'Additive', harmonics: 'Detuned', envelope: 'Pluck', modulation: 'None' }
            },
            'experimental-fm': {
                layer1: { method: 'FM', harmonics: 'Inharmonic', envelope: 'Pad', modulation: 'Harmonic Evolution' },
                layer2: { method: 'FM', harmonics: 'Simple', envelope: 'Synth', modulation: 'Decaying Filter' }
            },
            'vintage-strings': {
                layer1: { method: 'Waveform', harmonics: 'Harmonic', envelope: 'Warm', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'Physical Modeling', harmonics: 'Detuned', envelope: 'Warm', modulation: 'Natural Decay' }
            },
            'digital-pad': {
                layer1: { method: 'Additive', harmonics: 'Simple', envelope: 'Pad', modulation: 'Dynamic Resonance' },
                layer2: { method: 'FM', harmonics: 'Simple', envelope: 'Pad', modulation: 'Subtle Vibrato' }
            },
            'metallic-pluck': {
                layer1: { method: 'Subtractive', harmonics: 'Inharmonic', envelope: 'Pluck', modulation: 'Formant Shift' },
                layer2: { method: 'Waveform', harmonics: 'Inharmonic', envelope: 'Pluck', modulation: 'Decaying Filter' }
            },
            'warm-brass': {
                layer1: { method: 'Physical Modeling', harmonics: 'Brass', envelope: 'Warm', modulation: 'Subtle Vibrato' },
                layer2: { method: 'Additive', harmonics: 'Brass', envelope: 'Warm', modulation: 'Natural Decay' }
            },
            'crystal-organ': {
                layer1: { method: 'FM', harmonics: 'Organ', envelope: 'Organ', modulation: 'Harmonic Evolution' },
                layer2: { method: 'Additive', harmonics: 'Organ', envelope: 'Organ', modulation: 'High-Freq Rolloff' }
            },
            'dark-synth': {
                layer1: { method: 'Subtractive', harmonics: 'Detuned', envelope: 'Synth', modulation: 'Decaying Filter' },
                layer2: { method: 'Subtractive', harmonics: 'Harmonic', envelope: 'Synth', modulation: 'Decaying Filter' }
            },
            'bright-pluck': {
                layer1: { method: 'Additive', harmonics: 'Harmonic', envelope: 'Pluck', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'Physical Modeling', harmonics: 'Harmonic', envelope: 'Pluck', modulation: 'Natural Decay' }
            },
            'ethereal-simple': {
                layer1: { method: 'Physical Modeling', harmonics: 'Simple', envelope: 'Pad', modulation: 'Harmonic Evolution' },
                layer2: { method: 'Additive', harmonics: 'Simple', envelope: 'Pad', modulation: 'Dynamic Resonance' }
            },
            'aggressive-bell': {
                layer1: { method: 'Waveform', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Formant Shift' },
                layer2: { method: 'Subtractive', harmonics: 'Inharmonic', envelope: 'Bell', modulation: 'Dynamic Resonance' }
            },
            'vintage-pluck': {
                layer1: { method: 'FM', harmonics: 'Detuned', envelope: 'Pluck', modulation: 'High-Freq Rolloff' },
                layer2: { method: 'Physical Modeling', harmonics: 'Tine', envelope: 'Pluck', modulation: 'Natural Decay' }
            },
            'rich-brass': {
                layer1: { method: 'Additive', harmonics: 'Brass', envelope: 'Warm', modulation: 'Dynamic Resonance' },
                layer2: { method: 'Physical Modeling', harmonics: 'Brass', envelope: 'Warm', modulation: 'Harmonic Evolution' }
            },
            'experimental-pad': {
                layer1: { method: 'Subtractive', harmonics: 'Simple', envelope: 'Pad', modulation: 'Harmonic Evolution' },
                layer2: { method: 'FM', harmonics: 'Simple', envelope: 'Pad', modulation: 'Decaying Filter' }
            }
        };
        */
        
        /* Helper function moved to sound-generator-helper.js
        function createSoundGeneratorFromPreset(layerConfig) {
            // Get synth method
            const synthMethodMap = {
                'Physical Modeling': window.SynthMethods.PhysicalModeling,
                'Additive': window.SynthMethods.Additive,
                'FM': window.SynthMethods.FM,
                'Subtractive': window.SynthMethods.Subtractive,
                'Waveform': window.SynthMethods.Waveform
            };
            const SynthMethodClass = synthMethodMap[layerConfig.method];
            if (!SynthMethodClass) {
                throw new Error(`Unknown synth method: ${layerConfig.method}`);
            }
            const synthMethod = new SynthMethodClass();

            // Get harmonic content
            const harmonicMap = {
                'Harmonic': window.HarmonicContents.Harmonic,
                'Detuned': window.HarmonicContents.Detuned,
                'Inharmonic': window.HarmonicContents.Inharmonic,
                'Tine': window.HarmonicContents.Tine,
                'Brass': window.HarmonicContents.Brass,
                'Organ': window.HarmonicContents.Organ,
                'Simple': window.HarmonicContents.Simple
            };
            const HarmonicClass = harmonicMap[layerConfig.harmonics];
            if (!HarmonicClass) {
                throw new Error(`Unknown harmonics: ${layerConfig.harmonics}`);
            }
            const harmonicContent = new HarmonicClass();

            // Get envelope shape
            const envelopeMap = {
                'Piano': window.EnvelopeShapes.Piano,
                'Warm': window.EnvelopeShapes.Warm,
                'Rhodes': window.EnvelopeShapes.Rhodes,
                'Bell': window.EnvelopeShapes.Bell,
                'Harp': window.EnvelopeShapes.Harp,
                'Pad': window.EnvelopeShapes.Pad,
                'Organ': window.EnvelopeShapes.Organ,
                'Synth': window.EnvelopeShapes.Synth,
                'Pluck': window.EnvelopeShapes.Pluck
            };
            const EnvelopeClass = envelopeMap[layerConfig.envelope];
            if (!EnvelopeClass) {
                throw new Error(`Unknown envelope: ${layerConfig.envelope}`);
            }
            const envelopeShape = new EnvelopeClass();

            // Get modulation
            const modulationMap = {
                'None': window.HarmonicModulations.None,
                'Natural Decay': window.HarmonicModulations.NaturalDecay,
                'High-Freq Rolloff': window.HarmonicModulations.HighFreqRolloff,
                'Dynamic Resonance': window.HarmonicModulations.DynamicResonance,
                'Formant Shift': window.HarmonicModulations.FormantShift,
                'Subtle Vibrato': window.HarmonicModulations.SubtleVibrato,
                'Decaying Filter': window.HarmonicModulations.DecayingFilter,
                'Harmonic Evolution': window.HarmonicModulations.HarmonicEvolution
            };
            const ModulationClass = modulationMap[layerConfig.modulation];
            if (!ModulationClass) {
                throw new Error(`Unknown modulation: ${layerConfig.modulation}`);
            }
            const harmonicModulation = new ModulationClass();

            return new window.SoundGenerator(synthMethod, harmonicContent, envelopeShape, harmonicModulation);
        }
        */

        // Initialize
        let audioContext = null;
        let masterGain = null;
        let isPlaying = false;
        let shouldStop = false;
        let currentLoopTimeout = null;
        let layer1Sources = [];
        let layer2Sources = [];
        let layer1Gains = [];
        let layer2Gains = [];
        let currentCycleRate = 40; // Default rate
        let nextCycleRate = 40; // Rate for next cycle
        let isDragging = false;
        let currentRegionIndex = -1;
        let currentPitchShift = 0; // Semitones, -0.5 to +0.5
        let nextPitchShift = 0;
        let currentVolume = 0.9; // 0.05 to 0.9
        let nextVolume = 0.9;

        // Sound selection state
        let activeSound = 1; // Default to SOUND1
        let targetSound = 1;
        let isCrossfading = false;
        let crossfadeStartTime = null;
        let crossfadeDuration = 0;
        let currentSoundGains = { 1: null, 2: null, 3: null }; // Master gains for each sound
        let soundGenerators = { 1: null, 2: null, 3: null }; // Generators for each sound
        
        // Auto manage sound state
        let autoManageEnabled = false;
        let autoManageTimeout = null;

        // Populate layer dropdowns for all 3 sounds
        function populateLayerDropdowns() {
            const soundIds = [1, 2, 3];
            soundIds.forEach(soundNum => {
                const layer1Select = document.getElementById(`layerSelect${soundNum}_1`);
                const layer2Select = document.getElementById(`layerSelect${soundNum}_2`);
                
        Object.keys(presets).forEach(presetName => {
                    const option1 = document.createElement('option');
                    option1.value = presetName;
                    option1.textContent = presetName;
                    layer1Select.appendChild(option1);
            
            const option2 = document.createElement('option');
            option2.value = presetName;
            option2.textContent = presetName;
                    layer2Select.appendChild(option2);
                });
                
                // Set defaults
                layer1Select.value = 'warm-plucked';
                layer2Select.value = 'rich-pad';
            });
        }
        populateLayerDropdowns();
        
        // Initialize percentages on load
        updateSoundPercentages();
        
        // Update connection lines for a specific sound diagram
        function updateConnectionLines(soundNum) {
            const diagram = document.getElementById(`soundDiagram${soundNum}`);
            const soundOutput = document.getElementById(`soundOutput${soundNum}`);
            const layer1Select = document.getElementById(`layerSelect${soundNum}_1`);
            const layer2Select = document.getElementById(`layerSelect${soundNum}_2`);
            const connectionLines = document.getElementById(`connectionLines${soundNum}`);
            
            if (!diagram || !soundOutput || !layer1Select || !layer2Select) return;
            
            // Clear existing lines
            connectionLines.innerHTML = '';
            
            // Get positions relative to diagram
            const diagramRect = diagram.getBoundingClientRect();
            const soundRect = soundOutput.getBoundingClientRect();
            const layer1Rect = layer1Select.getBoundingClientRect();
            const layer2Rect = layer2Select.getBoundingClientRect();
            
            // Calculate relative positions
            // SOUND is now inside layers-container, so lines point from selects to SOUND
            const soundLeft = soundRect.left - diagramRect.left;
            const soundCenterY = (soundRect.top + soundRect.bottom) / 2 - diagramRect.top;
            const layer1Right = layer1Rect.right - diagramRect.left;
            const layer1CenterY = (layer1Rect.top + layer1Rect.bottom) / 2 - diagramRect.top;
            const layer2Right = layer2Rect.right - diagramRect.left;
            const layer2CenterY = (layer2Rect.top + layer2Rect.bottom) / 2 - diagramRect.top;
            
            // Create SVG for lines
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            
            // Line from Layer 1 to SOUND (pointing up/left)
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', layer1Right);
            line1.setAttribute('y1', layer1CenterY);
            line1.setAttribute('x2', soundLeft);
            line1.setAttribute('y2', soundCenterY);
            line1.setAttribute('stroke', '#666');
            line1.setAttribute('stroke-width', '2');
            line1.setAttribute('opacity', '0.6');
            line1.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(line1);
            
            // Line from Layer 2 to SOUND (pointing up/left)
            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', layer2Right);
            line2.setAttribute('y1', layer2CenterY);
            line2.setAttribute('x2', soundLeft);
            line2.setAttribute('y2', soundCenterY);
            line2.setAttribute('stroke', '#666');
            line2.setAttribute('stroke-width', '2');
            line2.setAttribute('opacity', '0.6');
            line2.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(line2);
            
            // Add arrowhead marker definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '0');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3, 0 6');
            polygon.setAttribute('fill', '#666');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            connectionLines.appendChild(svg);
        }
        
        // Update connection lines for all sounds
        function updateAllConnectionLines() {
            [1, 2, 3].forEach(soundNum => {
                setTimeout(() => updateConnectionLines(soundNum), 10);
            });
        }
        
        // Add change listeners for all layer selects
        [1, 2, 3].forEach(soundNum => {
            document.getElementById(`layerSelect${soundNum}_1`).addEventListener('change', () => updateConnectionLines(soundNum));
            document.getElementById(`layerSelect${soundNum}_2`).addEventListener('change', () => updateConnectionLines(soundNum));
        });
        
        updateAllConnectionLines(); // Initial update
        
        // Update lines on window resize
        window.addEventListener('resize', updateAllConnectionLines);
        
        // Sound selection handlers
        function selectSound(soundNum) {
            // Block selection if auto manage is enabled
            if (autoManageEnabled) return;
            
            if (soundNum === activeSound && !isCrossfading) return;
            
            targetSound = soundNum;
            
            // Update active visual state
            [1, 2, 3].forEach(num => {
                const output = document.getElementById(`soundOutput${num}`);
                if (num === soundNum) {
                    output.classList.add('active');
                } else {
                    output.classList.remove('active');
                }
            });
            
            // Update percentages
            updateSoundPercentages();
            
            // If playing, start crossfade immediately
            if (isPlaying) {
                startCrossfade();
            }
            // If not playing, we'll start crossfade when playback starts
        }
        
        // Lock/unlock sound selection and layer dropdowns
        function setSoundSelectionLocked(locked) {
            [1, 2, 3].forEach(soundNum => {
                // Lock sound outputs
                const output = document.getElementById(`soundOutput${soundNum}`);
                if (locked) {
                    output.style.pointerEvents = 'none';
                    output.style.opacity = '0.6';
                } else {
                    output.style.pointerEvents = 'auto';
                    output.style.opacity = '1';
                }
                
                // Lock layer dropdowns
                const layer1Select = document.getElementById(`layerSelect${soundNum}_1`);
                const layer2Select = document.getElementById(`layerSelect${soundNum}_2`);
                if (layer1Select) {
                    layer1Select.disabled = locked;
                    layer1Select.style.opacity = locked ? '0.6' : '1';
                }
                if (layer2Select) {
                    layer2Select.disabled = locked;
                    layer2Select.style.opacity = locked ? '0.6' : '1';
                }
            });
        }
        
        // Randomize layers for a specific sound
        function randomizeSoundLayers(soundNum) {
            const layer1Select = document.getElementById(`layerSelect${soundNum}_1`);
            const layer2Select = document.getElementById(`layerSelect${soundNum}_2`);
            const presetNames = Object.keys(presets);
            
            // Randomly select two different presets
            const random1 = presetNames[Math.floor(Math.random() * presetNames.length)];
            let random2 = presetNames[Math.floor(Math.random() * presetNames.length)];
            // Ensure they're different
            while (random2 === random1 && presetNames.length > 1) {
                random2 = presetNames[Math.floor(Math.random() * presetNames.length)];
            }
            
            layer1Select.value = random1;
            layer2Select.value = random2;
            
            // Invalidate generators so they get recreated with new layers
            soundGenerators[soundNum] = null;
        }
        
        // Get the two remaining sounds (not the active one)
        function getRemainingSounds() {
            return [1, 2, 3].filter(soundNum => soundNum !== activeSound);
        }
        
        // Auto manage: continuously crossfade between sounds
        function autoManageNextSound() {
            if (!autoManageEnabled || !isPlaying) return;
            
            // Get the 2 remaining sounds (not the current active one)
            const remainingSounds = getRemainingSounds();
            if (remainingSounds.length === 0) return;
            
            // Randomly select one of the remaining sounds
            const randomIndex = Math.floor(Math.random() * remainingSounds.length);
            const selectedSound = remainingSounds[randomIndex];
            
            // Randomize its layers BEFORE setting as target
            randomizeSoundLayers(selectedSound);
            
            // Set as target sound
            targetSound = selectedSound;
            
            // Update visual state
            [1, 2, 3].forEach(num => {
                const output = document.getElementById(`soundOutput${num}`);
                if (num === selectedSound) {
                    output.classList.add('active');
                } else {
                    output.classList.remove('active');
                }
            });
            
            // Start crossfade immediately
            startCrossfade();
        }
        
        // Start auto manage - begin continuous crossfading
        function startAutoManage() {
            if (!isPlaying || !autoManageEnabled) return;
            
            // Start the first crossfade immediately
            autoManageNextSound();
        }
        
        // Stop auto manage
        function stopAutoManage() {
            // Nothing to stop - crossfades handle themselves
        }
        
        // Add click handlers for sound outputs
        document.getElementById('soundOutput1').addEventListener('click', () => selectSound(1));
        document.getElementById('soundOutput2').addEventListener('click', () => selectSound(2));
        document.getElementById('soundOutput3').addEventListener('click', () => selectSound(3));
        
        // Auto manage checkbox handler
        const autoManageCheckbox = document.getElementById('autoManageCheckbox');
        autoManageCheckbox.addEventListener('change', (e) => {
            autoManageEnabled = e.target.checked;
            setSoundSelectionLocked(autoManageEnabled);
            
            if (autoManageEnabled) {
                // Start auto manage if playing (and not already crossfading)
                if (isPlaying && !isCrossfading) {
                    startAutoManage();
                }
            }
            // When disabled, user can control sounds again
        });
        
        // Update percentage displays for all sounds
        function updateSoundPercentages() {
            [1, 2, 3].forEach(soundNum => {
                const percentageEl = document.getElementById(`soundPercentage${soundNum}`);
                if (!percentageEl) return;
                
                let percentage = 0;
                if (currentSoundGains[soundNum]) {
                    // Get current gain value
                    percentage = Math.round(currentSoundGains[soundNum].gain.value * 100);
                } else if (soundNum === activeSound && !isCrossfading) {
                    // If it's the active sound and not crossfading, show 100%
                    percentage = 100;
                }
                
                percentageEl.textContent = `${percentage}%`;
            });
        }
        
        // Start crossfade between sounds
        function startCrossfade() {
            if (isCrossfading) return;
            if (targetSound === activeSound) return;
            
            isCrossfading = true;
            const bpm = parseInt(bpmSlider.value);
            crossfadeDuration = 960 / bpm; // 960/bpm seconds
            crossfadeStartTime = audioContext.currentTime;
            
            // Ensure both sound generators are created
            createSoundGenerators(activeSound);
            createSoundGenerators(targetSound);
            
            // Ensure active sound gain exists and is at 100%
            if (!currentSoundGains[activeSound]) {
                const activeGain = audioContext.createGain();
                activeGain.gain.value = 1.0;
                activeGain.connect(masterGain);
                currentSoundGains[activeSound] = activeGain;
            } else {
                // Make sure it's at 100% at the start of crossfade
                const currentGain = currentSoundGains[activeSound].gain.value;
                currentSoundGains[activeSound].gain.setValueAtTime(currentGain, crossfadeStartTime);
            }
            
            // Ensure target sound gain exists and starts at 0%
            if (!currentSoundGains[targetSound]) {
                const targetGain = audioContext.createGain();
                targetGain.gain.value = 0.0;
                targetGain.connect(masterGain);
                currentSoundGains[targetSound] = targetGain;
            }
            
            // Set up crossfade: activeSound fades from current level to 0%, targetSound fades from 0% to 100%
            const activeCurrentGain = currentSoundGains[activeSound].gain.value;
            currentSoundGains[activeSound].gain.setValueAtTime(activeCurrentGain, crossfadeStartTime);
            currentSoundGains[activeSound].gain.linearRampToValueAtTime(0.0, crossfadeStartTime + crossfadeDuration);
            
            currentSoundGains[targetSound].gain.setValueAtTime(0.0, crossfadeStartTime);
            currentSoundGains[targetSound].gain.linearRampToValueAtTime(1.0, crossfadeStartTime + crossfadeDuration);
            
            // Update percentages in real-time during crossfade
            const updateInterval = setInterval(() => {
                if (!isCrossfading) {
                    clearInterval(updateInterval);
                    updateSoundPercentages();
                    return;
                }
                
                const elapsed = audioContext.currentTime - crossfadeStartTime;
                if (elapsed >= crossfadeDuration) {
                    // Crossfade complete - set final values
                    updateSoundPercentages();
                    clearInterval(updateInterval);
                } else {
                    // Calculate current percentages based on elapsed time
                    // The Web Audio API handles the actual gain, we just display the progress
                    const progress = Math.min(1.0, elapsed / crossfadeDuration);
                    const activePercent = Math.round((1.0 - progress) * 100);
                    const targetPercent = Math.round(progress * 100);
                    
                    // Update display directly (Web Audio API handles actual gain)
                    const activePercentEl = document.getElementById(`soundPercentage${activeSound}`);
                    const targetPercentEl = document.getElementById(`soundPercentage${targetSound}`);
                    if (activePercentEl) activePercentEl.textContent = `${activePercent}%`;
                    if (targetPercentEl) targetPercentEl.textContent = `${targetPercent}%`;
                }
            }, 50); // Update every 50ms for smooth animation
            
            // Switch active sound after crossfade completes
            setTimeout(() => {
                activeSound = targetSound;
                isCrossfading = false;
                updateSoundPercentages();
                
                // If auto manage is enabled, immediately start next crossfade
                if (autoManageEnabled && isPlaying) {
                    autoManageNextSound();
                }
            }, crossfadeDuration * 1000);
        }
        
        // Create sound generators for a specific sound number
        function createSoundGenerators(soundNum) {
            if (soundGenerators[soundNum]) return; // Already created
            
            const layer1Select = document.getElementById(`layerSelect${soundNum}_1`);
            const layer2Select = document.getElementById(`layerSelect${soundNum}_2`);
            const layerName1 = layer1Select.value;
            const layerName2 = layer2Select.value;
            const layer1Preset = presets[layerName1];
            const layer2Preset = presets[layerName2];
            
            if (!layer1Preset || !layer2Preset) return;
            
            // Create generators
            const layer1Gen1 = createSoundGeneratorFromPreset(layer1Preset.layer1);
            const layer1Gen2 = createSoundGeneratorFromPreset(layer2Preset.layer1);
            const layer2Gen1 = createSoundGeneratorFromPreset(layer1Preset.layer2);
            const layer2Gen2 = createSoundGeneratorFromPreset(layer2Preset.layer2);
            
            soundGenerators[soundNum] = {
                layer1Gen1,
                layer1Gen2,
                layer2Gen1,
                layer2Gen2
            };
        }
        
        // Update generators when layer selects change
        [1, 2, 3].forEach(soundNum => {
            document.getElementById(`layerSelect${soundNum}_1`).addEventListener('change', () => {
                soundGenerators[soundNum] = null; // Invalidate to recreate
            });
            document.getElementById(`layerSelect${soundNum}_2`).addEventListener('change', () => {
                soundGenerators[soundNum] = null; // Invalidate to recreate
            });
        });

        // BPM slider
        const bpmSlider = document.getElementById('bpmSlider');
        const bpmValue = document.getElementById('bpmValue');
        bpmSlider.addEventListener('input', (e) => {
            bpmValue.textContent = e.target.value;
        });

        // Get region index from X coordinate
        function getRegionFromX(x) {
            const panel = document.getElementById('testPanel');
            const rect = panel.getBoundingClientRect();
            const relativeX = x - rect.left;
            const regionWidth = rect.width / 7;
            const regionIndex = Math.floor(relativeX / regionWidth);
            return Math.max(0, Math.min(6, regionIndex));
        }

        // Get pitch shift and volume from Y coordinate
        // Top = +0.5 semitone, 90% volume
        // Bottom = -0.5 semitone, 5% volume
        function getPitchAndVolumeFromY(y) {
            const panel = document.getElementById('testPanel');
            const rect = panel.getBoundingClientRect();
            const relativeY = y - rect.top;
            const height = rect.height;
            
            // Normalize Y position (0 = top, 1 = bottom)
            const normalizedY = Math.max(0, Math.min(1, relativeY / height));
            
            // Calculate pitch shift: +0.25 semitones at top, -0.25 at bottom (matches v1_4: ±25 cents)
            // Linear interpolation: pitchShift = 0.25 - normalizedY * 0.5
            const pitchShift = 0.25 - (normalizedY * 0.5); // Range: +0.25 to -0.25 semitones (±25 cents)
            
            // Calculate volume: 0.9 at top, 0.05 at bottom
            // Linear interpolation: volume = 0.9 - normalizedY * (0.9 - 0.05)
            const volume = 0.9 - (normalizedY * 0.85); // Range: 0.9 to 0.05
            
            return { pitchShift, volume };
        }

        // Convert semitone shift to frequency multiplier
        function semitonesToMultiplier(semitones) {
            return Math.pow(2, semitones / 12);
        }

        // Get cycle rate from region index
        function getCycleRateFromIndex(index) {
            const rates = [240, 120, 60, 40, 30, 20, 15];
            return rates[index];
        }

        // Update active region visual
        function updateActiveRegion(index, isHover = false) {
            const regions = document.querySelectorAll('.cycle-region');
            regions.forEach((region, i) => {
                region.classList.remove('active', 'hover');
                if (i === index) {
                    if (isHover && !isPlaying) {
                        region.classList.add('hover');
                    } else {
                        region.classList.add('active');
                    }
                }
            });
        }

        // Initialize audio context using AudioManager
        function initAudio() {
            // Initialize AudioManager (singleton)
            window.AudioManager.initialize();
            
            // Get audio context and master gain from AudioManager
            audioContext = window.AudioManager.getContext();
            masterGain = window.AudioManager.getMasterGain();
            
            // Resume if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Get chord frequencies from selected chord palette
        function getChordFrequencies() {
            const chordString = document.getElementById('chordPalette').value;
            
            // Handle special cases that the parser doesn't handle directly
            let rootNote = null;
            let chordType = 'major-triad';
            
            // Check for m7 (minor 7th) - must check before m and 7
            if (chordString.match(/^[A-G][#b]?m7$/i)) {
                rootNote = chordString.slice(0, -2); // Remove "m7"
                chordType = 'minor-7th';
            }
            // Check for maj7 (major 7th)
            else if (chordString.match(/^[A-G][#b]?maj7$/i)) {
                rootNote = chordString.slice(0, -4); // Remove "maj7"
                chordType = 'major-7th';
            }
            // Check for dim (diminished)
            else if (chordString.match(/^[A-G][#b]?dim$/i)) {
                rootNote = chordString.slice(0, -3); // Remove "dim"
                chordType = 'diminished-triad';
            }
            // Check for aug (augmented)
            else if (chordString.match(/^[A-G][#b]?aug$/i)) {
                rootNote = chordString.slice(0, -3); // Remove "aug"
                chordType = 'augmented-triad';
            }
            // Try standard parser for other chords (m, 7, etc.)
            else {
                const chord = ChordParser.parseChord(chordString);
                if (chord) {
                    rootNote = chord.rootNote;
                    chordType = chord.chordType;
                }
            }
            
            // Validate and get frequencies
            if (rootNote && Config.NOTE_TO_INDEX.hasOwnProperty(rootNote)) {
                return ChordParser.getChordFrequencies(rootNote, chordType);
            } else {
                // Fallback to Am7
                console.warn(`Could not parse chord: ${chordString}, using Am7`);
                return ChordParser.getChordFrequencies('A', 'minor-7th');
            }
        }

        // Play a cycle - uses active sound (or target sound if crossfading)
        async function playCycle(frequencies, bpm, cycleDuration, cycleRate, pitchShift, volume) {
            if (shouldStop) {
                // Was stopped before this cycle could start - clean up immediately
                isPlaying = false;
                shouldStop = false;
                document.getElementById('status').textContent = 'Ready';
                return;
            }

            const now = audioContext.currentTime;
            
            // During crossfade, we need to play both sounds
            // Also play both if targetSound is set but crossfade hasn't started yet
            const soundsToPlay = (isCrossfading || (targetSound !== activeSound && targetSound !== null)) 
                ? [activeSound, targetSound] 
                : [activeSound];
            
            // Play each sound
            soundsToPlay.forEach(soundNum => {
                // Ensure generators exist for this sound
                createSoundGenerators(soundNum);
                const generators = soundGenerators[soundNum];
                if (!generators) {
                    console.error(`No generators for sound ${soundNum}`);
                    return;
                }
                
                // Get or create sound gain node
                if (!currentSoundGains[soundNum]) {
                    const soundGain = audioContext.createGain();
                    // activeSound starts at 100%, targetSound starts at 0%
                    soundGain.gain.value = (soundNum === activeSound) ? 1.0 : 0.0;
                    soundGain.connect(masterGain);
                    currentSoundGains[soundNum] = soundGain;
                } else {
                    // If gain node exists, ensure correct initial value
                    if (soundNum === activeSound && !isCrossfading) {
                        currentSoundGains[soundNum].gain.setValueAtTime(1.0, now);
                    } else if (soundNum === targetSound && !isCrossfading) {
                        currentSoundGains[soundNum].gain.setValueAtTime(0.0, now);
                    }
                }
                const soundGain = currentSoundGains[soundNum];
                
                // Play this sound (will be called for each sound in the array)
                playSoundCycle(soundNum, generators, soundGain, frequencies, bpm, cycleDuration, cycleRate, pitchShift, volume, now);
            });
            
            // Schedule next cycle
            if (!shouldStop && isPlaying) {
                const nextBpm = parseInt(bpmSlider.value);
                const nextCycleDuration = (nextCycleRate * 60) / (nextBpm * nextBpm);
                
                currentLoopTimeout = setTimeout(() => {
                    if (isPlaying && !shouldStop) {
                        currentCycleRate = nextCycleRate;
                        currentPitchShift = nextPitchShift;
                        currentVolume = nextVolume;
                        playCycle(frequencies, nextBpm, nextCycleDuration, nextCycleRate, nextPitchShift, nextVolume);
                    } else {
                        isPlaying = false;
                        shouldStop = false;
                        currentRegionIndex = -1;
                        updateActiveRegion(-1);
                        document.getElementById('status').textContent = 'Ready';
                    }
                }, cycleDuration * 1000);
            } else if (shouldStop) {
                isPlaying = false;
                shouldStop = false;
                currentRegionIndex = -1;
                updateActiveRegion(-1);
                document.getElementById('status').textContent = 'Ready';
            }
        }
        
        // Play a single sound's cycle
        function playSoundCycle(soundNum, generators, soundGain, frequencies, bpm, cycleDuration, cycleRate, pitchShift, volume, now) {

            // Apply pitch shift to frequencies
            const pitchMultiplier = semitonesToMultiplier(pitchShift);
            const shiftedFrequencies = frequencies.map(freq => freq * pitchMultiplier);

            // Create gain nodes for volume control (Layer1 and Layer2 within the sound)
            const masterGain1 = audioContext.createGain();
            const masterGain2 = audioContext.createGain();
            
            // Connect through sound gain node
            masterGain1.connect(soundGain);
            masterGain2.connect(soundGain);

            // Start volumes: Layer1 at 80% * volume, Layer2 at 0%
            masterGain1.gain.setValueAtTime(0.8 * volume, now);
            masterGain2.gain.setValueAtTime(0.0, now);

            // After 0.1s, crossfade: Layer1 to 0%, Layer2 to 80% * volume
            masterGain1.gain.linearRampToValueAtTime(0.0, now + 0.1);
            masterGain2.gain.linearRampToValueAtTime(0.8 * volume, now + 0.1);

            // Play all frequencies for each layer - merges Layer 1 and Layer 2
            shiftedFrequencies.forEach(freq => {
                // Layer 1 - merge Layer 1 preset and Layer 2 preset
                const buffer1a = generators.layer1Gen1.generate(freq, 0.5, audioContext, cycleDuration, bpm, null);
                const buffer1b = generators.layer1Gen2.generate(freq, 0.5, audioContext, cycleDuration, bpm, null);
                
                // Mix the two buffers (SOUND1 = Layer 1 + Layer 2)
                const mixedBuffer1 = audioContext.createBuffer(1, buffer1a.length, audioContext.sampleRate);
                const channelData1 = mixedBuffer1.getChannelData(0);
                const data1a = buffer1a.getChannelData(0);
                const data1b = buffer1b.getChannelData(0);
                for (let i = 0; i < channelData1.length; i++) {
                    channelData1[i] = data1a[i] + data1b[i];
                }
                
                const source1 = audioContext.createBufferSource();
                source1.buffer = mixedBuffer1;
                source1.connect(masterGain1);
                source1.start(now);
                layer1Sources.push(source1);
                layer1Gains.push(masterGain1);

                // Layer 2 - merge Layer 1 preset and Layer 2 preset
                const buffer2a = generators.layer2Gen1.generate(freq, 0.5, audioContext, cycleDuration, bpm, null);
                const buffer2b = generators.layer2Gen2.generate(freq, 0.5, audioContext, cycleDuration, bpm, null);
                
                // Mix the two buffers (SOUND1 = Layer 1 + Layer 2)
                const mixedBuffer2 = audioContext.createBuffer(1, buffer2a.length, audioContext.sampleRate);
                const channelData2 = mixedBuffer2.getChannelData(0);
                const data2a = buffer2a.getChannelData(0);
                const data2b = buffer2b.getChannelData(0);
                for (let i = 0; i < channelData2.length; i++) {
                    channelData2[i] = data2a[i] + data2b[i];
                }
                
                const source2 = audioContext.createBufferSource();
                source2.buffer = mixedBuffer2;
                source2.connect(masterGain2);
                source2.start(now);
                layer2Sources.push(source2);
                layer2Gains.push(masterGain2);
            });
        }

        // Start playback with a specific cycle rate, pitch shift, and volume
        function startPlayback(cycleRate, pitchShift, volume) {
            // Reset any previous stop state
            shouldStop = false;
            if (currentLoopTimeout) {
                clearTimeout(currentLoopTimeout);
                currentLoopTimeout = null;
            }
            
            initAudio();
            isPlaying = true;
            shouldStop = false;
            currentCycleRate = cycleRate;
            nextCycleRate = cycleRate;
            currentPitchShift = pitchShift;
            nextPitchShift = pitchShift;
            currentVolume = volume;
            nextVolume = volume;
            
            // Check if we need to crossfade (targetSound is different from activeSound)
            if (targetSound !== activeSound && targetSound !== null) {
                // Start crossfade: activeSound at 100%, targetSound at 0%, then fade
                startCrossfade();
            } else {
                // No crossfade needed - just set up active sound
                // Create generators for active sound
                createSoundGenerators(activeSound);
                
            // Ensure sound gain node exists and is at full volume
            if (!currentSoundGains[activeSound]) {
                const soundGain = audioContext.createGain();
                soundGain.gain.value = 1.0;
                soundGain.connect(masterGain);
                currentSoundGains[activeSound] = soundGain;
            } else {
                // Reset to full volume if it exists
                currentSoundGains[activeSound].gain.setValueAtTime(1.0, audioContext.currentTime);
            }
            
            // Update percentages
            updateSoundPercentages();
            }

            // Get chord frequencies from palette
            const frequencies = getChordFrequencies();
            if (frequencies.length === 0) {
                const chordName = document.getElementById('chordPalette').value;
                alert(`Failed to parse chord: ${chordName}`);
                return;
            }

            // Get BPM and calculate cycle duration
            const bpm = parseInt(bpmSlider.value);
            const cycleDuration = (cycleRate * 60) / (bpm * bpm);

            document.getElementById('status').textContent = 'Playing...';

            // Start first cycle (pass generators for mixing)
            playCycle(frequencies, bpm, cycleDuration, cycleRate, pitchShift, volume);
            
            // Start auto manage if enabled
            if (autoManageEnabled) {
                startAutoManage();
            }
        }

        // Stop playback
        function stopPlayback() {
            if (!isPlaying) return;
            
            // Stop auto manage
            stopAutoManage();
            
            shouldStop = true;
            if (currentLoopTimeout) {
                clearTimeout(currentLoopTimeout);
                currentLoopTimeout = null;
            }
            
            // Prevent next cycle from starting
            // Current cycle will complete naturally when buffers end
            document.getElementById('status').textContent = 'Stopping after current cycle...';
            
            // Schedule cleanup after current cycle duration (worst case)
            const bpm = parseInt(bpmSlider.value);
            const cycleDuration = (currentCycleRate * 60) / (bpm * bpm);
            
            setTimeout(() => {
                if (shouldStop) {
                    isPlaying = false;
                    shouldStop = false;
                    currentRegionIndex = -1;
                    updateActiveRegion(-1);
                    document.getElementById('status').textContent = 'Ready';
                }
            }, cycleDuration * 1000 + 100); // Add small buffer
        }

        // Handle pointer down (mouse or touch)
        function handlePointerDown(e) {
            e.preventDefault();
            isDragging = true;
            
            const x = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const y = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            const regionIndex = getRegionFromX(x);
            const cycleRate = getCycleRateFromIndex(regionIndex);
            const { pitchShift, volume } = getPitchAndVolumeFromY(y);
            
            currentRegionIndex = regionIndex;
            updateActiveRegion(regionIndex);
            
            if (!isPlaying) {
                startPlayback(cycleRate, pitchShift, volume);
            } else {
                // Already playing - update next cycle rate, pitch, and volume
                nextCycleRate = cycleRate;
                nextPitchShift = pitchShift;
                nextVolume = volume;
            }
        }

        // Handle pointer move (while dragging)
        function handlePointerMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const x = e.type === 'mousemove' ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : null);
            const y = e.type === 'mousemove' ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : null);
            if (x === null || y === null) return;
            
            const regionIndex = getRegionFromX(x);
            const cycleRate = getCycleRateFromIndex(regionIndex);
            const { pitchShift, volume } = getPitchAndVolumeFromY(y);
            
            // Update visual feedback
            updateActiveRegion(regionIndex);
            
            // Update next cycle rate, pitch, and volume
            currentRegionIndex = regionIndex;
            nextCycleRate = cycleRate;
            nextPitchShift = pitchShift;
            nextVolume = volume;
            
            if (isPlaying) {
                const pitchDisplay = pitchShift >= 0 ? `+${pitchShift.toFixed(2)}` : pitchShift.toFixed(2);
                const volumeDisplay = Math.round(volume * 100);
                document.getElementById('status').textContent = `Playing... Next: ${cycleRate}/bpm, ${pitchDisplay}st, ${volumeDisplay}%`;
            }
        }

        // Handle pointer up (mouse or touch release)
        function handlePointerUp(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            isDragging = false;
            stopPlayback();
        }

        // Setup event handlers for test panel
        const testPanel = document.getElementById('testPanel');
        
        // Mouse events
        testPanel.addEventListener('mousedown', handlePointerDown);
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('mouseup', handlePointerUp);
        
        // Touch events - use { passive: false } to allow preventDefault
        testPanel.addEventListener('touchstart', handlePointerDown, { passive: false });
        document.addEventListener('touchmove', handlePointerMove, { passive: false });
        document.addEventListener('touchend', handlePointerUp, { passive: false });
        document.addEventListener('touchcancel', handlePointerUp, { passive: false });
    </script>
</body>
</html>

